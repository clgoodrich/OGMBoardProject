Index: ../main_process_board_matter.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nWellVisualizerMain.py\r\nAuthor: Colton Goodrich\r\nDate: 11/10/2024\r\nPython Version: 3.12\r\nThis module is a PyQt5 application that provides a graphical user interface (GUI) for\r\nvisualizing and analyzing well data, board matters, and related information from the\r\nState of Utah, Division of Oil, Gas, and Mining.\r\n\r\nThe application features various functionalities, including:\r\n\r\n- Interactive visualization of well trajectories in both 2D and 3D views, including\r\n  planned, currently drilling, and completed wells\r\n- Real-time well path visualization with different line styles for different well states\r\n  (planned: dashed, drilling: solid, completed: solid)\r\n- Advanced filtering system for wells based on type (oil, gas, water disposal, dry hole,\r\n  injection) and status (shut-in, PA, producing, drilling)\r\n- Mineral ownership visualization with section-level detail and agency tracking\r\n- Dynamic operator filtering system with color-coded checkboxes and scrollable interfaces\r\n- Production data visualization with cumulative and time-series analysis\r\n- Field boundary and plat code visualization with centroid labeling\r\n- Interactive well selection system with detailed data display\r\n- Customizable visualization features including zoom, pan, and scale adjustment\r\n\r\nClasses:\r\n- MultiBoldRowDelegate: A custom delegate for applying bold formatting to specific rows\r\n  in Qt views, particularly useful for emphasizing important wells\r\n- BoldDelegate: A custom delegate for applying bold formatting to specific values in\r\n  Qt views\r\n- wellVisualizationProcess: The main application class that inherits from QMainWindow\r\n  and BoardMattersVisualizer, handling all core functionality\r\n\r\nKey Components:\r\n- Data Management: Utilizes Pandas, GeoPandas, and SQLite for efficient data handling\r\n- Visualization: Combines Matplotlib with PyQt5 for interactive plotting\r\n- Geospatial Processing: Integrates UTM and Shapely for coordinate transformations\r\n  and geometric operations\r\n- User Interface: Custom-designed PyQt5 interface with scrollable areas and\r\n  dynamic updates\r\n\r\nThe module serves as a comprehensive tool for analyzing and visualizing well data,\r\nproviding detailed insights into well operations, ownership, and regulatory matters\r\nfor the State of Utah's Division of Oil, Gas, and Mining operations.\r\n\r\nDependencies:\r\n- Core Scientific: numpy, pandas, geopandas\r\n- GUI Framework: PyQt5\r\n- Visualization: matplotlib\r\n- Geospatial: shapely, utm\r\n- Database: sqlite3, sqlalchemy\r\n- Utility: regex\r\n\r\nNote: This application requires specific data structures and database connectivity\r\nto function properly. See accompanying documentation for setup requirements.\r\n\"\"\"\r\n\r\n# Python standard library imports\r\nimport itertools\r\nimport os\r\nimport sqlite3\r\nfrom datetime import datetime\r\nfrom typing import Callable, Dict, List, Literal, NoReturn, Optional, Set, Tuple, Union\r\n\r\n# Third-party imports - Core Data/Scientific\r\nimport numpy as np\r\nfrom numpy import array, std\r\nimport pandas as pd\r\nfrom pandas import DataFrame, concat, options, read_sql, set_option, to_datetime, to_numeric\r\nimport geopandas as gpd\r\nimport utm\r\nfrom sqlalchemy import create_engine\r\n\r\n# Third-party imports - PyQt5\r\nimport PyQt5\r\nfrom PyQt5.QtCore import QAbstractItemModel, QModelIndex, Qt\r\nfrom PyQt5.QtGui import QColor, QStandardItem, QStandardItemModel\r\nfrom PyQt5.QtWidgets import (\r\n    QApplication, QCheckBox, QGraphicsDropShadowEffect, QHeaderView,\r\n    QHBoxLayout, QLabel, QLayout, QMainWindow, QScrollArea,\r\n    QStyledItemDelegate, QTableWidget, QTableWidgetItem,\r\n    QVBoxLayout, QWidget\r\n)\r\n\r\n# Third-party imports - Matplotlib\r\nimport matplotlib.dates as mdates\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.axes import Axes\r\nfrom matplotlib.backend_bases import MouseEvent\r\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\r\nfrom matplotlib.collections import LineCollection, PatchCollection, PolyCollection\r\nfrom matplotlib.figure import Figure\r\nfrom matplotlib.lines import Line2D\r\nfrom matplotlib.patches import PathPatch, Polygon\r\nfrom matplotlib.text import Text\r\nfrom matplotlib.textpath import TextPath\r\nfrom matplotlib.ticker import FuncFormatter, ScalarFormatter\r\nfrom mpl_toolkits.mplot3d.art3d import Line3DCollection\r\n\r\n# Third-party imports - Geospatial\r\nfrom shapely import wkt\r\nfrom shapely.geometry import Point, Polygon\r\nfrom shapely.ops import unary_union\r\n\r\n# Third-party imports - Other\r\nimport regex as re\r\n\r\n# Local application imports\r\nfrom WellVisualizerBoardMatters import BoardMattersVisualizer\r\nfrom WellVisualizationUI import Ui_Dialog\r\nfrom main_process_well import Well\r\nfrom main_process_drawer import Drawer\r\n\r\n\r\nclass BoldDelegate(QStyledItemDelegate):\r\n    \"\"\"\r\n    A custom delegate class that applies bold formatting to specific values in a Qt view.\r\n\r\n    This delegate allows you to specify certain values that should be displayed in bold.\r\n    It's particularly useful when you want to emphasize specific items based on their\r\n    content in a QTableView or QListView.\r\n\r\n    Attributes:\r\n        bold_values (list or set): A collection of values that should be displayed in bold.\r\n\r\n    Args:\r\n        bold_values (list or set): The values that should be displayed in bold.\r\n        parent (QObject, optional): The parent object. Defaults to None.\r\n    \"\"\"\r\n\r\n    def __init__(self, bold_values, parent=None):\r\n        \"\"\"\r\n        Initialize the BoldDelegate.\r\n\r\n        Args:\r\n            bold_values (list or set): The values that should be displayed in bold.\r\n            parent (QObject, optional): The parent object. Defaults to None.\r\n        \"\"\"\r\n        # Step 1: Initialize the parent class\r\n        super().__init__(parent)\r\n\r\n        # Step 2: Store the bold_values for later use\r\n        self.bold_values = bold_values\r\n\r\n    def initStyleOption(self, option, index):\r\n        \"\"\"\r\n        Initialize the style options for the delegate.\r\n\r\n        This method is called by the view when it needs to paint an item. It sets\r\n        the font to bold if the item's data matches any value in bold_values.\r\n\r\n        Args:\r\n            option (QStyleOptionViewItem): The style options for the item.\r\n            index (QModelIndex): The model index of the item.\r\n        \"\"\"\r\n        # Step 1: Call the parent class's initStyleOption method\r\n        super().initStyleOption(option, index)\r\n\r\n        # Step 2: Check if the current item's data should be bold\r\n        if index.data() in self.bold_values:\r\n            # Step 3: If it should be bold, get the current font\r\n            font = option.font\r\n\r\n            # Step 4: Set the font to bold\r\n            font.setBold(True)\r\n\r\n            # Step 5: Apply the modified font to the option\r\n            option.font = font\r\n\r\n\r\nclass BoardMatter:\r\n    def __init__(self, ui, board_matter, df_board_matters, dx_df):\r\n        super().__init__()\r\n        self.ui = ui\r\n        self.dx_df = dx_df\r\n        well_lst = self.create_well_lst(df_board_matters)\r\n        self.populate_wells_combo_box(well_lst)\r\n        self.make_wells_bold_in_combobox(df_board_matters)\r\n        used_dx_df = dx_df[dx_df['apinumber'].isin(df_board_matters['well_id'].unique())]\r\n        used_dx_df = used_dx_df.drop_duplicates(keep='first')\r\n        print(used_dx_df)\r\n        self.Drawer = Drawer(self.ui, used_dx_df, df_board_matters)\r\n        self.ui.well_lst_combobox.activated.connect(lambda: self.do_this_when_wells_combo_box_pressed(df_board_matters))\r\n\r\n\r\n    def make_wells_bold_in_combobox(self, df):\r\n        masters_apds: List[str] = sorted(df[df['main_well'] == 1]['display_name'].unique())\r\n        delegate: QStyledItemDelegate = BoldDelegate(masters_apds)\r\n        self.ui.well_lst_combobox.setItemDelegate(delegate)\r\n\r\n    def create_well_lst(self, df):\r\n        unique_count: List[str] = sorted(df['display_name'].unique())\r\n        master_data: pd.DataFrame = df[df['main_well'] == 1]\r\n        masters_apds: List[str] = sorted(master_data['display_name'].unique())\r\n        sorted_list: List[str] = sorted([x for x in unique_count if x not in masters_apds])\r\n        well_lst: List[str] = masters_apds + sorted_list\r\n        return well_lst\r\n\r\n    def populate_wells_combo_box(self, well_lst):\r\n        self.ui.well_lst_combobox.clear()\r\n        model: QStandardItemModel = QStandardItemModel()\r\n        for item_text in well_lst:\r\n            item = QStandardItem(item_text)\r\n            model.appendRow(item)\r\n        self.ui.well_lst_combobox.setModel(model)\r\n\r\n    def do_this_when_wells_combo_box_pressed(self, df):\r\n        well_name: str = self.ui.well_lst_combobox.currentText()\r\n        well_obj = Well(ui=self.ui, well_name=well_name, df=df, dx_df = self.dx_df)\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../main_process_board_matter.py b/../main_process_board_matter.py
--- a/../main_process_board_matter.py	(revision 11c8d433909f415072d1821b99a7cb0108153144)
+++ b/../main_process_board_matter.py	(date 1743024294063)
@@ -175,9 +175,15 @@
         well_lst = self.create_well_lst(df_board_matters)
         self.populate_wells_combo_box(well_lst)
         self.make_wells_bold_in_combobox(df_board_matters)
-        used_dx_df = dx_df[dx_df['apinumber'].isin(df_board_matters['well_id'].unique())]
+        dx_df = dx_df.reset_index(drop=True)
+        # for idx, row in dx_df.iterrows():
+        #     print(row)
+        used_dx_df = dx_df[dx_df['api_number'].isin(df_board_matters['api_number'].unique())]
         used_dx_df = used_dx_df.drop_duplicates(keep='first')
-        print(used_dx_df)
+        # print(used_dx_df)
+        # print(used_dx_df['citing_type'].unique())
+        print(used_dx_df['citing_type'].unique())
+
         self.Drawer = Drawer(self.ui, used_dx_df, df_board_matters)
         self.ui.well_lst_combobox.activated.connect(lambda: self.do_this_when_wells_combo_box_pressed(df_board_matters))
 
Index: ../WellVisualizerMain.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nWellVisualizerMain.py\r\nAuthor: Colton Goodrich\r\nDate: 11/10/2024\r\nPython Version: 3.12\r\nThis module is a PyQt5 application that provides a graphical user interface (GUI) for\r\nvisualizing and analyzing well data, board matters, and related information from the\r\nState of Utah, Division of Oil, Gas, and Mining.\r\n\r\nThe application features various functionalities, including:\r\n\r\n- Interactive visualization of well trajectories in both 2D and 3D views, including\r\n  planned, currently drilling, and completed wells\r\n- Real-time well path visualization with different line styles for different well states\r\n  (planned: dashed, drilling: solid, completed: solid)\r\n- Advanced filtering system for wells based on type (oil, gas, water disposal, dry hole,\r\n  injection) and status (shut-in, PA, producing, drilling)\r\n- Mineral ownership visualization with section-level detail and agency tracking\r\n- Dynamic operator filtering system with color-coded checkboxes and scrollable interfaces\r\n- Production data visualization with cumulative and time-series analysis\r\n- Field boundary and plat code visualization with centroid labeling\r\n- Interactive well selection system with detailed data display\r\n- Customizable visualization features including zoom, pan, and scale adjustment\r\n\r\nClasses:\r\n- MultiBoldRowDelegate: A custom delegate for applying bold formatting to specific rows\r\n  in Qt views, particularly useful for emphasizing important wells\r\n- BoldDelegate: A custom delegate for applying bold formatting to specific values in\r\n  Qt views\r\n- wellVisualizationProcess: The main application class that inherits from QMainWindow\r\n  and BoardMattersVisualizer, handling all core functionality\r\n\r\nKey Components:\r\n- Data Management: Utilizes Pandas, GeoPandas, and SQLite for efficient data handling\r\n- Visualization: Combines Matplotlib with PyQt5 for interactive plotting\r\n- Geospatial Processing: Integrates UTM and Shapely for coordinate transformations\r\n  and geometric operations\r\n- User Interface: Custom-designed PyQt5 interface with scrollable areas and\r\n  dynamic updates\r\n\r\nThe module serves as a comprehensive tool for analyzing and visualizing well data,\r\nproviding detailed insights into well operations, ownership, and regulatory matters\r\nfor the State of Utah's Division of Oil, Gas, and Mining operations.\r\n\r\nDependencies:\r\n- Core Scientific: numpy, pandas, geopandas\r\n- GUI Framework: PyQt5\r\n- Visualization: matplotlib\r\n- Geospatial: shapely, utm\r\n- Database: sqlite3, sqlalchemy\r\n- Utility: regex\r\n\r\nNote: This application requires specific data structures and database connectivity\r\nto function properly. See accompanying documentation for setup requirements.\r\n\"\"\"\r\n\r\n# Python standard library imports\r\nimport itertools\r\nimport os\r\nimport sqlite3\r\nfrom datetime import datetime\r\nfrom typing import Callable, Dict, List, Literal, NoReturn, Optional, Set, Tuple, Union\r\n\r\n# Third-party imports - Core Data/Scientific\r\nimport numpy as np\r\nfrom numpy import array, std\r\nimport pandas as pd\r\nfrom pandas import DataFrame, concat, options, read_sql, set_option, to_datetime, to_numeric\r\nimport geopandas as gpd\r\nimport utm\r\nfrom sqlalchemy import create_engine\r\n\r\n# Third-party imports - PyQt5\r\nimport PyQt5\r\nfrom PyQt5.QtCore import QAbstractItemModel, QModelIndex, Qt\r\nfrom PyQt5.QtGui import QColor, QStandardItem, QStandardItemModel\r\nfrom PyQt5.QtWidgets import (\r\n    QApplication, QCheckBox, QGraphicsDropShadowEffect, QHeaderView,\r\n    QHBoxLayout, QLabel, QLayout, QMainWindow, QScrollArea,\r\n    QStyledItemDelegate, QTableWidget, QTableWidgetItem,\r\n    QVBoxLayout, QWidget\r\n)\r\n\r\n# Third-party imports - Matplotlib\r\nimport matplotlib.dates as mdates\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.axes import Axes\r\nfrom matplotlib.backend_bases import MouseEvent\r\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\r\nfrom matplotlib.collections import LineCollection, PatchCollection, PolyCollection\r\nfrom matplotlib.figure import Figure\r\nfrom matplotlib.lines import Line2D\r\nfrom matplotlib.patches import PathPatch, Polygon\r\nfrom matplotlib.text import Text\r\nfrom matplotlib.textpath import TextPath\r\nfrom matplotlib.ticker import FuncFormatter, ScalarFormatter\r\nfrom mpl_toolkits.mplot3d.art3d import Line3DCollection\r\n\r\n# Third-party imports - Geospatial\r\nfrom shapely import wkt\r\nfrom shapely.geometry import Point, Polygon\r\nfrom shapely.ops import unary_union\r\n\r\n# Third-party imports - Other\r\nimport regex as re\r\n\r\n# Local application imports\r\nfrom WellVisualizerBoardMatters import BoardMattersVisualizer\r\nfrom WellVisualizationUI import Ui_Dialog\r\n\r\n\r\n\"\"\"Function and class designed for creating bold values in the self.ui.well_lst_combobox, specifically bolding wells of importance.\"\"\"\r\n\r\n\r\nclass MultiBoldRowDelegate(QStyledItemDelegate):\r\n    \"\"\"\r\n    A custom delegate class that applies bold formatting to specific rows in a Qt view.\r\n\r\n    This delegate allows you to specify certain rows that should be displayed in bold.\r\n    It's particularly useful when you want to emphasize specific rows in a QTableView\r\n    or QListView.\r\n\r\n    Attributes:\r\n        bold_rows (set): A set containing the row indices that should be bold.\r\n\r\n    Args:\r\n        bold_rows (list or set): The row indices that should be displayed in bold.\r\n        parent (QObject, optional): The parent object. Defaults to None.\r\n    \"\"\"\r\n\r\n    def __init__(self, bold_rows, parent=None):\r\n        \"\"\"\r\n        Initialize the MultiBoldRowDelegate.\r\n\r\n        Args:\r\n            bold_rows (list or set): The row indices that should be displayed in bold.\r\n            parent (QObject, optional): The parent object. Defaults to None.\r\n        \"\"\"\r\n        # Step 1: Initialize the parent class\r\n        super().__init__(parent)\r\n\r\n        # Step 2: Convert bold_rows to a set for faster lookup and store it\r\n        self.bold_rows = set(bold_rows)\r\n\r\n    def initStyleOption(self, option, index):\r\n        \"\"\"\r\n        Initialize the style options for the delegate.\r\n\r\n        This method is called by the view when it needs to paint an item. It sets\r\n        the font to bold if the current row is in the bold_rows set.\r\n\r\n        Args:\r\n            option (QStyleOptionViewItem): The style options for the item.\r\n            index (QModelIndex): The model index of the item.\r\n        \"\"\"\r\n        # Step 1: Call the parent class's initStyleOption method\r\n        super().initStyleOption(option, index)\r\n\r\n        # Step 2: Check if the current row should be bold\r\n        if index.row() in self.bold_rows:\r\n            # Step 3: If it should be bold, set the font to bold\r\n            option.font.setBold(True)\r\n\r\nclass BoldDelegate(QStyledItemDelegate):\r\n    \"\"\"\r\n    A custom delegate class that applies bold formatting to specific values in a Qt view.\r\n\r\n    This delegate allows you to specify certain values that should be displayed in bold.\r\n    It's particularly useful when you want to emphasize specific items based on their\r\n    content in a QTableView or QListView.\r\n\r\n    Attributes:\r\n        bold_values (list or set): A collection of values that should be displayed in bold.\r\n\r\n    Args:\r\n        bold_values (list or set): The values that should be displayed in bold.\r\n        parent (QObject, optional): The parent object. Defaults to None.\r\n    \"\"\"\r\n\r\n    def __init__(self, bold_values, parent=None):\r\n        \"\"\"\r\n        Initialize the BoldDelegate.\r\n\r\n        Args:\r\n            bold_values (list or set): The values that should be displayed in bold.\r\n            parent (QObject, optional): The parent object. Defaults to None.\r\n        \"\"\"\r\n        # Step 1: Initialize the parent class\r\n        super().__init__(parent)\r\n\r\n        # Step 2: Store the bold_values for later use\r\n        self.bold_values = bold_values\r\n\r\n    def initStyleOption(self, option, index):\r\n        \"\"\"\r\n        Initialize the style options for the delegate.\r\n\r\n        This method is called by the view when it needs to paint an item. It sets\r\n        the font to bold if the item's data matches any value in bold_values.\r\n\r\n        Args:\r\n            option (QStyleOptionViewItem): The style options for the item.\r\n            index (QModelIndex): The model index of the item.\r\n        \"\"\"\r\n        # Step 1: Call the parent class's initStyleOption method\r\n        super().initStyleOption(option, index)\r\n\r\n        # Step 2: Check if the current item's data should be bold\r\n        if index.data() in self.bold_values:\r\n            # Step 3: If it should be bold, get the current font\r\n            font = option.font\r\n\r\n            # Step 4: Set the font to bold\r\n            font.setBold(True)\r\n\r\n            # Step 5: Apply the modified font to the option\r\n            option.font = font\r\n\r\nclass wellVisualizationProcess(QMainWindow, BoardMattersVisualizer):\r\n    checkbox_state_changed = PyQt5.QtCore.pyqtSignal(int, str, bool, PyQt5.QtGui.QColor)\r\n    def __init__(self, flag=True):\r\n        super().__init__()\r\n        set_option('display.max_columns', None)\r\n        options.mode.chained_assignment = None\r\n        self.combo_box_data = None\r\n        self.docket_ownership_data = None\r\n        self.used_plat_codes = None\r\n        self.df_adjacent_plats = None\r\n        self.df_adjacent_fields = None\r\n        self.field_labels = None\r\n        self.field_centroids_lst = None\r\n        self.df_shl = None\r\n        self.all_wells_model = None\r\n        self.df_all_wells_table = None\r\n        self.df_BoardData = None\r\n        self.df_BoardDataLinks = None\r\n        self.currently_drilling_segments_3d = None\r\n        self.currently_drilling_segments = None\r\n        self.planned_segments_3d = None\r\n        self.planned_segments = None\r\n        self.drilled_df = None\r\n        self.planned_df = None\r\n        self.currently_drilling_df = None\r\n        self.drilled_segments = None\r\n        self.drilled_segments_3d = None\r\n        self.ui = Ui_Dialog()\r\n        self.ui.setupUi(self)\r\n        self.wellsLoc = []\r\n        self.df = None\r\n        self.df_year, self.df_month, self.df_docket, self.wellsUsedInBoardOrder, self.df_docket_data, self.df_prod, self.df_tsr = None, None, None, None, None, None, None\r\n        self.used_sections, self.centroids_lst = None, None\r\n        self.currently_used_lines = None\r\n        self.drilled, self.planned, self.currently_drilling = (), (), ()\r\n        self.drilled_xy, self.planned_xy, self.currently_drilling_xy = {}, {}, {}\r\n        self.dx_df_asDrilled, self.dx_df_planned, self.dx_df, self.dx_data, self.df_plat = [], [], [], [], []\r\n        self.planned_xy_2d, self.planned_xy_3d, self.drilled_xy_2d, self.drilled_xy_3d, self.currently_drilling_xy_2d, self.currently_drilling_xy_3d = [], [], [], [], [], []\r\n        self.colors = [\"#000000\", \"#004949\", \"#009292\", \"#ff6db6\", \"#ffb6db\",\r\n                       \"#490092\", \"#006ddb\", \"#b66dff\", \"#6db6ff\", \"#b6dbff\",\r\n                       \"#920000\", \"#924900\", \"#db6d00\", \"#24ff24\", \"#ffff6d\",\r\n                       \"#999999\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\"]\r\n        self.type_checks = [self.ui.oil_well_check, self.ui.gas_well_check, self.ui.water_disposal_check, self.ui.dry_hole_check, self.ui.injection_check, self.ui.other_well_status_check]\r\n        self.status_checks = [self.ui.shut_in_check, self.ui.pa_check, self.ui.producing_check, self.ui.drilling_status_check, self.ui.producing_check]\r\n\r\n        self.ui.oil_well_check.setStyleSheet(f\"\"\"QCheckBox {{color: {'#c34c00'};}}\"\"\")\r\n        self.ui.gas_well_check.setStyleSheet(f\"\"\"QCheckBox {{color: {'#f1aa00'};}}\"\"\")\r\n        self.ui.water_disposal_check.setStyleSheet(f\"\"\"QCheckBox {{color: {'#0032b0'};}}\"\"\")\r\n        self.ui.dry_hole_check.setStyleSheet(f\"\"\"QCheckBox {{color: {'#4f494b'};}}\"\"\")\r\n        self.ui.injection_check.setStyleSheet(f\"\"\"QCheckBox {{color: {'#93ebff'};}}\"\"\")\r\n        self.ui.other_well_status_check.setStyleSheet(f\"\"\"QCheckBox {{color: {'#985bee'};}}\"\"\")\r\n        self.ui.producing_check.setStyleSheet(f\"\"\"QCheckBox {{color: {'#a2e361'};}}\"\"\")\r\n        self.ui.shut_in_check.setStyleSheet(f\"\"\"QCheckBox {{color: {'#D2B48C'};}}\"\"\")\r\n        self.ui.pa_check.setStyleSheet(f\"\"\"QCheckBox {{color: {'#4c2d77'};}}\"\"\")\r\n        self.ui.drilling_status_check.setStyleSheet(f\"\"\"QCheckBox {{color: {'#001958'};}}\"\"\")\r\n        self.ui.misc_well_type_check.setStyleSheet(f\"\"\"QCheckBox {{color: {'#4a7583'};}}\"\"\")\r\n\r\n        self.specific_well_data_model = QStandardItemModel()\r\n        self.operators_model = QStandardItemModel()\r\n        self.owner_model = QStandardItemModel()\r\n        self.agency_model = QStandardItemModel()\r\n\r\n        # Create a scroll area for checkboxes\r\n        self.checkbox_scroll_area = QScrollArea()\r\n        self.checkbox_scroll_area.setWidgetResizable(True)\r\n        self.checkbox_scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\r\n        self.checkbox_scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\r\n\r\n        # Create a widget to hold the checkboxes\r\n        self.checkbox_container = QWidget()\r\n        self.checkbox_layout = QVBoxLayout(self.checkbox_container)\r\n        self.checkbox_layout.setAlignment(Qt.AlignTop)\r\n        self.checkbox_layout.setContentsMargins(0, 0, 0, 0)\r\n        self.checkbox_layout.setSpacing(2)\r\n\r\n        # Set the checkbox container as the widget for the scroll area\r\n        self.checkbox_scroll_area.setWidget(self.checkbox_container)\r\n\r\n        # Create a horizontal layout to hold the checkbox scroll area and the existing layout\r\n        new_layout = QHBoxLayout()\r\n        new_layout.addWidget(self.checkbox_scroll_area)\r\n\r\n        # Move the existing layout into the new horizontal layout\r\n        existing_content = QWidget()\r\n        existing_content.setLayout(self.ui.operators_layout)\r\n        new_layout.addWidget(existing_content)\r\n        self.owner_scroll_area = QScrollArea()\r\n        self.owner_scroll_area.setWidgetResizable(True)\r\n        self.owner_scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\r\n        self.owner_scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)\r\n        self.owner_label_container = QWidget()\r\n        self.owner_layout = QVBoxLayout(self.owner_label_container)\r\n        self.owner_layout.setAlignment(Qt.AlignTop)\r\n        self.owner_layout.setContentsMargins(0, 0, 0, 0)\r\n        self.owner_layout.setSpacing(2)\r\n        self.owner_scroll_area.setWidget(self.owner_label_container)\r\n        new_layout_labels = QHBoxLayout()\r\n        new_layout_labels.addWidget(self.owner_scroll_area)\r\n        existing_content_owners = QWidget()\r\n        existing_content_owners.setLayout(self.ui.owner_layout)\r\n        new_layout_labels.addWidget(existing_content_owners)\r\n\r\n        # Set the new layout for the operator_model_widget\r\n        self.ui.operator_model_widget.setLayout(new_layout)\r\n        self.ui.owner_model_widget.setLayout(new_layout_labels)\r\n\r\n        self.checkbox_dict = {}  # Dictionary to store checkboxes\r\n        self.operator_checkbox_list = []  # List to store checkboxes in order\r\n        self.owner_label_list = []\r\n        self.agency_label_list = []\r\n        self.color_palette = self.generateColorPalette()\r\n        self.line_style = '-'\r\n        self.used_dockets, self.used_years, self.used_months = [], [], []\r\n        self.figure_plat = plt.figure()\r\n        self.canvas_plat = FigureCanvas(self.figure_plat)\r\n        self.ax_plat = self.figure_plat.subplots()\r\n        self.targeted_well_elevation = 0\r\n        self.selected_well_2d_path = []\r\n        self.selected_well_3d_path = []\r\n        self.targeted_well = \"00000000000\"\r\n        self.scale_factor = 1\r\n        self.line_prod_1, self.line_prod_2, self.line_prod_1_cum, self.line_prod_2_cum = None, None, None, None\r\n        \"\"\"2d graphic\"\"\"\r\n        \"\"\"Generate the graphic, the canvas, etc\"\"\"\r\n        self.figure2d = plt.figure()\r\n        self.canvas2d = FigureCanvas(self.figure2d)\r\n        self.ax2d = self.figure2d.subplots()\r\n        self.ui.well_graphic_mp_2d_model.addWidget(self.canvas2d)\r\n\r\n        \"\"\"This button press event is triggered when you click on a visible well. It will highlight the well, load information to the well, etc\"\"\"\r\n        self.canvas2d.mpl_connect('button_press_event', self.onClick2d)\r\n\r\n        \"\"\"Zoom function designed for zooming and panning. I stole this code from someone else and repurposed it.\"\"\"\r\n        self.zp = ZoomPan()\r\n        self.zoom_fac = self.zp.zoom_factory(self.ax2d, 1.1)\r\n        figPan = self.zp.pan_factory(self.ax2d)\r\n\r\n        \"\"\"These are specific empty plots and collections specifically for toggling visual data on and off. The idea is that as data selection changes and check boxes are activated or deactivated, \r\n        the code will dynamically update without having to fully redrawn the graphic.\"\"\"\r\n        self.spec_well_2d, = self.ax2d.plot([], [], c='purple', linewidth=3, linestyle=self.line_style, zorder=5)  ### graphing the selected well\r\n        self.spec_vertical_wells_2d = self.ax2d.scatter([], [], c='purple', s=25, zorder=5, alpha=0.5)  ### graphic for specific vertical wells. I'm pretty sure this is deprecated.\r\n        self.outlined_board_sections = PolyCollection([], zorder=3, alpha=0.2)  ### graphic for board matters. Will highlight specific sections.\r\n        self.ownership_sections = PolyCollection([], zorder=1, alpha=0.2)  ### graphic for showing mineral ownership. Currently disabled while I troubleshoot the data\r\n        self.ownership_sections_owner = PolyCollection([], zorder=1, alpha=0.8)  ### graphic for showing mineral ownership. Currently disabled while I troubleshoot the data\r\n        self.ownership_sections_agency = PolyCollection([], zorder=1, alpha=0.8)  ### graphic for showing mineral ownership. Currently disabled while I troubleshoot the data\r\n        self.field_sections = PolyCollection([], zorder=2, alpha=0.2)  ### graphic for showing oil fields.\r\n        self.all_vertical_wells_2d = self.ax2d.scatter([], [], c='black', s=15, zorder=5)  ### graphic for all vertical wells. I'm pretty sure this is deprecated.\r\n        self.all_wells_2d = LineCollection([], color='black', linewidth=0.5, linestyle=self.line_style, zorder=5)  ### graphic for all wells. I'm pretty sure this is deprecated.\r\n        self.all_wells_2d_planned = LineCollection([], color='black', linewidth=0.5, linestyle=\"--\", zorder=5)  ### graphic for all nonvertical wells that are currently planned but not being drilled.\r\n        self.all_wells_2d_asdrilled = LineCollection([], color='black', linewidth=0.5, linestyle=\"-\", zorder=5)  ### graphic for all nonvertical wells that are currently drilled\r\n        self.all_wells_2d_current = LineCollection([], color='blue', linewidth=0.5, linestyle=\"dotted\", zorder=5)  ### graphic for all nonvertical wells that are currently *being* drilled\r\n        self.all_wells_plat_labels, self.all_wells_plat_labels_for_editing = [], []  ### empty lists for labels\r\n        self.all_wells_2d_vertical_planned = self.ax2d.scatter([], [], c='black', s=5, zorder=5)  ### graphic for all vertical wells that are currently planned but not being drilled.\r\n        self.all_wells_2d_vertical_asdrilled = self.ax2d.scatter([], [], c='black', s=5, zorder=5)  ### graphic for all vertical wells that are currently drilled\r\n        self.all_wells_2d_vertical_current = self.ax2d.scatter([], [], c='blue', s=5, zorder=5)  ### graphic for all vertical wells that are currently *being* drilled\r\n        self.plats_2d = LineCollection([], color='black', linewidth=2, linestyle=self.line_style, zorder=4, alpha=0.5)  ### graphic for mapping township and range section data\r\n        self.plats_2d_main = LineCollection([], color='black', linewidth=4, linestyle=self.line_style, zorder=4)  ### graphic for mapping township and range section data\r\n        self.plats_2d_1adjacent = LineCollection([], color='black', linewidth=2, linestyle=self.line_style, zorder=4, alpha=0.75)  ### graphic for mapping township and range section data\r\n        self.plats_2d_2adjacent = LineCollection([], color='black', linewidth=2, linestyle=self.line_style, zorder=4, alpha=0.75)  ### graphic for mapping township and range section data\r\n        self.all_wells_2d_operators = []\r\n        self.all_wells_2d_operators_vertical = []\r\n        self.labels_plats_2d_main = PatchCollection([\r\n            PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\", zorder=1)\r\n            for coord, text in zip([], [])], facecolors=\"black\")  ### graphic for mapping township and range labels\r\n\r\n        self.labels_plats_2d_1adjacent = PatchCollection([\r\n            PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\", zorder=1)\r\n            for coord, text in zip([], [])], facecolors=\"black\")  ### graphic for mapping township and range labels\r\n\r\n        self.labels_plats_2d_2adjacent = PatchCollection([\r\n            PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\", zorder=1)\r\n            for coord, text in zip([], [])], facecolors=\"black\")  ### graphic for mapping township and range labels\r\n\r\n        self.labels_plats_2d = PatchCollection([\r\n            PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\", zorder=1)\r\n            for coord, text in zip([], [])], facecolors=\"black\")  ### graphic for mapping township and range labels\r\n\r\n        self.labels_field = PatchCollection([\r\n            PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\", zorder=1)\r\n            for coord, text in zip([], [])], facecolors=\"black\")  ### graphic for mapping oil and gas field labels\r\n        self.ui.board_matter_files.setOpenExternalLinks(True)\r\n\r\n        \"\"\"Add collections to the axes for each display item\"\"\"\r\n        self.ax2d.add_collection(self.outlined_board_sections)\r\n        self.ax2d.add_collection(self.ownership_sections_owner)\r\n        self.ax2d.add_collection(self.field_sections)\r\n        self.ax2d.add_collection(self.ownership_sections_agency)\r\n        self.ax2d.add_collection(self.all_wells_2d)\r\n        self.ax2d.add_collection(self.all_wells_2d_planned)\r\n        self.ax2d.add_collection(self.all_wells_2d_asdrilled)\r\n        self.ax2d.add_collection(self.all_wells_2d_current)\r\n        self.ax2d.add_collection(self.labels_plats_2d)\r\n        self.ax2d.add_collection(self.labels_field)\r\n        self.ax2d.add_collection(self.plats_2d)\r\n        self.ax2d.add_collection(self.plats_2d_main)\r\n        self.ax2d.add_collection(self.plats_2d_1adjacent)\r\n        self.ax2d.add_collection(self.plats_2d_2adjacent)\r\n        self.ax2d.add_collection(self.labels_plats_2d_main)\r\n        self.ax2d.add_collection(self.labels_plats_2d_1adjacent)\r\n        self.ax2d.add_collection(self.labels_plats_2d_2adjacent)\r\n        self.ax2d.axis('equal')\r\n\r\n        \"\"\"3d Graphic\"\"\"\r\n        \"\"\"Generate the graphic, the canvas, etc\"\"\"\r\n        self.all_wells_3d_data = []  # This should be filled with (x, y, z) tuples for each line\r\n        self.fig3d, self.ax3d = plt.subplots(subplot_kw={'projection': '3d'})\r\n        self.canvas3d = FigureCanvas(self.fig3d)\r\n        self.ui.well_graphic_mp_3d_model.addWidget(self.canvas3d)\r\n        self.ax3d.set_xlabel('Northing')\r\n        self.ax3d.set_ylabel('Easting')\r\n        self.ax3d.set_zlabel('TVD')\r\n        self.ax3d.view_init(elev=20., azim=0, roll=0)\r\n        self.centroid = [0, 0, 0]\r\n        self.fig3d.canvas.mpl_connect('scroll_event', lambda event: self.zoom(event, self.ax3d, self.centroid, self.fig3d))\r\n\r\n        \"\"\"These are specific empty plots and collections specifically for toggling visual data on and off. The idea is that as data selection changes and check boxes are activated or deactivated, \r\n        the code will dynamically update without having to fully redrawn the graphic.\"\"\"\r\n        self.spec_well_3d, = self.ax3d.plot([], [], [], c='purple', linewidth=3, linestyle=self.line_style, zorder=5)  ### graph the selected well in 3d\r\n        self.all_wells_3d = Line3DCollection([], colors='black', linewidth=0.5, linestyle='-', zorder=5)  ### graph all wells in 3d. Deprecated\r\n        self.all_wells_3d_planned = Line3DCollection([], colors='black', linewidth=0.5, linestyle='dashed', zorder=5)  ### graph all planned wells in 3d\r\n        self.all_wells_3d_asdrilled = Line3DCollection([], colors='black', linewidth=0.5, linestyle='solid', zorder=5)  ### graph all drilled wells in 3d\r\n        self.all_wells_3d_current = Line3DCollection([], colors='blue', linewidth=0.5, linestyle='dotted', zorder=5)  ### graph all currently drilling wells in 3d\r\n\r\n        \"\"\"Add collections to the axes for each display item\"\"\"\r\n        self.ax3d.add_collection(self.all_wells_3d)\r\n        self.ax3d.add_collection(self.all_wells_3d_planned)\r\n        self.ax3d.add_collection(self.all_wells_3d_asdrilled)\r\n        self.ax3d.add_collection(self.all_wells_3d_current)\r\n\r\n        \"\"\"3d Graphic solo\"\"\"\r\n        \"\"\"Generate the graphic, the canvas, etc\"\"\"\r\n        self.fig3d_solo, self.ax3d_solo = plt.subplots(subplot_kw={'projection': '3d'})\r\n        self.canvas3d_solo = FigureCanvas(self.fig3d_solo)\r\n        self.ui.well_graphic_mp_3d_model_2.addWidget(self.canvas3d_solo)\r\n        self.ax3d_solo.set_xlabel('Northing')\r\n        self.ax3d_solo.set_ylabel('Easting')\r\n        self.ax3d_solo.set_zlabel('TVD')\r\n        self.ax3d_solo.view_init(elev=20., azim=0, roll=0)\r\n        self.spec_well_3d_solo, = self.ax3d_solo.plot([], [], [], c='purple', linewidth=3, linestyle=self.line_style, zorder=5)  ### graph the selected well in 3d\r\n        self.fig3d_solo.canvas.mpl_connect('scroll_event', lambda event: self.zoom(event, self.ax3d_solo, self.centroid, self.fig3d_solo))\r\n\r\n        \"\"\"Prod Chart\"\"\"\r\n        fig_width = 2.6  # Adjust as needed (361 pixels / 80 dpi â‰ˆ 4.5 inches)\r\n        fig_height = 1.4\r\n\r\n        \"\"\"Generate the two production figures on their seperate tabs. #1 examines potential profit, #2 examines production values\"\"\"\r\n        self.fig_prod_1 = plt.figure(figsize=(fig_width, fig_height), constrained_layout=True)\r\n        self.canvas_prod_1 = FigureCanvas(self.fig_prod_1)\r\n        self.ax_prod_1 = self.fig_prod_1.add_subplot(111)\r\n        self.ui.well_graphic_production_1.addWidget(self.canvas_prod_1)\r\n\r\n        self.fig_prod_2 = plt.figure(figsize=(fig_width, fig_height), constrained_layout=True)\r\n        self.canvas_prod_2 = FigureCanvas(self.fig_prod_2)\r\n        self.ax_prod_2 = self.fig_prod_2.add_subplot(111)\r\n        self.ui.well_graphic_production_2.addWidget(self.canvas_prod_2)\r\n        self.ax_prod_1.set_xticks(self.ax_prod_1.get_xticks())\r\n        self.ax_prod_1.set_xticklabels(self.ax_prod_1.get_xticklabels(), rotation=45, ha='right')\r\n        self.ax_prod_2.set_xticks(self.ax_prod_2.get_xticks())\r\n        self.ax_prod_2.set_xticklabels(self.ax_prod_2.get_xticklabels(), rotation=45, ha='right')\r\n        self.current_prod = 'oil'  ### create an initial default for oil. fig 1 can switch between gas and oil\r\n\r\n        self.profit_line, = self.ax_prod_1.plot([], [], color='red', linewidth=2, zorder=1, label='Monthly Profit')\r\n        self.profit_line_cum, = self.ax_prod_1.plot([], [], color='black', linewidth=2, zorder=1,\r\n                                                    label='Cumulative Profit')\r\n        self.prod_line, = self.ax_prod_2.plot([], [], color='blue', linewidth=2, zorder=1, label='Monthly Production')\r\n        self.prod_line_cum, = self.ax_prod_2.plot([], [], color='black', linewidth=2, zorder=1,\r\n                                                  label='Cumulative Production')\r\n\r\n\r\n        \"\"\"Board Data\"\"\"\r\n        self.board_table_model = QStandardItemModel()\r\n        self.all_wells_model = QStandardItemModel()\r\n        self.used_plat_codes_for_boards = None\r\n        \"\"\"Assemble, organize, and produce the actual data from the .db item,\"\"\"\r\n        self.table_model = QStandardItemModel()\r\n        apd_data_dir = os.path.join(os.getcwd(), 'Board_DB.db')\r\n        self.conn_db = sqlite3.connect(apd_data_dir)\r\n        self.cursor_db = self.conn_db.cursor()\r\n        self.ui.show_polygon_board_checkbox.setChecked(True)\r\n\r\n        # Create SQLAlchemy engine\r\n        self.engine = create_engine(f'sqlite:///{apd_data_dir}')\r\n\r\n        \"\"\"Setup the tables so that they are prepped and ready to go.\"\"\"\r\n        self.setupTables()\r\n\r\n        \"\"\"Load the data to be used, process it, alter it, etc for usage\"\"\"\r\n        self.loadData()\r\n\r\n        \"\"\"Setup the initial data for the year. Presently only uses 2024\"\"\"\r\n        self.comboBoxSetupYear()\r\n        \"\"\"Setting up the radio buttons. Specifically their ID because QT Designer won't #@$@#$ing do it. This is for ease of reference when clicking different radio buttons\"\"\"\r\n\r\n\r\n        \"\"\"This is for the radio buttons that correspond to the years currently being displayed. IE, when was the well drilled? Last 10 years, 5 years, 1 year, any time\"\"\"\r\n        self.ui.drilling_within_button_group.setId(self.ui.radioButton_5, 0)\r\n        self.ui.drilling_within_button_group.setId(self.ui.radioButton_6, 1)\r\n        self.ui.drilling_within_button_group.setId(self.ui.radioButton_7, 2)\r\n        self.ui.drilling_within_button_group.setId(self.ui.radioButton_8, 3)\r\n\r\n        \"\"\"This alters the board data display page. This will allow you to either search by the board orders themselves, or to search by board orders affecting the section\"\"\"\r\n        self.ui.board_order_button_group.setId(self.ui.search_section_radio, 1)\r\n        self.ui.board_order_button_group.setId(self.ui.search_board_radio, 2)\r\n\r\n        \"\"\"UI Elements connections. Run these when events happen. Go figure.\"\"\"\r\n\r\n        \"\"\"Switch between gas and oil toggle\"\"\"\r\n        self.ui.prod_button_group.buttonClicked.connect(self.drawProductionGraphic)\r\n\r\n        \"\"\"Switch between applicable years toggle\"\"\"\r\n        self.ui.drilling_within_button_group.buttonClicked.connect(self.returnWellDataDependingOnParametersTest)\r\n\r\n        \"\"\"Toggle between displaying asDrilled wells\"\"\"\r\n        self.ui.asdrilled_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying planned wells\"\"\"\r\n        self.ui.planned_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying currently drilling wells\"\"\"\r\n        self.ui.currently_drilling_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying oil wells\"\"\"\r\n        self.ui.oil_well_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying gas wells\"\"\"\r\n        self.ui.gas_well_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying water disposal wells\"\"\"\r\n        self.ui.water_disposal_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying injection wells\"\"\"\r\n        self.ui.injection_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying all other wells\"\"\"\r\n        self.ui.other_well_status_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying shut-in wells\"\"\"\r\n        self.ui.dry_hole_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying producing wells\"\"\"\r\n        self.ui.producing_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying shut in wells\"\"\"\r\n        self.ui.shut_in_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying plugged and abandoned wells\"\"\"\r\n        self.ui.pa_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying drilling wells\"\"\"\r\n        self.ui.drilling_status_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying all other status wells\"\"\"\r\n        self.ui.misc_well_type_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying field names\"\"\"\r\n        self.ui.field_names_checkbox.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying township and range sections\"\"\"\r\n        self.ui.section_label_checkbox.stateChanged.connect(self.drawTSRPlat)\r\n\r\n        \"\"\"Do these when the combobox is changed via the user\"\"\"\r\n\r\n        \"\"\"Setup the month combo box when the user changes the relevant year\"\"\"\r\n        self.ui.year_lst_combobox.activated.connect(self.comboBoxSetupMonthWhenYearChanges)\r\n\r\n        \"\"\"Setup the docket combo box when the user changes the relevant month\"\"\"\r\n        self.ui.month_lst_combobox.activated.connect(self.comboBoxSetupBoardWhenMonthChanges)\r\n\r\n        \"\"\"Setup the wells combo box when the user changes the relevant docket data\"\"\"\r\n        self.ui.board_matter_lst_combobox.activated.connect(self.comboBoxSetupWellsWhenDocketChanges)\r\n\r\n        \"\"\"Setup the displays and information when a well is selected\"\"\"\r\n        self.ui.well_lst_combobox.activated.connect(self.comboUpdateWhenWellChanges)\r\n\r\n        \"\"\"Setup the Sections Combo Box for board orders (list sections)\"\"\"\r\n        self.ui.sectionsBoardComboBox.activated.connect(self.setupBoardMattersGraphic)\r\n\r\n        \"\"\"Setup the board orders combo box dependent on what was used in the previous sections box\"\"\"\r\n        self.ui.mattersBoardComboBox.activated.connect(self.updateBoardMatterDetails)\r\n\r\n        \"\"\"Setup the board orders box that just lists all board orders.\"\"\"\r\n        self.ui.board_matters_visible_combo.activated.connect(self.updateBoardMatterDetails)\r\n\r\n        \"\"\"Run this process when the radio button for searching for board orders is clicked or changed\"\"\"\r\n        self.ui.board_order_button_group.buttonClicked.connect(self.prodButtonsActivate)\r\n\r\n        \"\"\"This will toggle the polygon for the board data\"\"\"\r\n        self.ui.show_polygon_board_checkbox.stateChanged.connect(self.checkboxMakeVisible)\r\n        \"\"\"Run this when the table in All Wells is clicked. It should then highlight the appropriate wells. Note, nothing will happen if no wells are displayed\"\"\"\r\n        self.ui.all_wells_qtableview.clicked.connect(self.onRowClicked)\r\n\r\n        self.ui.ownership_button_group.buttonClicked.connect(self.ownershipSelection)\r\n        self.ui.ownership_checkbox.setEnabled(False)\r\n        self.ui.section_ownership_radio_complex.setEnabled(False)\r\n        self.ui.section_ownership_radio_simplified.setEnabled(False)\r\n        self.ui.well_type_or_status_button_group.buttonClicked.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n    def setupTables(self) -> None:\r\n        \"\"\"Initializes UI tables with empty QTableWidgetItems for data display.\r\n\r\n        Creates and sets up the initial state of three well data tables and one\r\n        board data table in the user interface. Each table is populated with empty\r\n        QTableWidgetItem instances to prepare for later data insertion.\r\n\r\n        Table Structure:\r\n            - Well Data Tables (3):\r\n                - 1 row x 12 columns each\r\n                - All cells initialized as empty\r\n            - Board Data Table:\r\n                - 3 rows x 1 column\r\n                - All cells initialized as empty\r\n\r\n        Side Effects:\r\n            Modifies the following UI components:\r\n            - self.ui.well_data_table_1\r\n            - self.ui.well_data_table_2\r\n            - self.ui.well_data_table_3\r\n            - self.ui.board_data_table\r\n\r\n        Note:\r\n            This method should be called once during UI initialization before\r\n            any data population occurs.\r\n\r\n        Raises:\r\n            AttributeError: If any of the required UI table widgets are not properly initialized.\r\n        \"\"\"\r\n        # Initialize list of well data tables for batch processing\r\n        well_tables: List[QTableWidget] = [\r\n            self.ui.well_data_table_1,\r\n            self.ui.well_data_table_2,\r\n            self.ui.well_data_table_3\r\n        ]\r\n\r\n        # Initialize all well data tables (12 columns x 1 row each)\r\n        for table in well_tables:  # type: QTableWidget\r\n            for column in range(12):  # Create empty cells across all columns\r\n                empty_item = QTableWidgetItem()  # Create empty cell\r\n                table.setItem(0, column, empty_item)  # Set cell in first row\r\n\r\n        # Initialize board data table (1 column x 3 rows)\r\n        for row in range(3):  # Create empty cells down first column\r\n            empty_item = QTableWidgetItem()  # Create empty cell\r\n            self.ui.board_data_table.setItem(row, 0, empty_item)  # Set cell in first column\r\n\r\n    def zoom(self, event: MouseEvent, ax: plt.Axes, centroid: Tuple[float, float, float], fig: Figure) -> None:\r\n        \"\"\"Performs zooming operations on a 3D plot using mouse scroll events.\r\n\r\n        Maintains the plot's center at the specified centroid while scaling the view\r\n        based on mouse scroll direction. Scrolling up zooms in (1.1x), while scrolling\r\n        down zooms out (0.9x).\r\n\r\n        Args:\r\n            event: The matplotlib scroll event containing scroll direction.\r\n            ax: The 3D matplotlib axes object to be zoomed (projection='3d').\r\n            centroid: The (x, y, z) coordinates of the fixed center point.\r\n            fig: The matplotlib figure containing the axes.\r\n\r\n        Warning:\r\n            Requires 3D axes object. Using with 2D axes will raise AttributeError.\r\n        \"\"\"\r\n        # Get current zoom level from x-axis range\r\n        current_zoom: float = ax.get_xlim3d()[1] - ax.get_xlim3d()[0]\r\n\r\n        # Set zoom factor based on scroll direction\r\n        zoom_factor: float = 1.1 if event.button == 'up' else 0.9\r\n\r\n        # Calculate new zoom amount\r\n        zoom_amount: float = (current_zoom * zoom_factor) / 2\r\n\r\n        # Update axis limits maintaining centroid as center\r\n        new_xlim: list[float] = [centroid[0] - zoom_amount, centroid[0] + zoom_amount]\r\n        new_ylim: list[float] = [centroid[1] - zoom_amount, centroid[1] + zoom_amount]\r\n        new_zlim: list[float] = [centroid[2] - zoom_amount, centroid[2] + zoom_amount]\r\n\r\n        # Apply new limits to all axes\r\n        ax.set_xlim3d(new_xlim)\r\n        ax.set_ylim3d(new_ylim)\r\n        ax.set_zlim3d(new_zlim)\r\n\r\n        # Refresh display\r\n        fig.canvas.draw_idle()\r\n\r\n    def comboBoxSetupYear(self) -> None:\r\n        \"\"\"\r\n        Sets up and populates the year combo box with available years.\r\n\r\n        This method manages the year selection combo box by creating a new model and\r\n        populating it with years from self.used_years. The function follows a clear,\r\n        create, populate, and set pattern for managing the combo box contents.\r\n\r\n        Args:\r\n            self: Instance of the containing class, which must have:\r\n                - self.used_years (List[str]): List of years to populate the combo box\r\n                - self.ui.year_lst_combobox (QComboBox): The combo box widget to populate\r\n\r\n        Returns:\r\n            None\r\n\r\n        Example:\r\n            >>> self.used_years = ['2021', '2022', '2023']\r\n            >>> self.comboBoxSetupYear()\r\n            # Results in combo box populated with these three years\r\n\r\n        Note:\r\n            - Assumes self.used_years contains string representations of years\r\n            - Clears existing items before populating new ones\r\n            - Creates a fresh model instance for each setup\r\n            - Does not maintain previous selection state\r\n\r\n        Warning:\r\n            Make sure self.used_years is initialized before calling this method,\r\n            otherwise the combo box will be cleared but not populated.\r\n        \"\"\"\r\n        # Clear any existing items from the year combo box\r\n        self.ui.year_lst_combobox.clear()\r\n\r\n        # Create a new QStandardItemModel to hold the year items\r\n        model: QStandardItemModel = QStandardItemModel()\r\n\r\n        # Iterate through each year in the self.used_years list\r\n        for year in self.used_years:\r\n            # Create a new QStandardItem for the current year\r\n            item: QStandardItem = QStandardItem(str(year))\r\n            # Add the year item to the model\r\n            model.appendRow(item)\r\n\r\n        # Set the created model as the model for the year combo box\r\n        self.ui.year_lst_combobox.setModel(model)\r\n\r\n    def comboBoxSetupMonthWhenYearChanges(self) -> None:\r\n        \"\"\"\r\n        Updates the month combo box when the selected year changes in the year combo box.\r\n        This method is triggered when a new year is selected and handles the cascading updates\r\n        of dependent combo boxes.\r\n\r\n        The function performs the following operations:\r\n        1. Clears related combo boxes (wells, board matters, months)\r\n        2. Filters data for the selected year\r\n        3. Populates the month combo box with available months for the selected year\r\n\r\n        Args:\r\n            self: The class instance containing UI elements and data\r\n\r\n        Returns:\r\n            None\r\n\r\n        Side Effects:\r\n            - Clears well_lst_combobox\r\n            - Clears board_matter_lst_combobox\r\n            - Clears month_lst_combobox\r\n            - Updates self.used_months with filtered month values\r\n            - Updates self.df_year with filtered year data\r\n            - Populates month_lst_combobox with new values\r\n\r\n        Example:\r\n            # This method is typically connected to the year combo box's activated signal\r\n            self.ui.year_lst_combobox.activated.connect(self.comboBoxSetupMonthWhenYearChanges)\r\n\r\n        Notes:\r\n            - This function is part of a cascading update system where changing the year\r\n              triggers updates to months, board matters, and wells\r\n            - The function relies on self.dx_data containing 'Board_Year' and 'Docket_Month' columns\r\n            - Any existing visualization data is cleared when this function is called\r\n        \"\"\"\r\n        # Clear dependent combo boxes to prevent stale data\r\n        self.ui.well_lst_combobox.clear()\r\n        self.ui.board_matter_lst_combobox.clear()\r\n        self.ui.month_lst_combobox.clear()\r\n\r\n        # Get selected year from combo box\r\n        selected_year: str = self.ui.year_lst_combobox.currentText()\r\n\r\n        # Filter and update class data members\r\n        self.used_months: List[str] = self.dx_data[\r\n            self.dx_data['Board_Year'] == selected_year\r\n            ]['Docket_Month'].unique()\r\n\r\n        self.df_year = self.dx_data[self.dx_data['Board_Year'] == selected_year]\r\n\r\n        # Create and populate model for month combo box\r\n        model: QStandardItemModel = QStandardItemModel()\r\n        for month in self.used_months:\r\n            item: QStandardItem = QStandardItem(month)\r\n            model.appendRow(item)\r\n\r\n        # Update month combo box with new model\r\n        self.ui.month_lst_combobox.setModel(model)\r\n\r\n    def comboBoxSetupBoardWhenMonthChanges(self) -> None:\r\n        \"\"\"\r\n        Updates the board matters combo box when a new month is selected. This method manages\r\n        the cascading update of UI elements and visualization data when the month selection changes.\r\n\r\n        The function performs the following operations:\r\n        1. Clears dependent UI elements (wells list and board matters)\r\n        2. Clears visualization data from 2D and 3D displays\r\n        3. Filters data based on selected year and month\r\n        4. Populates board matters combo box with relevant dockets\r\n\r\n        Args:\r\n            self: The class instance containing UI elements and data members\r\n\r\n        Returns:\r\n            None\r\n\r\n        Side Effects:\r\n            - Clears well_lst_combobox\r\n            - Clears board_matter_lst_combobox\r\n            - Calls clearDataFrom2dAnd3d() to reset visualization\r\n            - Updates self.df_month with filtered monthly data\r\n            - Populates board_matter_lst_combobox with new values\r\n\r\n        Example:\r\n            # This method is typically connected to the month combo box's activated signal\r\n            self.ui.month_lst_combobox.activated.connect(self.comboBoxSetupBoardWhenMonthChanges)\r\n\r\n        Notes:\r\n            - Part of a hierarchical combo box update system (Year -> Month -> Board Matter -> Wells)\r\n            - Depends on self.dx_data containing 'Board_Year', 'Docket_Month', and 'Board_Docket' columns\r\n            - Visualization data is cleared to prevent displaying outdated information\r\n            - Maintains data consistency by clearing dependent selections\r\n        \"\"\"\r\n        # Clear dependent UI elements and visualization data\r\n        self.ui.well_lst_combobox.clear()\r\n        self.ui.board_matter_lst_combobox.clear()\r\n        self.clearDataFrom2dAnd3d()\r\n\r\n        # Retrieve current selections from UI\r\n        selected_year: str = self.ui.year_lst_combobox.currentText()\r\n        selected_month: str = self.ui.month_lst_combobox.currentText()\r\n\r\n        # Filter data for selected year and month\r\n        df_month: pd.DataFrame = self.dx_data[(self.dx_data['Board_Year'] == selected_year) &\r\n            (self.dx_data['Docket_Month'] == selected_month)]\r\n\r\n        # Update class member with filtered monthly data\r\n        self.df_month = self.df_year[self.df_year['Docket_Month'] == selected_month]\r\n\r\n        # Extract unique board matters and populate combo box\r\n        board_matters: List[str] = df_month['Board_Docket'].unique()\r\n        model: QStandardItemModel = QStandardItemModel()\r\n\r\n        # Populate model with board matters\r\n        for board_matter in board_matters:\r\n            item: QStandardItem = QStandardItem(board_matter)\r\n            model.appendRow(item)\r\n\r\n        # Update board matters combo box with new model\r\n        self.ui.board_matter_lst_combobox.setModel(model)\r\n\r\n    def comboBoxSetupWellsWhenDocketChanges(self) -> None:\r\n        \"\"\"\r\n        Updates the well list and related data when a new board docket is selected.\r\n        This is a comprehensive update function that handles all aspects of well data\r\n        display and management when the user selects a different docket.\r\n\r\n        The function performs the following major operations:\r\n        1. Clears existing data\r\n        2. Updates well information and displays\r\n        3. Processes directional survey data\r\n        4. Updates UI elements and visualizations\r\n        5. Handles ownership and agency information\r\n        6. Updates status and type counters\r\n\r\n        Note:\r\n            This is a complex operation that triggers multiple UI updates and data\r\n            recalculations. May cause temporary UI freezing for large datasets.\r\n\r\n        Raises:\r\n            ValueError: If required docket data is missing or malformed\r\n            AttributeError: If UI components are not properly initialized\r\n        \"\"\"\r\n        # Clear and filter data\r\n        self.clearDataFrom2dAnd3d()\r\n        self.filterMainDataForDocket()\r\n\r\n        # Update models and displays\r\n        self.updateOperatorsModel()\r\n        self.updateWellIDsAndDisplayNames()\r\n\r\n        # Process directional survey data\r\n        self.filterDirectionalSurveyData()\r\n        self.filterDocketForDirectionalSurveyData()\r\n\r\n        # Update well lists and displays\r\n        self.createFinalSortedListOfWells()\r\n        self.fillInAllWellsTable(self.final_list)\r\n        self.updateWellListComboBox()\r\n        self.makeMainWellsBoldInComboBox()\r\n\r\n        # Update visualizations\r\n        self.update2dWhenDocketChanges()\r\n        self.df_docket_data = self.returnWellsWithParameters()\r\n        self.setAxesLimits()\r\n\r\n        # Process and update additional data\r\n        self.setupDataForBoardDrillingInformation()\r\n        self.update3dViewIfAvailable()\r\n        self.used_sections, self.all_wells_plat_labels = self.draw2dModelSections()\r\n        self.colorInFields()\r\n\r\n        # Update UI elements and ownership data\r\n\r\n        self.createCheckboxes()\r\n        self.calculateCentroidsForSections()\r\n        self.returnWellDataDependingOnParametersTest()\r\n        self.drawTSRPlat()\r\n        self.colorInOwnership()\r\n        self.ownershipSelection()\r\n        self.updateOwnerAndAgencyModels()\r\n        self.createOwnershipLabels()\r\n\r\n        # Finalize updates\r\n        self.canvas2d.blit(self.ax2d.bbox)\r\n        self.canvas2d.draw()\r\n        self.updateComboBoxData()\r\n        self.prodButtonsActivate()\r\n        self.updateCountersForStatusAndType()\r\n\r\n    def filterMainDataForDocket(self) -> None:\r\n        \"\"\"\r\n        Filters the main data frame to only include records matching the currently\r\n        selected year, month, and board docket.\r\n\r\n        The filtered data is stored in self.df_docket for further processing.\r\n        \"\"\"\r\n        self.df_docket = self.dx_data[(self.dx_data['Board_Year'] == self.ui.year_lst_combobox.currentText()) &\r\n            (self.dx_data['Docket_Month'] == self.ui.month_lst_combobox.currentText()) &\r\n            (self.dx_data['Board_Docket'] == self.ui.board_matter_lst_combobox.currentText())]\r\n\r\n    def updateOperatorsModel(self) -> None:\r\n        \"\"\"\r\n        Updates the operators model with sorted unique operator names from the current docket.\r\n\r\n        This function performs the following operations:\r\n        1. Extracts unique operator names from the current docket DataFrame\r\n        2. Sorts them alphabetically\r\n        3. Clears the existing operators model\r\n        4. Populates the model with new operator items\r\n\r\n        The operators model is used to populate UI elements like combo boxes and checkbox lists\r\n        that display operator information.\r\n\r\n        Attributes:\r\n            self.df_docket (pd.DataFrame): DataFrame containing the current docket information\r\n            self.operators_model (QStandardItemModel): Model storing operator information\r\n\r\n        Note:\r\n            - This function should be called whenever the docket selection changes\r\n            - The operators_model must be properly initialized before calling this function\r\n            - Operators are displayed in alphabetical order for easier navigation\r\n\r\n        Raises:\r\n            AttributeError: If self.df_docket or self.operators_model is not initialized\r\n            KeyError: If 'Operator' column is missing from df_docket\r\n        \"\"\"\r\n        # Extract and sort unique operators from the current docket\r\n        operators: List[str] = sorted(self.df_docket['Operator'].unique())\r\n\r\n        # Clear existing items from the operators model\r\n        self.operators_model.clear()\r\n\r\n        # Add each operator as a new item in the model\r\n        for row in operators:\r\n            # Create a new standard item for each operator\r\n            item = QStandardItem(row)\r\n            # Append the item to the model\r\n            self.operators_model.appendRow(item)\r\n\r\n    def updateWellIDsAndDisplayNames(self) -> None:\r\n        \"\"\"\r\n        Updates the well identifiers and display names from the current docket data.\r\n\r\n        Extracts and stores unique well IDs and display names from the current docket.\r\n        Well IDs are stored as-is while display names are sorted alphabetically.\r\n\r\n        Attributes:\r\n            self.apis (Set[str]): Set of unique well API numbers from the docket\r\n            self.unique_count (List[str]): Sorted list of unique well display names\r\n            self.df_docket (pd.DataFrame): DataFrame containing current docket data\r\n\r\n        Note:\r\n            - The APIs are used for matching wells across different data sources\r\n            - Display names are sorted for consistent presentation in the UI\r\n            - This method should be called whenever the docket selection changes\r\n\r\n        Side Effects:\r\n            - Updates self.apis with unique WellID values\r\n            - Updates self.unique_count with sorted DisplayName values\r\n\r\n        Raises:\r\n            KeyError: If 'WellID' or 'DisplayName' columns are missing from df_docket\r\n            AttributeError: If self.df_docket is not properly initialized\r\n        \"\"\"\r\n        # Extract unique well IDs (API numbers)\r\n        self.apis: Set[str] = self.df_docket['WellID'].unique()\r\n\r\n        # Extract and sort unique display names\r\n        self.unique_count: List[str] = sorted(self.df_docket['DisplayName'].unique())\r\n\r\n    def filterDirectionalSurveyData(self) -> None:\r\n        \"\"\"\r\n        Filters and processes directional survey data for wells in the current docket.\r\n\r\n        This function filters the directional survey DataFrame (dx_df) to include only\r\n        wells that match the API numbers from the current docket. The resulting data is\r\n        cleaned by removing duplicates and sorted by API number and measured depth.\r\n\r\n        Attributes:\r\n            self.dx_df (pd.DataFrame): Source DataFrame containing directional survey data\r\n            self.apis (Set[str]): Set of API numbers from the current docket\r\n            self.test_df (pd.DataFrame): Filtered and processed directional survey data\r\n\r\n        Operations performed:\r\n        1. Filters dx_df to include only rows matching current API numbers\r\n        2. Removes duplicate entries, keeping first occurrence\r\n        3. Sorts data by API number and measured depth\r\n\r\n        Note:\r\n            - This function is called during docket changes to update well trajectory data\r\n            - The filtered data is used for well path visualization in 2D and 3D views\r\n            - Measured depth sorting is crucial for proper well trajectory display\r\n\r\n        Side Effects:\r\n            Updates self.test_df with filtered and sorted directional survey data\r\n\r\n        Raises:\r\n            KeyError: If required columns ('APINumber', 'MeasuredDepth') are missing\r\n            AttributeError: If self.dx_df or self.apis are not properly initialized\r\n        \"\"\"\r\n        self.test_df: pd.DataFrame = (\r\n            # Filter for wells in current docket\r\n            self.dx_df[self.dx_df['APINumber'].isin(self.apis)]\r\n            # Remove duplicate entries\r\n            .drop_duplicates(keep='first')\r\n            # Sort by API number and depth for proper trajectory ordering\r\n            .sort_values(by=['APINumber', 'MeasuredDepth']))\r\n\r\n    def filterDocketForDirectionalSurveyData2(self):\r\n        unique_apis_with_data = self.test_df['APINumber'].unique()\r\n        self.df_docket = self.df_docket[self.df_docket['WellID'].isin(unique_apis_with_data)]\r\n\r\n    def filterDocketForDirectionalSurveyData(self) -> None:\r\n        \"\"\"\r\n        Filters the docket DataFrame to include only wells that have directional survey data.\r\n\r\n        This function identifies wells with existing directional survey data in test_df and\r\n        updates the docket DataFrame to include only those wells. This ensures consistency\r\n        between the directional survey data and the docket information for visualization\r\n        and analysis purposes.\r\n\r\n        Attributes:\r\n            self.test_df (pd.DataFrame): DataFrame containing processed directional survey data\r\n            self.df_docket (pd.DataFrame): DataFrame containing well docket information\r\n\r\n        Operations:\r\n        1. Extracts unique API numbers from wells with directional survey data\r\n        2. Filters docket DataFrame to retain only wells with survey data\r\n\r\n        Note:\r\n            - This function should be called after filterDirectionalSurveyData()\r\n            - Maintains data consistency for well visualization and analysis\r\n            - Wells without directional survey data are excluded from the docket\r\n\r\n        Side Effects:\r\n            - Modifies self.df_docket to contain only wells with directional survey data\r\n\r\n        Raises:\r\n            AttributeError: If self.test_df or self.df_docket is not initialized\r\n            KeyError: If 'APINumber' column is missing from test_df or 'WellID' from df_docket\r\n        \"\"\"\r\n        # Get unique API numbers from wells with directional survey data\r\n        unique_apis_with_data: Set[str] = self.test_df['APINumber'].unique()\r\n\r\n        # Filter docket to include only wells that have directional survey data\r\n        self.df_docket = self.df_docket[self.df_docket['WellID'].isin(unique_apis_with_data)]\r\n\r\n    def createFinalSortedListOfWells(self) -> None:\r\n        \"\"\"\r\n        Creates a sorted list of wells with master wells prioritized at the beginning.\r\n\r\n        This function performs the following operations:\r\n        1. Identifies master wells from the docket\r\n        2. Creates a sorted list of master well display names\r\n        3. Creates a sorted list of non-master wells\r\n        4. Combines both lists maintaining master wells at the start\r\n\r\n        Attributes:\r\n            self.df_docket (pd.DataFrame): DataFrame containing well information\r\n            self.unique_count (List[str]): List of all unique well display names\r\n            self.final_list (List[str]): Resulting sorted list with master wells first\r\n\r\n        Note:\r\n            - Master wells are identified by 'MainWell' column value of 1\r\n            - Display names are used for well identification in UI components\r\n            - Order is preserved for consistent UI presentation\r\n\r\n        Side Effects:\r\n            - Updates self.final_list with the combined sorted well list\r\n\r\n        Raises:\r\n            KeyError: If 'MainWell' or 'DisplayName' columns are missing from df_docket\r\n            AttributeError: If self.df_docket or self.unique_count is not initialized\r\n        \"\"\"\r\n        # Filter and extract master wells from the docket\r\n        master_data: pd.DataFrame = self.df_docket[self.df_docket['MainWell'] == 1]\r\n\r\n        # Create sorted list of master well display names\r\n        masters_apds: List[str] = sorted(master_data['DisplayName'].unique())\r\n\r\n        # Create sorted list of non-master wells\r\n        sorted_list: List[str] = sorted([x for x in self.unique_count if x not in masters_apds])\r\n\r\n        # Combine master wells and other wells into final sorted list\r\n        self.final_list: List[str] = masters_apds + sorted_list\r\n\r\n    def updateWellListComboBox(self) -> None:\r\n        \"\"\"\r\n        Updates the well list combo box with the current final list of wells.\r\n\r\n        This function refreshes the well selection combo box in the UI by:\r\n        1. Clearing existing items\r\n        2. Creating a new item model\r\n        3. Populating the model with well names from final_list\r\n        4. Setting the updated model to the combo box\r\n\r\n        Attributes:\r\n            self.ui.well_lst_combobox (QComboBox): UI combo box for well selection\r\n            self.final_list (List[str]): Sorted list of well names to display\r\n\r\n        Note:\r\n            - This function should be called after final_list is updated\r\n            - Wells are displayed in the order specified in final_list\r\n            - The combo box allows user selection of wells for detailed view\r\n            - This update affects the well selection UI component only\r\n\r\n        Side Effects:\r\n            - Clears all existing items in the well list combo box\r\n            - Updates the combo box with new well names\r\n            - Maintains any existing delegate settings (e.g., bold formatting)\r\n\r\n        Raises:\r\n            AttributeError: If self.final_list or self.ui.well_lst_combobox is not initialized\r\n        \"\"\"\r\n        # Clear existing items from the combo box\r\n        self.ui.well_lst_combobox.clear()\r\n\r\n        # Create new model for the combo box\r\n        model: QStandardItemModel = QStandardItemModel()\r\n\r\n        # Add each well from final_list to the model\r\n        for item_text in self.final_list:\r\n            item = QStandardItem(item_text)\r\n            model.appendRow(item)\r\n\r\n        # Set the updated model to the combo box\r\n        self.ui.well_lst_combobox.setModel(model)\r\n\r\n    def makeMainWellsBoldInComboBox(self) -> None:\r\n        \"\"\"\r\n        Applies bold formatting to main wells in the well list combo box.\r\n\r\n        This function identifies main wells from the docket and applies bold styling\r\n        to make them visually distinct in the well selection combo box. Main wells\r\n        are those with MainWell=1 in the docket data.\r\n\r\n        Attributes:\r\n            self.df_docket (pd.DataFrame): DataFrame containing well information\r\n            self.ui.well_lst_combobox (QComboBox): UI combo box for well selection\r\n\r\n        Operations:\r\n        1. Extracts and sorts display names of main wells\r\n        2. Creates a custom delegate for bold formatting\r\n        3. Applies the delegate to the combo box\r\n\r\n        Note:\r\n            - Main wells are identified by 'MainWell' column value of 1\r\n            - Bold formatting helps users quickly identify primary wells\r\n            - The delegate preserves other combo box functionality\r\n            - This styling persists until a new delegate is set\r\n\r\n        Side Effects:\r\n            - Updates the item delegate of the well list combo box\r\n            - Changes the visual appearance of main well entries\r\n\r\n        Raises:\r\n            KeyError: If 'MainWell' or 'DisplayName' columns are missing from df_docket\r\n            AttributeError: If self.df_docket or self.ui.well_lst_combobox is not initialized\r\n        \"\"\"\r\n        # Extract and sort display names of main wells\r\n        masters_apds: List[str] = sorted(self.df_docket[self.df_docket['MainWell'] == 1]['DisplayName'].unique())\r\n\r\n        # Create delegate for bold formatting of main wells\r\n        delegate: QStyledItemDelegate = BoldDelegate(masters_apds)\r\n\r\n        # Apply the delegate to the combo box\r\n        self.ui.well_lst_combobox.setItemDelegate(delegate)\r\n\r\n    def update3dViewIfAvailable(self) -> None:\r\n        \"\"\"\r\n        Updates the 3D view boundaries based on the centroid of drilled segments.\r\n\r\n        If 3D segment data is available, this function:\r\n        1. Calculates the centroid of all drilled segments\r\n        2. Sets new view boundaries extending 10,000 units in each direction\r\n        3. Updates the 3D axis limits to center on the well segments\r\n\r\n        Attributes:\r\n            self.drilled_segments_3d (np.ndarray): Array of 3D coordinates for well segments\r\n            self.ax3d (Axes3D): The 3D matplotlib axes object for well visualization\r\n            self.centroid (np.ndarray): Calculated center point of all well segments\r\n\r\n        Note:\r\n            - Function only executes if drilled_segments_3d contains data\r\n            - View boundaries are set symmetrically around the centroid\r\n            - The Â±10,000 unit range provides consistent zoom level across wells\r\n            - Visualization updates immediately when called\r\n\r\n        Side Effects:\r\n            - Updates self.centroid with new calculated center point\r\n            - Modifies 3D axis limits of the visualization\r\n            - Changes the visible range of the 3D well plot\r\n\r\n        Raises:\r\n            AttributeError: If self.ax3d or self.drilled_segments_3d is not initialized\r\n            ValueError: If drilled_segments_3d contains invalid coordinate data\r\n        \"\"\"\r\n        # Only update if 3D segment data exists\r\n        if self.drilled_segments_3d:\r\n            # Calculate centroid and standard deviation of well segments\r\n            self.centroid: np.ndarray\r\n            std_vals: np.ndarray\r\n            self.centroid, std_vals = self.calculateCentroidNP(self.drilled_segments_3d)\r\n\r\n            # Define new view boundaries centered on centroid\r\n            new_xlim: List[float] = [self.centroid[0] - 10000, self.centroid[0] + 10000]\r\n            new_ylim: List[float] = [self.centroid[1] - 10000, self.centroid[1] + 10000]\r\n            new_zlim: List[float] = [self.centroid[2] - 10000, self.centroid[2] + 10000]\r\n\r\n            # Update 3D axis limits with new boundaries\r\n            self.ax3d.set_xlim3d(new_xlim)\r\n            self.ax3d.set_ylim3d(new_ylim)\r\n            self.ax3d.set_zlim3d(new_zlim)\r\n\r\n    def calculateCentroidsForSections(self) -> None:\r\n        \"\"\"\r\n        Calculates centroids for each well section polygon.\r\n\r\n        Processes each section in the used_sections list by:\r\n        1. Closing each polygon by appending first point to end\r\n        2. Computing the geometric centroid of each section\r\n        3. Storing centroids for later use in visualization\r\n\r\n        Attributes:\r\n            self.used_sections (List[List[Tuple[float, float]]]): List of section coordinates\r\n            self.centroids_lst (List[Point]): List to store computed centroids\r\n\r\n        Note:\r\n            - Sections must be valid polygons for centroid calculation\r\n            - Centroids are used for section labeling and visualization\r\n            - Each section is automatically closed by connecting last point to first\r\n\r\n        Side Effects:\r\n            - Modifies self.used_sections by closing each polygon\r\n            - Populates self.centroids_lst with computed centroids\r\n\r\n        Raises:\r\n            ValueError: If any section contains invalid polygon coordinates\r\n            AttributeError: If self.used_sections is not properly initialized\r\n        \"\"\"\r\n        # Initialize empty list to store centroids\r\n        self.centroids_lst: List[Point] = []\r\n\r\n        # Process each section in used_sections\r\n        for i, val in enumerate(self.used_sections):\r\n            # Close the polygon by appending first point to end\r\n            self.used_sections[i].append(self.used_sections[i][0])\r\n\r\n            # Calculate and store centroid for the section\r\n            centroid: Point = Polygon(self.used_sections[i]).centroid\r\n            self.centroids_lst.append(centroid)\r\n\r\n    def updateOwnerAndAgencyModels(self) -> None:\r\n        \"\"\"\r\n        Updates the owner and agency list models with unique values from docket ownership data.\r\n\r\n        This function refreshes two separate list models by:\r\n        1. Extracting and sorting unique owners from docket data\r\n        2. Extracting and sorting unique state agencies from docket data\r\n        3. Clearing existing models\r\n        4. Populating models with new sorted data\r\n\r\n        Attributes:\r\n            self.docket_ownership_data (pd.DataFrame): DataFrame containing ownership information\r\n                with 'owner' and 'state_legend' columns\r\n            self.owner_model (QStandardItemModel): Model for owner list view\r\n            self.agency_model (QStandardItemModel): Model for agency list view\r\n\r\n        Note:\r\n            - Models are completely refreshed each time this is called\r\n            - Items are sorted alphabetically for consistent display\r\n            - Empty models are created if no data is available\r\n            - Used for populating filter/selection UI components\r\n\r\n        Side Effects:\r\n            - Clears all existing items in both models\r\n            - Updates models with new sorted lists of owners and agencies\r\n\r\n        Raises:\r\n            KeyError: If 'owner' or 'state_legend' columns are missing from docket_ownership_data\r\n            AttributeError: If models or docket_ownership_data are not initialized\r\n        \"\"\"\r\n        # Extract and sort unique owners and agencies\r\n        owners: List[str] = sorted(self.docket_ownership_data['owner'].unique())\r\n        agencies: List[str] = sorted(self.docket_ownership_data['state_legend'].unique())\r\n\r\n        # Clear existing data from both models\r\n        self.owner_model.clear()\r\n        self.agency_model.clear()\r\n\r\n        # Populate owner model with sorted owner names\r\n        for row in owners:\r\n            self.owner_model.appendRow(QStandardItem(row))\r\n\r\n        # Populate agency model with sorted agency names\r\n        for row in agencies:\r\n            self.agency_model.appendRow(QStandardItem(row))\r\n\r\n    def updateComboBoxData(self) -> None:\r\n        \"\"\"\r\n        Updates the internal combo box data list with truncated well names.\r\n\r\n        Processes the well list combo box by:\r\n        1. Iterating through all combo box items\r\n        2. Extracting the first 10 characters of each well name\r\n        3. Storing truncated names in combo_box_data list\r\n\r\n        Attributes:\r\n            self.ui.well_lst_combobox (QComboBox): Combo box containing well names\r\n            self.combo_box_data (List[str]): List to store truncated well identifiers\r\n\r\n        Note:\r\n            - Well names are truncated to 10 characters for consistent sizing\r\n            - Used for internal data processing and matching\r\n            - Should be called after any changes to well list combo box\r\n            - Maintains synchronization between UI and internal data\r\n\r\n        Side Effects:\r\n            - Updates self.combo_box_data with new truncated well names\r\n\r\n        Raises:\r\n            AttributeError: If self.ui.well_lst_combobox is not initialized\r\n        \"\"\"\r\n        # Create list of truncated well names from combo box\r\n        self.combo_box_data: List[str] = [self.ui.well_lst_combobox.itemText(i)[:10]\r\n            for i in range(self.ui.well_lst_combobox.count())]\r\n\r\n    def updateCountersForStatusAndType(self) -> None:\r\n        \"\"\"\r\n        Updates UI counters for well statuses and types by processing docket data.\r\n\r\n        Coordinates the counting and UI updates for both well statuses and types by:\r\n        1. Defining classification categories for statuses and types\r\n        2. Delegating counting to specialized methods\r\n        3. Maintaining consistent categorization across the application\r\n\r\n        Attributes:\r\n            self.df_docket (pd.DataFrame): DataFrame containing well information with\r\n                'CurrentWellStatus' and 'CurrentWellType' columns\r\n\r\n        Note:\r\n            - Main statuses represent primary operational states\r\n            - Other statuses are grouped for simplified visualization\r\n            - Well types are organized with some types merged into broader categories\r\n            - UI elements are automatically updated with count information\r\n\r\n        Side Effects:\r\n            - Updates multiple UI checkbox labels with count information\r\n            - Triggers recalculation of all well status and type counts\r\n\r\n        Raises:\r\n            AttributeError: If df_docket or UI elements are not properly initialized\r\n            KeyError: If required DataFrame columns are missing\r\n        \"\"\"\r\n        # Define primary operational status categories\r\n        main_statuses: List[str] = ['Plugged & Abandoned',\r\n            'Producing',\r\n            'Shut-in',\r\n            'Drilling']\r\n\r\n        # Define secondary status categories for 'Other' grouping\r\n        other_statuses: List[str] = ['Location Abandoned - APD rescinded',\r\n            'Returned APD (Unapproved)',\r\n            'Approved Permit',\r\n            'Active',\r\n            'Drilling Operations Suspended',\r\n            'New Permit',\r\n            'Inactive',\r\n            'Temporarily-abandoned',\r\n            'Test Well or Monitor Well']\r\n\r\n        # Define primary well type categories\r\n        main_types: List[str] = ['Unknown',\r\n            'Oil Well',\r\n            'Dry Hole',\r\n            'Gas Well',\r\n            'Test Well',\r\n            'Water Source Well']\r\n\r\n        # Define merged categories for related well types\r\n        merged_types: Dict[str, List[str]] = {'Injection Well': ['Water Injection Well', 'Gas Injection Well'],\r\n            'Disposal Well': ['Water Disposal Well', 'Oil Well/Water Disposal Well'],\r\n            'Other': ['Test Well', 'Water Source Well', 'Unknown']}\r\n\r\n        # Process and update counters for both classifications\r\n        self.getCountersForStatus(main_statuses, other_statuses)\r\n        self.getCountersForType(main_types, merged_types)\r\n\r\n    def getCountersForType(self, main_types: List[str], merged_types: Dict[str, List[str]]) -> None:\r\n        \"\"\"\r\n        Calculates and updates UI elements with well type counts from docket data.\r\n\r\n        Processes well types by:\r\n        1. Counting occurrences of main well types\r\n        2. Aggregating counts for merged type categories\r\n        3. Updating UI checkboxes with count information\r\n\r\n        Args:\r\n            main_types: List of primary well type categories to count individually\r\n            merged_types: Dictionary mapping merged category names to lists of subtypes\r\n\r\n        Note:\r\n            - Main types are counted directly from CurrentWellType column\r\n            - Merged types aggregate counts from multiple related subtypes\r\n            - UI updates use f-strings for count display\r\n\r\n        Side Effects:\r\n            - Updates multiple UI checkbox labels with count information\r\n\r\n        Raises:\r\n            AttributeError: If df_docket or UI elements are not initialized\r\n        \"\"\"\r\n        # Initialize count dictionary for all well types\r\n        type_counts: Dict[str, int] = {well_type: 0 for well_type in main_types}\r\n        type_counts.update({merged: 0 for merged in merged_types})\r\n\r\n        # Count occurrences of main well types\r\n        for well_type in main_types:\r\n            type_counts[well_type] = self.df_docket['CurrentWellType'].value_counts().get(well_type, 0)\r\n\r\n        # Aggregate counts for merged type categories\r\n        for merged, subtypes in merged_types.items():\r\n            for subtype in subtypes:\r\n                type_counts[merged] += self.df_docket['CurrentWellType'].value_counts().get(subtype, 0)\r\n\r\n        # Update UI elements with calculated counts\r\n        self.ui.oil_well_check.setText(f\"\"\"Oil Well ({str(type_counts['Oil Well'])})\"\"\")\r\n        self.ui.gas_well_check.setText(f\"\"\"Gas Well ({str(type_counts['Gas Well'])})\"\"\")\r\n        self.ui.water_disposal_check.setText(f\"\"\"Water Disposal ({str(type_counts['Disposal Well'])})\"\"\")\r\n        self.ui.dry_hole_check.setText(f\"\"\"Dry Hole ({str(type_counts['Dry Hole'])})\"\"\")\r\n        self.ui.injection_check.setText(f\"\"\"Injection Well ({str(type_counts['Injection Well'])})\"\"\")\r\n        self.ui.other_well_status_check.setText(f\"\"\"Other ({str(type_counts['Other'])})\"\"\")\r\n\r\n    def getCountersForStatus(self, main_status: List[str], other_status: List[str]) -> None:\r\n        \"\"\"\r\n        Counts the occurrences of different well statuses and updates the UI accordingly.\r\n\r\n        This method categorizes well statuses into main statuses and 'Other' statuses,\r\n        counts their occurrences in the current docket data, and updates the UI elements\r\n        to display these counts.\r\n\r\n        Args:\r\n            main_status: List of strings representing primary well status categories\r\n                to be counted individually. Expected values include 'Producing',\r\n                'Shut-in', 'Plugged & Abandoned', and 'Drilling'.\r\n            other_status: List of strings representing secondary well status categories\r\n                to be grouped under 'Other'. Includes statuses like 'Approved Permit',\r\n                'Inactive', etc.\r\n\r\n        Attributes:\r\n            self.df_docket (pd.DataFrame): DataFrame containing well information with\r\n                a 'CurrentWellStatus' column\r\n            self.ui: PyQt5 UI object containing checkbox elements for status display\r\n\r\n        Note:\r\n            - Uses pandas value_counts() for efficient counting\r\n            - Handles missing statuses gracefully by defaulting to 0\r\n            - Updates UI checkboxes with formatted count strings\r\n            - Thread-safe for UI updates when used with PyQt5\r\n\r\n        Side Effects:\r\n            - Updates text of multiple UI checkbox elements:\r\n                - producing_check\r\n                - shut_in_check\r\n                - pa_check\r\n                - drilling_status_check\r\n                - misc_well_type_check\r\n\r\n        Raises:\r\n            AttributeError: If df_docket or UI elements are not properly initialized\r\n            KeyError: If 'CurrentWellStatus' column is missing from df_docket\r\n        \"\"\"\r\n        # Initialize counter dictionary with main statuses and 'Other' category\r\n        status_counts: Dict[str, int] = {status: 0 for status in main_status}\r\n        status_counts['Other'] = 0\r\n\r\n        # Count occurrences of main well statuses from docket data\r\n        for status in main_status:\r\n            status_counts[status] = self.df_docket['CurrentWellStatus'].value_counts().get(status, 0)\r\n\r\n        # Aggregate counts for 'Other' category from secondary statuses\r\n        for status in other_status:\r\n            status_counts['Other'] += self.df_docket['CurrentWellStatus'].value_counts().get(status, 0)\r\n\r\n        # Update UI checkbox labels with formatted count information\r\n        self.ui.producing_check.setText(f\"\"\"Producing ({str(status_counts['Producing'])})\"\"\")\r\n        self.ui.shut_in_check.setText(f\"\"\"Shut In ({str(status_counts['Shut-in'])})\"\"\")\r\n        self.ui.pa_check.setText(f\"\"\"Plugged and Abandoned ({str(status_counts['Plugged & Abandoned'])})\"\"\")\r\n        self.ui.drilling_status_check.setText(f\"\"\"Drilling ({str(status_counts['Drilling'])})\"\"\")\r\n        self.ui.misc_well_type_check.setText(f\"\"\"Misc ({str(status_counts['Other'])})\"\"\")\r\n\r\n    def colorInFields(self) -> None:\r\n        \"\"\"Processes and visualizes field sections with distinct colors on the map.\r\n\r\n        This method handles the coloring and visualization of field polygons based on\r\n        field data from multiple DataFrames. It processes field boundaries, creates\r\n        polygon visualizations, and sets up field labels with centroids.\r\n\r\n        Instance Attributes Modified:\r\n            field_sections: Updates colors, paths, and visibility\r\n            field_centroids_lst: Stores centroid points for field labels\r\n            field_labels: Stores unique field names\r\n\r\n        Note:\r\n            - Requires pre-populated DataFrames: df_docket, df_adjacent_fields, and df_field\r\n            - Uses a colorblind-friendly color palette\r\n            - Initially sets field sections as invisible\r\n\r\n        Raises:\r\n            AttributeError: If required instance DataFrames are not initialized\r\n        \"\"\"\r\n        # Color list definition (truncated for brevity)\r\n        color_lst = [\r\n            '#000000', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c',\r\n            '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191',\r\n            '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087',\r\n            '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43',\r\n            '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c',\r\n            '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191',\r\n            '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087',\r\n            '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43',\r\n            '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c',\r\n            '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191',\r\n            '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087',\r\n            '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43',\r\n            '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c',\r\n            '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191',\r\n            '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087',\r\n            '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43',\r\n            '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c',\r\n            '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191',\r\n            '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087',\r\n            '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43',\r\n            '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c',\r\n            '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191',\r\n            '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087',\r\n            '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43',\r\n            '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c',\r\n            '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191',\r\n            '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087',\r\n            '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43',\r\n            '#ffa600']\r\n\r\n        polygons_lst: List[np.ndarray] = []\r\n\r\n        # Extract unique fields from docket data\r\n        all_used_fields = self.df_docket['FieldName'].unique()\r\n\r\n        # Process adjacent fields\r\n        used_fields = self.df_adjacent_fields[\r\n            self.df_adjacent_fields['Field_Name'].isin(all_used_fields)]\r\n\r\n        # Combine original and adjacent field names\r\n        used_fields_names = list(set(used_fields['adjacent_Field_Name'].values.tolist() +\r\n            all_used_fields.tolist()))\r\n\r\n        # Filter fields DataFrame for relevant fields\r\n        used_fields = self.df_field[self.df_field['Field_Name'].isin(used_fields_names)]\r\n\r\n        # Process line segments and create field groups\r\n        used_fields['LineSegmentOrder'] = used_fields.groupby('Field_Name').cumcount() + 1\r\n        used_fields = used_fields.drop_duplicates(keep='first')\r\n        grouped_rows = used_fields.groupby('Field_Name')\r\n\r\n        # Create polygon coordinates for each field\r\n        for _, group in grouped_rows:\r\n            coordinates = group[['Easting', 'Northing']].values.tolist()\r\n            polygons_lst.append(np.array(coordinates))\r\n\r\n        # Update field section properties\r\n        self.field_sections.set_color(color_lst)\r\n        self.field_sections.set_paths(polygons_lst)\r\n        self.field_sections.set_visible(False)\r\n\r\n        # Calculate and store field centroids and labels\r\n        self.field_centroids_lst = [Polygon(i).centroid for i in polygons_lst]\r\n        self.field_labels = used_fields['Field_Name'].unique()\r\n\r\n    def fillInAllWellsTable(self, lst: List[str]) -> None:\r\n        \"\"\"Populates the wells table with filtered well data.\r\n\r\n        Args:\r\n            lst: List of DisplayNames to filter the wells data\r\n\r\n        This method filters the docket DataFrame based on provided display names,\r\n        sorts the data, and populates a QTableView with the results.\r\n\r\n        Instance Attributes Modified:\r\n            df_all_wells_table: Updates filtered wells data\r\n            all_wells_model: Updates table model with new data\r\n\r\n        Note:\r\n            - Maintains display name ordering based on input list\r\n            - Automatically resizes table columns and rows\r\n            - Hides vertical headers in the table view\r\n\r\n        Raises:\r\n            AttributeError: If required DataFrame or UI components are not initialized\r\n        \"\"\"\r\n        # Filter and sort wells data\r\n        self.df_all_wells_table = self.df_docket[self.df_docket['DisplayName'].isin(lst)]\r\n        self.df_all_wells_table['DisplayName'] = pd.Categorical(\r\n            self.df_all_wells_table['DisplayName'],\r\n            categories=lst, ordered=True)\r\n        self.df_all_wells_table.sort_values('DisplayName', inplace=True)\r\n        self.df_all_wells_table.reset_index(drop=True, inplace=True)\r\n\r\n        # Prepare table data\r\n        data = self.df_all_wells_table.values.tolist()\r\n        self.all_wells_model.removeRows(0, self.all_wells_model.rowCount())\r\n\r\n        # Set up table headers and populate data\r\n        self.all_wells_model.setHorizontalHeaderLabels(self.df_all_wells_table.columns)\r\n        for row in data:\r\n            items = [QStandardItem(str(item)) for item in row]\r\n            self.all_wells_model.appendRow(items)\r\n\r\n        # Configure table view properties\r\n        self.ui.all_wells_qtableview.horizontalHeader().setSectionResizeMode(\r\n            QHeaderView.ResizeToContents)\r\n        self.ui.all_wells_qtableview.verticalHeader().setSectionResizeMode(\r\n            QHeaderView.ResizeToContents)\r\n        self.ui.all_wells_qtableview.verticalHeader().setVisible(False)\r\n\r\n        # Set the model to the view\r\n        self.ui.all_wells_qtableview.setModel(self.all_wells_model)\r\n\r\n    def colorInOwnership(self) -> None:\r\n        \"\"\"Processes and visualizes land ownership data with color-coded polygons for both owners and agencies.\r\n\r\n        This method handles the visualization of land ownership by:\r\n        1. Loading and preprocessing ownership data\r\n        2. Applying color schemes for both owners and agencies\r\n        3. Converting geometries to proper coordinate systems\r\n        4. Creating polygon collections for visualization\r\n\r\n        Color schemes are predefined for different types of ownership and agencies.\r\n\r\n        Returns:\r\n            None\r\n\r\n        Side Effects:\r\n            - Updates self.docket_ownership_data\r\n            - Modifies ownership_sections_agency and ownership_sections_owner properties\r\n            - Creates ownership labels through createOwnershipLabels()\r\n\r\n        Requires:\r\n            - self.df_owner: DataFrame containing ownership data\r\n            - self.used_plat_codes_for_boards: List of valid plat codes\r\n            - self.ownership_sections_agency: PatchCollection for agency visualization\r\n            - self.ownership_sections_owner: PatchCollection for owner visualization\r\n        \"\"\"\r\n        # Initialize empty lists for polygon coordinates\r\n        polygons_lst_owner: List[np.ndarray] = []\r\n        polygons_lst_agency: List[np.ndarray] = []\r\n\r\n        # Define color mappings for different types of ownership\r\n        colors_owner: Dict[str, str] = {'Private': '#D2B48C',\r\n            'Tribal': '#800000',\r\n            'State': '#0000FF',\r\n            'Federal': '#008000'}\r\n\r\n        # Define color mappings for different agencies\r\n        colors_agency: Dict[str, str] = {'None': 'white',\r\n            'Bureau of Land Management': '#2f4b7c',\r\n            'Bureau of Reclamation': '#003f5c',\r\n            'Department of Defense': '#ffa600',\r\n            'Department of Energy': '#ff7c43',\r\n            'National Park Service': '#ff7c43',\r\n            'Private': '#D2B48C',\r\n            'Utah State Forestry Service': '#f95d6a',\r\n            'United States Fish and Wildlife Service': '#d45087',\r\n            'Department of Natural Resources': '#a05195',\r\n            'Other State': '#665191',\r\n            'State Trust Lands': '#2f4b7c',\r\n            'Utah Department of Transportation': '#003f5c',\r\n            'Tribal': '#800000'}\r\n\r\n        # Process ownership data and convert to GeoDataFrame\r\n        docket_ownership_data = self.df_owner[self.df_owner['conc'].isin(self.used_plat_codes_for_boards)]\r\n        docket_ownership_data['geometry'] = docket_ownership_data['geometry'].apply(wkt.loads)\r\n        docket_ownership_data = gpd.GeoDataFrame(docket_ownership_data, geometry='geometry', crs='EPSG:4326')\r\n\r\n        # Transform coordinate system to UTM Zone 12N (EPSG:26912)\r\n        docket_ownership_data = docket_ownership_data.to_crs(epsg=26912)\r\n\r\n        # Map colors to ownership and agency data\r\n        docket_ownership_data['owner_color'] = docket_ownership_data['owner'].map(colors_owner)\r\n        docket_ownership_data['agency_color'] = docket_ownership_data['state_legend'].map(colors_agency)\r\n\r\n        # Create order columns for potential use in visualization\r\n        docket_ownership_data['owner_order'] = docket_ownership_data.groupby('owner').cumcount() + 1\r\n        docket_ownership_data['agency_order'] = docket_ownership_data.groupby('state_legend').cumcount() + 1\r\n\r\n        # Remove duplicates and store processed data\r\n        docket_ownership_data = docket_ownership_data.drop_duplicates(keep='first')\r\n        self.docket_ownership_data = docket_ownership_data\r\n\r\n        # Process geometries and colors for both owner and agency visualizations\r\n        colors_owner_used: List[str] = []\r\n        colors_agency_used: List[str] = []\r\n\r\n        # Create polygon collections for owners\r\n        for conc, group in docket_ownership_data.groupby('owner'):\r\n            for idx, row in group.iterrows():\r\n                coordinates = list(row['geometry'].exterior.coords)\r\n                polygons_lst_owner.append(np.array(coordinates))\r\n                colors_owner_used.append(row['owner_color'])\r\n\r\n        # Create polygon collections for agencies\r\n        for conc, group in docket_ownership_data.groupby('state_legend'):\r\n            for idx, row in group.iterrows():\r\n                coordinates = list(row['geometry'].exterior.coords)\r\n                polygons_lst_agency.append(np.array(coordinates))\r\n                colors_agency_used.append(row['agency_color'])\r\n\r\n        # Update visualization properties for both agency and owner layers\r\n        self.ownership_sections_agency.set_color(colors_agency_used)\r\n        self.ownership_sections_agency.set_paths(polygons_lst_agency)\r\n        self.ownership_sections_agency.set_visible(False)\r\n        self.ownership_sections_owner.set_color(colors_owner_used)\r\n        self.ownership_sections_owner.set_paths(polygons_lst_owner)\r\n        self.ownership_sections_owner.set_visible(False)\r\n\r\n        # Generate labels for ownership visualization\r\n        self.createOwnershipLabels()\r\n\r\n    def colorInFields2(self):\r\n        # Here's a big list of distinctive colors,hopefully colorblind friendly.\r\n        color_lst = [\r\n            '#000000', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c',\r\n            '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191',\r\n            '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087',\r\n            '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43',\r\n            '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c',\r\n            '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191',\r\n            '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087',\r\n            '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43',\r\n            '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c',\r\n            '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191',\r\n            '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087',\r\n            '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43',\r\n            '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c',\r\n            '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191',\r\n            '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087',\r\n            '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43',\r\n            '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c',\r\n            '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191',\r\n            '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087',\r\n            '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43',\r\n            '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c',\r\n            '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191',\r\n            '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087',\r\n            '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43',\r\n            '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c',\r\n            '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191',\r\n            '#a05195', '#d45087', '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087',\r\n            '#f95d6a', '#ff7c43', '#ffa600', '#003f5c', '#2f4b7c', '#665191', '#a05195', '#d45087', '#f95d6a', '#ff7c43',\r\n            '#ffa600']\r\n        polygons_lst = []\r\n        # Get a list of all fields out there that are used in these welkls\r\n        all_used_fields = self.df_docket['FieldName'].unique()\r\n\r\n        # Get a list of adjacent fields to the fields that are being used\r\n        used_fields = self.df_adjacent_fields[self.df_adjacent_fields['Field_Name'].isin(all_used_fields)]\r\n\r\n        # get the names of all the adjacent fields and merge them with the original fields\r\n        used_fields_names = list(set(used_fields['adjacent_Field_Name'].values.tolist() + all_used_fields.tolist()))\r\n\r\n        # search df_fields for those fields specifically and generate a dataframe\r\n        used_fields = self.df_field[self.df_field['Field_Name'].isin(used_fields_names)]\r\n\r\n        # group the fields linesegments, drop dupes, group by name\r\n        used_fields['LineSegmentOrder'] = used_fields.groupby('Field_Name').cumcount() + 1\r\n        used_fields = used_fields.drop_duplicates(keep='first')\r\n        grouped_rows = used_fields.groupby('Field_Name')\r\n        # Create a dictionary to store the polygons for each Conc and iterate them. There's probably a better way to do this\r\n\r\n        for conc, group in grouped_rows:\r\n            # Extract the coordinates from the group\r\n            coordinates = group[['Easting', 'Northing']].values.tolist()\r\n            polygons_lst.append(np.array(coordinates))\r\n\r\n        # set the colors, paths, and visibility. Initially it won't be visible.\r\n        self.field_sections.set_color(color_lst)\r\n        self.field_sections.set_paths(polygons_lst)\r\n        self.field_sections.set_visible(False)\r\n\r\n        # get the centroids. These will be where the field name labels will be anchored.\r\n        self.field_centroids_lst = [Polygon(i).centroid for i in polygons_lst]\r\n        self.field_labels = used_fields['Field_Name'].unique()\r\n\r\n    def fillInAllWellsTable2(self, lst):\r\n        self.df_all_wells_table = self.df_docket[self.df_docket['DisplayName'].isin(lst)]\r\n        self.df_all_wells_table['DisplayName'] = pd.Categorical(self.df_all_wells_table['DisplayName'], categories=lst, ordered=True)\r\n        self.df_all_wells_table.sort_values('DisplayName', inplace=True)\r\n        self.df_all_wells_table.reset_index(drop=True, inplace=True)\r\n        data = self.df_all_wells_table.values.tolist()\r\n        self.all_wells_model.removeRows(0, self.all_wells_model.rowCount())\r\n\r\n        self.all_wells_model.setHorizontalHeaderLabels(self.df_all_wells_table.columns)\r\n        for row in data:\r\n            items = [QStandardItem(str(item)) for item in row]\r\n            self.all_wells_model.appendRow(items)\r\n\r\n        # Set the model to the QTableView\r\n        self.ui.all_wells_qtableview.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)\r\n        self.ui.all_wells_qtableview.verticalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)\r\n        self.ui.all_wells_qtableview.verticalHeader().setVisible(False)\r\n\r\n        self.ui.all_wells_qtableview.setModel(self.all_wells_model)\r\n\r\n    def onRowClicked(self, index: QModelIndex) -> None:\r\n        \"\"\"\r\n        Handles the event when a row is clicked in the all wells table view.\r\n        Updates well information displays, tables, and visualizations based on the selected well.\r\n\r\n        This method performs several key operations:\r\n        1. Extracts row data from the selected well\r\n        2. Filters well data based on API Number\r\n        3. Updates 2D and 3D visualization paths\r\n        4. Updates the well selection combo box\r\n        5. Populates well data tables with detailed information\r\n\r\n        Args:\r\n            index (QModelIndex): The index of the clicked row in the table view\r\n\r\n        Returns:\r\n            None\r\n\r\n        Side Effects:\r\n            - Updates self.selected_well_2d_path and self.selected_well_3d_path\r\n            - Updates self.targeted_well\r\n            - Modifies well_lst_combobox selection\r\n            - Updates well data tables (well_data_table_1, well_data_table_2, well_data_table_3)\r\n            - Triggers 2D visualization update\r\n\r\n        Requires:\r\n            - self.all_wells_model: QStandardItemModel containing well data\r\n            - self.currently_used_lines: DataFrame with well coordinates and information\r\n            - self.combo_box_data: List of well identifiers\r\n            - self.ui: UI component container\r\n        \"\"\"\r\n        # Extract row data from the model\r\n        row: int = index.row()\r\n        row_data: List[Any] = [self.all_wells_model.data(self.all_wells_model.index(row, column))\r\n            for column in range(self.all_wells_model.columnCount())]\r\n\r\n        # Filter well data based on API Number and extract coordinates\r\n        filtered_df: pd.DataFrame = self.currently_used_lines[self.currently_used_lines['APINumber'] == row_data[0]]\r\n        data_select_2d: np.ndarray = filtered_df[['X', 'Y']].to_numpy().astype(float)\r\n        data_select_3d: np.ndarray = filtered_df[['SPX', 'SPY', 'Targeted Elevation']].to_numpy().astype(float)\r\n\r\n        # Update well path data\r\n        self.selected_well_2d_path: List[List[float]] = data_select_2d.tolist()\r\n        self.selected_well_3d_path: List[List[float]] = data_select_3d.tolist()\r\n\r\n        # Update selected well and combo box selection\r\n        self.targeted_well: str = row_data[0]\r\n        target_index: int = self.combo_box_data.index(self.targeted_well)\r\n        self.ui.well_lst_combobox.setCurrentIndex(target_index)\r\n\r\n        # Define data categories for table population\r\n        row_1_data: List[str] = ['WellID', 'WellName', 'SideTrack', 'WorkType', 'Slant',\r\n            'APDReceivedDate', 'APDReturnDate', 'APDApprovedDate',\r\n            'APDExtDate', 'APDRescindDate', 'DrySpud', 'RotarySpud']\r\n        row_2_data: List[str] = ['WCRCompletionDate', 'WellStatusReport', 'WellTypeReport',\r\n            'FirstProdDate', 'TestDate', 'ProductionMethod', 'OilRate',\r\n            'GasRate', 'WaterRate', 'DST', 'DirSurveyRun', 'CompletionType']\r\n        row_3_data: List[str] = ['MD', 'TVD', 'Perforation MD', 'Perforation TVD',\r\n            'CurrentWellStatus', 'CurrentWellType', 'Total Gas Prod',\r\n            'Total Oil Prod', 'WellAge', 'Last Production (if Shut In)',\r\n            'Months Shut In']\r\n\r\n        # Create dictionary and DataFrame for data organization\r\n        all_columns: List[str] = row_1_data + row_2_data + row_3_data\r\n        result_dict: Dict[str, Any] = {col: value for col, value in zip(all_columns, row_data)}\r\n        test_df: pd.DataFrame = pd.DataFrame([result_dict])\r\n\r\n        # Populate the three data tables with well information\r\n        for i, value in enumerate(row_1_data):\r\n            self.ui.well_data_table_1.item(0, i).setText(str(test_df[value].item()))\r\n        for i, value in enumerate(row_2_data):\r\n            self.ui.well_data_table_2.item(0, i).setText(str(test_df[value].iloc[0]))\r\n        for i, value in enumerate(row_3_data):\r\n            self.ui.well_data_table_3.item(0, i).setText(str(test_df[value].iloc[0]))\r\n\r\n        # Update 2D visualization\r\n        self.update2dSelectedWhenWellChanges()\r\n\r\n    def clearDataFrom2dAnd3d(self) -> None:\r\n        \"\"\"\r\n        Clears all data and resets visualization components in both 2D and 3D views.\r\n\r\n        This method performs a comprehensive cleanup of the application state, including:\r\n        1. Clearing UI components and data structures\r\n        2. Resetting well visualizations in 2D and 3D\r\n        3. Clearing plat and section visualizations\r\n        4. Resetting production data displays\r\n        5. Clearing well data tables\r\n        6. Resetting checkbox labels\r\n\r\n        Side Effects:\r\n            - Clears multiple UI components (ComboBoxes, text areas, tables)\r\n            - Resets all visualization parameters and collections\r\n            - Clears all stored well data and paths\r\n            - Updates multiple canvas elements\r\n            - Resets checkbox labels to default states\r\n\r\n        Returns:\r\n            None\r\n\r\n        Note:\r\n            This method should be called when a complete reset of the application\r\n            state is needed, such as when switching between different datasets\r\n            or clearing the current visualization.\r\n        \"\"\"\r\n        # Clear UI components and basic data structures\r\n        self.used_plat_codes: List[str] = []\r\n        self.ui.sectionsBoardComboBox.clear()  # Clear combo box selections\r\n        self.ui.board_matter_files.clear()\r\n        self.ui.board_brief_text.clear()\r\n\r\n        # Reset 2D and 3D well visualizations\r\n        for model_type in ['current', 'planned', 'asdrilled']:\r\n            # Update 2D models\r\n            self.drawModelBasedOnParameters2d(getattr(self, f'all_wells_2d_{model_type}'),\r\n                [], [], [], self.ax2d, getattr(self, f'all_wells_2d_vertical_{model_type}'))\r\n            # Update 3D models\r\n            self.drawModelBasedOnParameters(getattr(self, f'all_wells_3d_{model_type}'),\r\n                [], [], [], self.ax3d)\r\n\r\n        # Clear operator-specific well visualizations\r\n        for i in range(len(self.all_wells_2d_operators)):\r\n            self.drawModelBasedOnParameters2d(self.all_wells_2d_operators[i],\r\n                [], [], [], self.ax2d, self.all_wells_2d_operators_vertical[i])\r\n\r\n        # Reset 3D specific well properties\r\n        for well_obj in [self.spec_well_3d, self.spec_well_3d_solo]:\r\n            well_obj.set_data([], [])\r\n            well_obj.set_3d_properties([])\r\n\r\n        # Clear 2D visualization components\r\n        self.all_vertical_wells_2d.set_offsets([None, None])\r\n        self.spec_vertical_wells_2d.set_offsets([None, None])\r\n        self.spec_well_2d.set_data([], [])\r\n\r\n        # Reset plat visualizations\r\n        for plat_collection in [self.plats_2d, self.plats_2d_main, self.plats_2d_1adjacent, self.plats_2d_2adjacent]:\r\n            plat_collection.set_segments([])\r\n\r\n        # Clear section and ownership visualizations\r\n        for section_collection in [self.ownership_sections_agency, self.ownership_sections_owner, self.field_sections, self.outlined_board_sections]:\r\n            section_collection.set_paths([])\r\n\r\n        # Reset production data visualizations\r\n        for line in [self.profit_line, self.profit_line_cum, self.prod_line, self.prod_line_cum]:\r\n            line.set_data([], [])\r\n\r\n        # Clear well data tables\r\n        self.specific_well_data_model.removeRows(\r\n            0, self.specific_well_data_model.rowCount()\r\n        )\r\n        for i in range(11):\r\n            for table in [self.ui.well_data_table_1, self.ui.well_data_table_2, self.ui.well_data_table_3]:\r\n                table.item(0, i).setText('')\r\n\r\n        # Clear zoom/pan text objects\r\n        for text in self.zp.text_objects:\r\n            text.remove()\r\n        self.zp.text_objects = []\r\n\r\n        # Update all canvases\r\n        for canvas in [self.canvas_prod_1, self.canvas_prod_2, self.canvas3d_solo, self.canvas2d, self.canvas3d]:\r\n            canvas.draw()\r\n\r\n        # Special handling for 2D canvas\r\n        self.ax2d.draw_artist(self.all_vertical_wells_2d)\r\n        self.canvas2d.blit(self.ax2d.bbox)\r\n        self.canvas3d.blit(self.ax3d.bbox)\r\n\r\n        # Reset well table and operators\r\n        self.ui.all_wells_qtableview.setModel(None)\r\n        self.all_wells_2d_operators = []\r\n        self.all_wells_2d_operators_vertical = []\r\n\r\n        # Reset checkbox labels\r\n        checkbox_labels = {'producing_check': 'Producing',\r\n            'shut_in_check': 'Shut In',\r\n            'pa_check': 'Plugged and Abandoned',\r\n            'drilling_status_check': 'Drilling',\r\n            'misc_well_type_check': 'Misc',\r\n            'oil_well_check': 'Oil Well',\r\n            'gas_well_check': 'Gas Well',\r\n            'water_disposal_check': 'Water Disposal',\r\n            'dry_hole_check': 'Dry Hole',\r\n            'injection_check': 'Injection Well',\r\n            'other_well_status_check': 'Other'}\r\n\r\n        for check_name, label in checkbox_labels.items():\r\n            getattr(self.ui, check_name).setText(f\"{label}\")\r\n\r\n    def setAxesLimits(self) -> None:\r\n        \"\"\"\r\n        Sets the axes limits for the 2D visualization based on the data points' distribution.\r\n\r\n        This method processes the docket data to determine appropriate axis limits that will\r\n        properly display all data points with sufficient padding. The process involves:\r\n        1. Generating line segments from docket data\r\n        2. Extracting unique coordinate points\r\n        3. Calculating boundaries with padding\r\n        4. Setting axis limits with a 16000-unit buffer\r\n\r\n        Args:\r\n            self: The class instance containing required attributes:\r\n                - df_docket_data (pd.DataFrame): DataFrame containing docket information\r\n                - ax2d (Axes): The 2D matplotlib axes object to be adjusted\r\n\r\n        Returns:\r\n            None\r\n\r\n        Side Effects:\r\n            - Modifies the x and y limits of self.ax2d\r\n\r\n        Notes:\r\n            - Adds a 16000-unit buffer on all sides to ensure visibility of edge points\r\n            - Uses numpy operations for efficient array processing\r\n            - Assumes all coordinate data is valid and numerical\r\n\r\n        Example:\r\n            >>> self.setAxesLimits()  # Adjusts axes based on current docket data\r\n        \"\"\"\r\n        # Generate all line segments from docket data\r\n        segments: List[List[Tuple[float, float]]] = self.returnSegmentsFromDF(self.df_docket_data)\r\n\r\n        # Convert segments to unique coordinate points\r\n        flattened_list: List[Tuple[float, float]] = [tuple(point) for sublist in segments for point in sublist]\r\n        unique_points: np.ndarray = np.array(list(set(flattened_list)))\r\n\r\n        # Calculate boundary values from coordinate points\r\n        min_x: float = np.min(unique_points[:, 0])  # Minimum x coordinate\r\n        max_x: float = np.max(unique_points[:, 0])  # Maximum x coordinate\r\n        min_y: float = np.min(unique_points[:, 1])  # Minimum y coordinate\r\n        max_y: float = np.max(unique_points[:, 1])  # Maximum y coordinate\r\n\r\n        # Set axis limits with padding\r\n        self.ax2d.set_xlim([min_x - 16000, max_x + 16000])  # Add x-axis buffer\r\n        self.ax2d.set_ylim([min_y - 16000, max_y + 16000])  # Add y-axis buffer\r\n\r\n    def onClick2d(self, event: MouseEvent) -> None:\r\n        \"\"\"\r\n        Handles mouse click events in the 2D well visualization to select and display well information.\r\n\r\n        This method processes click events by:\r\n        1. Calculating the distance between the click location and all visible wells\r\n        2. Identifying the closest well within a dynamic threshold\r\n        3. Loading and displaying the selected well's data\r\n        4. Updating the UI components to reflect the selection\r\n\r\n        Args:\r\n            event (MouseEvent): Matplotlib mouse event containing click coordinates\r\n                and axes information\r\n\r\n        Side Effects:\r\n            - Updates self.selected_well_2d_path with new well coordinates\r\n            - Updates self.selected_well_3d_path with new well 3D coordinates\r\n            - Updates self.targeted_well with selected well's API number\r\n            - Changes well_lst_combobox selection\r\n            - Triggers well information update via comboUpdateWhenWellChanges\r\n\r\n        Notes:\r\n            - Selection threshold is dynamically calculated based on current view dimensions\r\n            - Only processes clicks within the plot axes\r\n            - Requires valid well data in self.currently_used_lines DataFrame\r\n\r\n        Example:\r\n            # Event handler automatically called on mouse click\r\n            >>> self.canvas2d.mpl_connect('button_press_event', self.onClick2d)\r\n        \"\"\"\r\n        if event.inaxes is not None:\r\n            # Extract click coordinates\r\n            x_selected: float = event.xdata\r\n            y_selected: float = event.ydata\r\n\r\n            # Calculate dynamic selection threshold based on current view\r\n            limit: float = (np.diff(self.ax2d.get_xlim())[0] + np.diff(self.ax2d.get_ylim())[0]) / 80\r\n\r\n            # Calculate distances to all visible wells\r\n            self.currently_used_lines['distance'] = np.sqrt(\r\n                (self.currently_used_lines['X'].astype(float) - x_selected) ** 2 +\r\n                (self.currently_used_lines['Y'].astype(float) - y_selected) ** 2)\r\n\r\n            # Filter wells within selection threshold\r\n            closest_points: pd.DataFrame = self.currently_used_lines[self.currently_used_lines['distance'] < limit]\r\n\r\n            if not closest_points.empty:\r\n                # Identify closest well\r\n                closest_point: pd.Series = closest_points.loc[closest_points['distance'].idxmin()]\r\n\r\n                # Get API number of selected well\r\n                selected_well_api: str = closest_point['APINumber']\r\n\r\n                # Filter full well data\r\n                filtered_df: pd.DataFrame = self.currently_used_lines[self.currently_used_lines['APINumber'] == selected_well_api]\r\n\r\n                # Extract 2D and 3D coordinate data\r\n                data_select_2d: np.ndarray = filtered_df[['X', 'Y']].to_numpy().astype(float)\r\n                data_select_3d: np.ndarray = filtered_df[['SPX', 'SPY', 'Targeted Elevation']].to_numpy().astype(float)\r\n\r\n                # Update instance variables with selected well data\r\n                self.selected_well_2d_path: List[List[float]] = data_select_2d.tolist()\r\n                self.selected_well_3d_path: List[List[float]] = data_select_3d.tolist()\r\n                self.targeted_well: str = selected_well_api\r\n\r\n                # Update combo box selection\r\n                target_index: int = self.combo_box_data.index(self.targeted_well)\r\n                self.ui.well_lst_combobox.setCurrentIndex(target_index)\r\n\r\n                # Update well information display\r\n                self.comboUpdateWhenWellChanges()\r\n\r\n    def update2dWhenDocketChanges(self) -> None:\r\n        \"\"\"\r\n        Updates the 2D visualization data when the selected docket or well changes.\r\n\r\n        This method processes the currently selected well from the combo box to:\r\n        1. Extract and format coordinate data for 2D/3D visualization\r\n        2. Calculate relative elevation values\r\n        3. Update instance variables with new well data\r\n\r\n        Args:\r\n            self: The class instance containing:\r\n                - ui.well_lst_combobox (QComboBox): Combo box with well selections\r\n                - dx_df (pd.DataFrame): DataFrame containing well data\r\n                - dx_data (pd.DataFrame): DataFrame with elevation data\r\n\r\n        Side Effects:\r\n            - Updates self.selected_well_2d_path with new 2D coordinates\r\n            - Updates self.selected_well_3d_path with new 3D coordinates\r\n            - Updates self.targeted_well with current API number\r\n            - Updates self.targeted_well_elevation\r\n            - Modifies dx_df and dx_data with new relative elevation calculations\r\n\r\n        Notes:\r\n            - API numbers are truncated to first 10 characters for filtering\r\n            - Elevation calculations are based on the first entry in dx_data\r\n            - Coordinates are converted to float type for numerical operations\r\n\r\n        Example:\r\n            >>> self.update2dWhenDocketChanges()  # Updates visualization after well selection\r\n        \"\"\"\r\n        # Extract current well selection from combo box\r\n        current_text: str = self.ui.well_lst_combobox.currentText()\r\n        api_number: str = current_text[:10]  # First 10 chars represent API number\r\n\r\n        # Filter well data based on API number\r\n        filtered_df: pd.DataFrame = self.dx_df[self.dx_df['APINumber'] == api_number]\r\n\r\n        # Extract and convert coordinate data\r\n        data_select_2d: np.ndarray = filtered_df[['X', 'Y']].to_numpy().astype(float)\r\n        data_select_3d: np.ndarray = filtered_df[['X', 'Y', 'TrueVerticalDepth']].to_numpy().astype(float)\r\n\r\n        # Update instance variables with new coordinate data\r\n        self.selected_well_2d_path: List[List[float]] = data_select_2d.tolist()\r\n        self.selected_well_3d_path: List[List[float]] = data_select_3d.tolist()\r\n        self.targeted_well: str = api_number\r\n\r\n        # Calculate relative elevation values\r\n        self.targeted_well_elevation: float = self.dx_data['Elevation'].iloc[0]\r\n\r\n        # Update DataFrames with relative elevation calculations\r\n        self.dx_df['Targeted Elevation'] = (self.dx_df['TrueElevation'] - self.targeted_well_elevation)\r\n        self.dx_data['Relative Elevation'] = (self.dx_data['Elevation'] - self.targeted_well_elevation)\r\n\r\n    def comboUpdateWhenWellChanges(self) -> None:\r\n        \"\"\"\r\n        Updates the UI tables and visualization when a well selection changes in the combo box.\r\n\r\n        This method filters the well data based on current selections and populates three data\r\n        tables with detailed well information. The process includes:\r\n        1. Filtering data based on year, month, and board matter\r\n        2. Identifying the currently selected well\r\n        3. Populating three UI tables with well-specific data\r\n        4. Triggering 2D visualization updates\r\n\r\n        Args:\r\n            self: The class instance containing:\r\n                - dx_data (pd.DataFrame): Main well data\r\n                - ui: UI components including combo boxes and tables\r\n\r\n        Side Effects:\r\n            - Updates well_data_table_1, well_data_table_2, and well_data_table_3\r\n            - Triggers update2dSelectedWhenWellChanges\r\n\r\n        Notes:\r\n            - Handles multiple records for same well by selecting most recent APD approval\r\n            - Data is organized into three distinct tables for different well attributes\r\n            - All values are converted to strings for display\r\n\r\n        Example:\r\n            >>> self.comboUpdateWhenWellChanges()  # Updates UI after well selection change\r\n        \"\"\"\r\n        # Filter data frame based on current UI selections\r\n        df_month: pd.DataFrame = self.dx_data[(self.dx_data['Board_Year'] == self.ui.year_lst_combobox.currentText()) &\r\n            (self.dx_data['Docket_Month'] == self.ui.month_lst_combobox.currentText()) &\r\n            (self.dx_data['Board_Docket'] == self.ui.board_matter_lst_combobox.currentText())]\r\n\r\n        # Get current well selection\r\n        current_text: str = self.ui.well_lst_combobox.currentText()\r\n\r\n        # Filter to current well's data\r\n        current_data_row: pd.DataFrame = df_month[df_month['DisplayName'] == current_text]\r\n\r\n        # Handle multiple records by selecting most recent\r\n        if len(current_data_row) > 1:\r\n            current_data_row = current_data_row.sort_values(by='APDApprovedDate', ascending=False).head(1)\r\n\r\n        # Define data fields for each table\r\n        row_1_data: List[str] = ['WellID', 'WellName', 'SideTrack', 'CurrentWellStatus', 'CurrentWellType',\r\n            'APDReceivedDate', 'APDReturnDate', 'APDApprovedDate', 'APDExtDate',\r\n            'APDRescindDate', 'DrySpud', 'RotarySpud']\r\n\r\n        row_2_data: List[str] = ['WellStatusReport', 'WellTypeReport', 'FirstProdDate', 'WCRCompletionDate',\r\n            'TestDate', 'ProductionMethod', 'OilRate', 'GasRate', 'WaterRate', 'DST',\r\n            'DirSurveyRun', 'CompletionType']\r\n\r\n        row_3_data: List[str] = ['GasVolume', 'OilVolume', 'WellAge', 'Last Production (if Shut In)',\r\n            'Months Shut In', 'Operator', 'MD', 'TVD', 'Perforation MD',\r\n            'Perforation TVD', 'WorkType', 'Slant']\r\n\r\n        # Setup table structure\r\n        self.setupTableData([row_1_data, row_2_data, row_3_data], current_data_row)\r\n\r\n        # Populate each table with corresponding data\r\n        for i, value in enumerate(row_1_data):\r\n            self.ui.well_data_table_1.item(0, i).setText(str(current_data_row[value].item()))\r\n\r\n        for i, value in enumerate(row_2_data):\r\n            self.ui.well_data_table_2.item(0, i).setText(str(current_data_row[value].iloc[0]))\r\n\r\n        for i, value in enumerate(row_3_data):\r\n            self.ui.well_data_table_3.item(0, i).setText(str(current_data_row[value].iloc[0]))\r\n\r\n        # Update 2D visualization\r\n        self.update2dSelectedWhenWellChanges()\r\n\r\n    def setupTableData(self, row_data: List[List[str]], df: pd.DataFrame) -> None:\r\n        \"\"\"\r\n        Sets up and populates a table view with well data using a custom model and delegate.\r\n\r\n        This method organizes well data into a structured table format with alternating\r\n        header and data rows. It handles the formatting and display of well attributes\r\n        including production, physical characteristics, and operational data.\r\n\r\n        Args:\r\n            row_data: List of three lists containing column headers for each data section:\r\n                - row_data[0]: Basic well information and dates\r\n                - row_data[1]: Well status and production metrics\r\n                - row_data[2]: Physical characteristics and operations\r\n            df: DataFrame containing the well data to populate the table\r\n\r\n        Side Effects:\r\n            - Clears and updates self.specific_well_data_model\r\n            - Modifies table view formatting and visibility settings\r\n            - Sets custom delegate for bold row styling\r\n\r\n        Notes:\r\n            - Headers (bold rows) are at indices 0, 2, and 4\r\n            - Data rows follow their respective headers\r\n            - Table adjusts column and row sizes automatically\r\n            - Headers are hidden for custom formatting\r\n\r\n        Example:\r\n            >>> row_data = [['WellID', 'WellName'], ['Status', 'Type'], ['MD', 'TVD']]\r\n            >>> setupTableData(row_data, well_df)  # Populates table with well data\r\n        \"\"\"\r\n        # Clear existing table data\r\n        self.specific_well_data_model.removeRows(0, self.specific_well_data_model.rowCount())\r\n\r\n        # Define modified headers for the third row\r\n        row_3_data_edited: List[str] = ['GasVolume', 'OilVolume', 'WellAge', 'Recorded Last Production',\r\n            'Months Shut In (if applicable)', 'Operator', 'MD', 'TVD',\r\n            'Perforation MD', 'Perforation TVD', 'WorkType', 'Slant']\r\n\r\n        # Initialize data structure for table population\r\n        data_used_lst: List[List[str]] = [row_data[0], [], row_data[1], [], row_3_data_edited, []]\r\n\r\n        # Populate data rows from DataFrame\r\n        for i, value in enumerate(row_data[0]):\r\n            data_used_lst[1].append(str(df[value].values[0]))\r\n        for i, value in enumerate(row_data[1]):\r\n            data_used_lst[3].append(str(df[value].values[0]))\r\n        for i, value in enumerate(row_data[2]):\r\n            data_used_lst[5].append(str(df[value].values[0]))\r\n\r\n        # Create and append items to model\r\n        for row in data_used_lst:\r\n            items = [QStandardItem(str(item)) for item in row]\r\n            self.specific_well_data_model.appendRow(items)\r\n\r\n        # Configure table view display settings\r\n        self.ui.well_data_table_view.horizontalHeader().setSectionResizeMode(\r\n            QHeaderView.ResizeToContents)\r\n        self.ui.well_data_table_view.verticalHeader().setSectionResizeMode(\r\n            QHeaderView.ResizeToContents)\r\n        self.ui.well_data_table_view.horizontalHeader().setVisible(False)\r\n        self.ui.well_data_table_view.verticalHeader().setVisible(False)\r\n        self.ui.well_data_table_view.setModel(self.specific_well_data_model)\r\n\r\n        # Apply custom formatting for bold rows\r\n        bold_rows: List[int] = [0, 2, 4]\r\n        delegate = MultiBoldRowDelegate(bold_rows)\r\n        self.ui.well_data_table_view.setItemDelegate(delegate)\r\n\r\n    def update2dSelectedWhenWellChanges(self) -> None:\r\n        \"\"\"\r\n        Updates the 2D visualization when a well selection changes, handling both data\r\n        and visual model updates.\r\n\r\n        This method acts as a coordinator between data updates and visual rendering by:\r\n        1. Triggering updates to well data, relative elevations, and targeting data\r\n        2. Redrawing the 2D visualization model for the selected well\r\n\r\n        Args:\r\n            self: The class instance containing:\r\n                - update2dWhenDocketChanges method for data updates\r\n                - draw2dModelSelectedWell method for visualization updates\r\n\r\n        Side Effects:\r\n            - Updates well data through update2dWhenDocketChanges\r\n            - Refreshes 2D visualization through draw2dModelSelectedWell\r\n            - Modifies scatter plots and line collections in the 2D view\r\n\r\n        Notes:\r\n            - Called when a well is selected either through combo box or table click\r\n            - Part of the visualization update chain triggered by well selection changes\r\n            - Coordinates both data and visual updates in the correct sequence\r\n\r\n        Example:\r\n            >>> self.update2dSelectedWhenWellChanges()  # Updates view after well selection\r\n        \"\"\"\r\n        # Update well data and calculations\r\n        self.update2dWhenDocketChanges()\r\n\r\n        # Refresh the 2D visualization model\r\n        self.draw2dModelSelectedWell()\r\n\r\n    def draw2dModelSelectedWell(self) -> None:\r\n        \"\"\"\r\n        Draws and updates the 2D and 3D visualizations for the currently selected well.\r\n\r\n        This method processes well data and updates multiple visualization components:\r\n        - 2D well path visualization\r\n        - 3D well trajectory\r\n        - Production graphics\r\n        - Vertical well representations\r\n\r\n        The method handles different citing types (as-drilled, planned, vertical) and\r\n        ensures visualization even with partial data availability.\r\n\r\n        Args:\r\n            self: The class instance containing:\r\n                - df_docket (pd.DataFrame): Docket-specific well data\r\n                - dx_data (pd.DataFrame): Display-formatted well data\r\n                - dx_df (pd.DataFrame): Directional survey data\r\n                - Various matplotlib plot elements and canvases\r\n\r\n        Side Effects:\r\n            - Updates spec_vertical_wells_2d scatter plot\r\n            - Updates spec_well_2d line plot\r\n            - Updates spec_well_3d and spec_well_3d_solo 3D plots\r\n            - Modifies plot limits and redraws canvases\r\n            - Triggers production graphic updates\r\n\r\n        Notes:\r\n            - Prioritizes data display in order: as-drilled > planned > vertical\r\n            - Converts coordinates to float for plotting\r\n            - Centers view on well's centroid with 8000-unit buffer\r\n            - Handles both vertical and directional wells differently\r\n\r\n        Example:\r\n            >>> self.draw2dModelSelectedWell()  # Updates visualizations for selected well\r\n        \"\"\"\r\n        # Get well parameter data from current selection\r\n        df_well_data: pd.DataFrame = self.df_docket.loc[self.dx_data['DisplayName'] == self.ui.well_lst_combobox.currentText()]\r\n        print(self.dx_data)\r\n        print(foo)\r\n        # Filter directional survey data for selected well\r\n        df_well: pd.DataFrame = self.dx_df[self.dx_df['APINumber'] == df_well_data['WellID'].iloc[0]]\r\n\r\n        # Separate data by citing type\r\n        drilled_df: pd.DataFrame = df_well[df_well['CitingType'].isin(['asdrilled'])]\r\n        planned_df: pd.DataFrame = df_well[df_well['CitingType'].isin(['planned'])]\r\n        vert_df: pd.DataFrame = df_well[df_well['CitingType'].isin(['vertical'])]\r\n\r\n        # Get best available data based on priority\r\n        df_well = self.findPopulatedDataframeForSelection(drilled_df, planned_df, vert_df)\r\n        df_well.drop_duplicates(keep='first', inplace=True)\r\n        df_well['X'] = df_well['X'].astype(float)\r\n        df_well['Y'] = df_well['Y'].astype(float)\r\n\r\n        # Extract coordinate data\r\n        xy_data = df_well[['X', 'Y']].values\r\n\r\n        # Update appropriate plot based on well type\r\n        if df_well['CitingType'].iloc[0] == 'vertical':\r\n            self.spec_vertical_wells_2d.set_offsets(xy_data)\r\n            self.spec_well_2d.set_data([], [])\r\n        else:\r\n            self.spec_vertical_wells_2d.set_offsets([None, None])\r\n            self.spec_well_2d.set_data(xy_data[:, 0], xy_data[:, 1])\r\n\r\n        # Process 3D coordinates\r\n        x = to_numeric(df_well['SPX'], errors='coerce')\r\n        y = to_numeric(df_well['SPY'], errors='coerce')\r\n        z = to_numeric(df_well['Targeted Elevation'], errors='coerce')\r\n        self.centroid = (x.mean(), y.mean(), z.mean())\r\n\r\n        # Update 3D visualizations\r\n        self.spec_well_3d.set_data(x, y)\r\n        self.spec_well_3d.set_3d_properties(z)\r\n        self.spec_well_3d_solo.set_data(x, y)\r\n        self.spec_well_3d_solo.set_3d_properties(z)\r\n\r\n        # Refresh canvases\r\n        self.canvas2d.draw()\r\n        self.canvas3d.draw()\r\n\r\n        # Set new view limits centered on well\r\n        new_xlim = [self.centroid[0] - 8000, self.centroid[0] + 8000]\r\n        new_ylim = [self.centroid[1] - 8000, self.centroid[1] + 8000]\r\n        new_zlim = [self.centroid[2] - 8000, self.centroid[2] + 8000]\r\n\r\n        # Update 3D solo view limits\r\n        self.ax3d_solo.set_xlim3d(new_xlim)\r\n        self.ax3d_solo.set_ylim3d(new_ylim)\r\n        self.ax3d_solo.set_zlim3d(new_zlim)\r\n\r\n        # Refresh solo canvas and production graphic\r\n        self.canvas3d_solo.draw()\r\n        self.drawProductionGraphic()\r\n\r\n    def findPopulatedDataframeForSelection(\r\n            self,drilled_df: pd.DataFrame, planned_df: pd.DataFrame, vert_df: pd.DataFrame) -> pd.DataFrame:\r\n        \"\"\"\r\n        Prioritizes and returns the first non-empty DataFrame from the provided well data sources.\r\n\r\n        This method implements a prioritized selection of well data, checking in order:\r\n        1. As-drilled data (highest priority)\r\n        2. Planned well data\r\n        3. Vertical well data (fallback option)\r\n\r\n        Args:\r\n            drilled_df: DataFrame containing as-drilled well survey data\r\n            planned_df: DataFrame containing planned well survey data\r\n            vert_df: DataFrame containing vertical well survey data\r\n\r\n        Returns:\r\n            pd.DataFrame: The first non-empty DataFrame based on priority order.\r\n            Will return vert_df even if empty if no other data is available.\r\n\r\n        Notes:\r\n            - Used to ensure visualization data is available even with partial surveys\r\n            - Prioritizes actual drilled data over planned trajectories\r\n            - Serves as a data selection failsafe for visualization methods\r\n\r\n        Example:\r\n            >>> selected_df = findPopulatedDataframeForSelection(\r\n            ...     drilled_df=empty_df,\r\n            ...     planned_df=populated_df,\r\n            ...     vert_df=empty_df\r\n            ... )\r\n            >>> # Returns populated_df since drilled_df is empty\r\n        \"\"\"\r\n        if not drilled_df.empty:\r\n            return drilled_df\r\n        elif not planned_df.empty:\r\n            return planned_df\r\n        else:\r\n            return vert_df\r\n\r\n    def drawTSRPlat(self) -> None:\r\n        \"\"\"\r\n        Renders a Township, Section, and Range (TSR) plat visualization with adjacent territories.\r\n\r\n        This method creates a 2D visualization of plat data showing main and adjacent territories,\r\n        complete with labels and boundaries. It processes three levels of adjacency:\r\n        - Main plat areas (Order 0)\r\n        - First-level adjacent plats (Order 1)\r\n        - Second-level adjacent plats (Order 2)\r\n\r\n        The visualization includes:\r\n        1. Plat boundaries for all three adjacency levels\r\n        2. Centered labels for each plat\r\n        3. Automatic viewport centering on the main plat area\r\n        4. Optional section labels based on checkbox state\r\n\r\n        Args:\r\n            self: Parent class instance containing required attributes:\r\n                - ui: User interface elements\r\n                - df_adjacent_plats: DataFrame with adjacency information\r\n                - df_plat: DataFrame with plat geometry data\r\n                - ax2d: Matplotlib axes for 2D plotting\r\n                - canvas2d: Matplotlib canvas for rendering\r\n\r\n        Attributes Modified:\r\n            - used_plat_codes: List of unique plat codes in main area\r\n            - used_plat_codes_for_boards: List of all unique plat codes\r\n            - Various matplotlib artists (plats_2d_main, labels_plats_2d_main, etc.)\r\n\r\n        Notes:\r\n            - Requires fieldsTester() helper function for geometry processing\r\n            - Handles visibility toggling based on UI checkbox state\r\n            - Updates the plot limits based on centroid calculation\r\n            - Attempts to update dependent data via manipulateTheDfDocketDataDependingOnCheckboxes()\r\n        \"\"\"\r\n\r\n        def fieldsTester(df_field: pd.DataFrame) -> pd.DataFrame:\r\n            \"\"\"\r\n            Processes field data to create geometric representations and labeling for visualization.\r\n\r\n            Transforms raw field data into a geometric dataset by:\r\n            1. Converting coordinate pairs to Point geometries\r\n            2. Grouping points by concentration to form polygons\r\n            3. Calculating centroids for each polygon\r\n            4. Adding transformed labels\r\n\r\n            Args:\r\n                df_field (pd.DataFrame): Input DataFrame containing at minimum:\r\n                    - Easting (float): X coordinates\r\n                    - Northing (float): Y coordinates\r\n                    - Conc (Any): Concentration or field identifier\r\n\r\n            Returns:\r\n                pd.DataFrame: Processed DataFrame containing:\r\n                    - Conc: Original field identifier\r\n                    - geometry: Polygon geometries formed from point groups\r\n                    - centroid: Centroid point for each polygon\r\n                    - label: Transformed string label\r\n\r\n            Notes:\r\n                - Assumes transformString() helper function exists for label creation\r\n                - Creates both point and polygon geometries for visualization\r\n                - Handles merging and cleanup of intermediate geometric data\r\n                - Uses Shapely geometry objects for spatial operations\r\n\r\n            Example:\r\n                >>> field_data = pd.DataFrame({\r\n                ...     'Easting': [1.0, 2.0, 3.0],\r\n                ...     'Northing': [1.0, 2.0, 3.0],\r\n                ...     'Conc': ['A', 'A', 'B']\r\n                ... })\r\n                >>> result = fieldsTester(field_data)\r\n            \"\"\"\r\n            # Create point geometries from coordinates\r\n            df_field['geometry'] = df_field.apply(lambda row: Point(row['Easting'], row['Northing']), axis=1)\r\n\r\n            # Extract and process relevant fields\r\n            used_fields = df_field[['Conc', 'Easting', 'Northing', 'geometry']]\r\n            used_fields['geometry'] = used_fields.apply(lambda row: Point(row['Easting'], row['Northing']), axis=1)\r\n\r\n            # Helper function to create polygons from coordinate groups\r\n            def createFieldsPolygon(group: pd.DataFrame) -> Polygon:\r\n                return Polygon(zip(group['Easting'], group['Northing']))\r\n\r\n            # Create polygons grouped by concentration\r\n            polygons = used_fields.groupby('Conc',group_keys=False).apply(createFieldsPolygon, include_groups=False).reset_index()\r\n\r\n            # Rename geometry column\r\n            polygons = polygons.rename(columns={0: 'geometry'})\r\n\r\n            # Merge point and polygon data\r\n            merged_data = used_fields.merge(polygons, on='Conc')\r\n            merged_data = merged_data.drop('geometry_y', axis=1).rename(columns={'geometry_x': 'geometry'})\r\n\r\n            # Create final polygon dataset\r\n            df_new = merged_data.groupby('Conc').apply(lambda x: Polygon(zip(x['Easting'], x['Northing'])), include_groups=False).reset_index()\r\n\r\n            # Set column names and add derived fields\r\n            df_new.columns = ['Conc', 'geometry']\r\n            df_new['centroid'] = df_new.apply(lambda x: x['geometry'].centroid, axis=1)\r\n            df_new['label'] = df_new.apply(lambda x: transformString(x['Conc']), axis=1)\r\n\r\n            return df_new\r\n\r\n        def transformString(s: str) -> str:\r\n            \"\"\"\r\n            Transforms a well location string from compact format to readable format.\r\n\r\n            Converts strings like \"0102S03WA\" to \"1 2S 3W A\" by:\r\n            1. Extracting numeric and directional components\r\n            2. Removing leading zeros\r\n            3. Adding proper spacing\r\n\r\n            Args:\r\n                s (str): Input string in format \"TTRRSDDDW[A-Z]\" where:\r\n                    - TT: Township number (2 digits)\r\n                    - RRS: Range number with S direction (3 chars)\r\n                    - DDDW: Distance number with W direction (3 chars)\r\n                    - [A-Z]: Single letter designation\r\n\r\n            Returns:\r\n                str: Transformed string with removed leading zeros and added spaces.\r\n                     Returns original string if pattern doesn't match.\r\n\r\n            Notes:\r\n                - Uses regex pattern matching to identify string components\r\n                - Maintains directional indicators (S/W) in output\r\n                - Preserves single letter designation without modification\r\n\r\n            Example:\r\n                >>> transformString(\"0102S03WA\")\r\n                \"1 2S 3W A\"\r\n                >>> transformString(\"invalid\")\r\n                \"invalid\"\r\n            \"\"\"\r\n            # Pattern matching for well location format\r\n            parts = re.match(r'(\\d{2})(\\d{2}S)(\\d{2}W)([A-Z])', s)\r\n\r\n            # Return original string if pattern doesn't match\r\n            if not parts:\r\n                return s\r\n\r\n            # Extract and transform components\r\n            part1 = str(int(parts.group(1)))  # Township number without leading zeros\r\n            part2 = str(int(parts.group(2)[:-1])) + parts.group(2)[-1]  # Range with S\r\n            part3 = str(int(parts.group(3)[:-1])) + parts.group(3)[-1]  # Distance with W\r\n            part4 = parts.group(4)  # Letter designation\r\n\r\n            # Format with spaces between components\r\n            return f\"{part1} {part2} {part3} {part4}\"\r\n\r\n        self.used_plat_codes = []\r\n\r\n        # Get current board data and filter adjacent plats\r\n        board_data = self.ui.board_matter_lst_combobox.currentText()\r\n        adjacent_all = self.df_adjacent_plats[self.df_adjacent_plats['Board_Docket'] == board_data]\r\n        df_plat_docket = self.df_plat[self.df_plat['Board_Docket'] == board_data]\r\n\r\n        # Filter adjacency orders\r\n        adjacent_main = adjacent_all[adjacent_all['Order'] == 0]\r\n        adjacent_1 = adjacent_all[adjacent_all['Order'] == 1]\r\n        adjacent_2 = adjacent_all[adjacent_all['Order'] == 2]\r\n\r\n        # Get plat data for each adjacency level\r\n        adjacent_main_plats = df_plat_docket[df_plat_docket['Conc'].isin(adjacent_main['src_FullCo'].unique())]\r\n        adjacent_1_plats = df_plat_docket[df_plat_docket['Conc'].isin(adjacent_1['src_FullCo'].unique())]\r\n        adjacent_2_plats = df_plat_docket[df_plat_docket['Conc'].isin(adjacent_2['src_FullCo'].unique())]\r\n\r\n        # Process geometry data\r\n        plat_data_main = fieldsTester(adjacent_main_plats)\r\n        plat_data_adjacent_1 = fieldsTester(adjacent_1_plats)\r\n        plat_data_adjacent_2 = fieldsTester(adjacent_2_plats)\r\n\r\n        # Create text labels with paths\r\n        paths_main = [\r\n            PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\")\r\n            for coord, text in zip(plat_data_main['centroid'], plat_data_main['label'])\r\n        ]\r\n        paths_adjacent_1 = [\r\n            PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\")\r\n            for coord, text in zip(plat_data_adjacent_1['centroid'], plat_data_adjacent_1['label'])\r\n        ]\r\n        paths_adjacent_2 = [\r\n            PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\")\r\n            for coord, text in zip(plat_data_adjacent_2['centroid'], plat_data_adjacent_2['label'])\r\n        ]\r\n\r\n        # Set label paths\r\n        self.labels_plats_2d_main.set_paths(paths_main)\r\n        self.labels_plats_2d_1adjacent.set_paths(paths_adjacent_1)\r\n        self.labels_plats_2d_2adjacent.set_paths(paths_adjacent_2)\r\n\r\n        # Set geometry segments\r\n        self.plats_2d_main.set_segments(\r\n            plat_data_main['geometry'].apply(lambda x: x.exterior.coords)\r\n        )\r\n        self.plats_2d_1adjacent.set_segments(\r\n            plat_data_adjacent_1['geometry'].apply(lambda x: x.exterior.coords)\r\n        )\r\n        self.plats_2d_2adjacent.set_segments(\r\n            plat_data_adjacent_2['geometry'].apply(lambda x: x.exterior.coords)\r\n        )\r\n\r\n        # Calculate and set plot limits based on centroid\r\n        all_polygons = unary_union(plat_data_main['geometry'].tolist())\r\n        overall_centroid = all_polygons.centroid\r\n        self.ax2d.set_xlim(overall_centroid.x - 10000, overall_centroid.x + 10000)\r\n        self.ax2d.set_ylim(overall_centroid.y - 10000, overall_centroid.y + 10000)\r\n\r\n        # Update plat codes and visibility\r\n        self.used_plat_codes = plat_data_main['Conc'].unique().tolist()\r\n        self.plats_2d_main.set_visible(True)\r\n        self.plats_2d_1adjacent.set_visible(True)\r\n        self.plats_2d_2adjacent.set_visible(True)\r\n\r\n        # Handle label visibility based on checkbox\r\n        label_visibility = self.ui.section_label_checkbox.isChecked()\r\n        for labels in [self.labels_plats_2d_main,\r\n                       self.labels_plats_2d_1adjacent,\r\n                       self.labels_plats_2d_2adjacent]:\r\n            labels.set_visible(True)  # Always visible per original logic\r\n\r\n        # Compile all unique plat codes\r\n        self.used_plat_codes_for_boards = list(set(\r\n            plat_data_main['Conc'].unique().tolist() +\r\n            plat_data_adjacent_1['Conc'].unique().tolist() +\r\n            plat_data_adjacent_2['Conc'].unique().tolist()\r\n        ))\r\n\r\n        # Update canvas\r\n        self.canvas2d.blit(self.ax2d.bbox)\r\n        self.canvas2d.draw()\r\n\r\n        # Try to update dependent data\r\n        try:\r\n            self.manipulateTheDfDocketDataDependingOnCheckboxes()\r\n        except AttributeError:\r\n            pass\r\n        \r\n    def setupDataForBoardDrillingInformation(self):\r\n        # Clear and prep the data\r\n        self.df_docket_data = self.preprocessData(self.df_docket_data)\r\n\r\n        # Initialize data containers\r\n        self.planned_xy_2d, self.planned_xy_3d, self.drilled_xy_2d, self.drilled_xy_3d, self.currently_drilling_xy_2d, self.currently_drilling_xy_3d = [], [], [], [], [], []\r\n\r\n        # Generate masks for data filtering\r\n        mask_drilled, mask_planned, mask_drilling = self.generateMasks()\r\n\r\n        # Generate age-based masks\r\n        age_masks = self.createAgeMasks()\r\n\r\n        # Clean data\r\n        self.df_docket_data = self.cleanData(self.df_docket_data)\r\n\r\n        # Generate dataframes based on conditions\r\n\r\n        # For drilled\r\n        drilled_dfs = self.generateDataframes('drilled', mask_drilled, age_masks)\r\n        # For planned\r\n        planned_dfs = self.generateDataframes('planned', mask_planned, age_masks)\r\n        # For currently drilling\r\n        currently_drilling_dfs = self.generateDataframes('currently_drilling', mask_drilling, age_masks)\r\n\r\n\r\n        drilled_dataframes = [drilled_dfs['drilled_year'], drilled_dfs['drilled_5years'], drilled_dfs['drilled_10years'], drilled_dfs['drilled_all']]\r\n        planned_dataframes = [planned_dfs['planned_year'], planned_dfs['planned_5years'], planned_dfs['planned_10years'], planned_dfs['planned_all']]\r\n        currently_drilling_dataframes = [currently_drilling_dfs['currently_drilling_year'], currently_drilling_dfs['currently_drilling_5years'], currently_drilling_dfs['currently_drilling_10years'], currently_drilling_dfs['currently_drilling_all']]\r\n\r\n        # Filter out planned data based on drilled data\r\n        planned_dataframes = self.filterPlannedData(drilled_dataframes, planned_dataframes)\r\n\r\n        # Prepare final data structures\r\n        self.prepareFinalData(drilled_dataframes, planned_dataframes, currently_drilling_dataframes)\r\n\r\n    def preprocessData(self, df: pd.DataFrame) -> pd.DataFrame:\r\n        \"\"\"\r\n        Preprocesses well data by removing duplicates, sorting, and handling missing ages.\r\n\r\n        Performs the following operations in sequence:\r\n        1. Removes duplicate rows keeping first occurrence\r\n        2. Sorts data by API number\r\n        3. Resets DataFrame index\r\n        4. Fills missing well ages with 0\r\n\r\n        Args:\r\n            self: Parent class instance\r\n            df (pd.DataFrame): Input DataFrame containing well data.\r\n                Required columns:\r\n                - APINumber: Well identification number\r\n                - WellAge: Age of the well (can contain NaN values)\r\n\r\n        Returns:\r\n            pd.DataFrame: Processed DataFrame with:\r\n                - No duplicates\r\n                - Sorted by APINumber\r\n                - Reset index\r\n                - WellAge filled with 0 for missing values\r\n\r\n        Notes:\r\n            - Preserves all original columns except duplicates\r\n            - Assumes APINumber is a valid sorting key\r\n            - Treatment of NaN well ages as 0 typically indicates planned/permitted wells\r\n            - Original index is dropped during reset\r\n\r\n        Example:\r\n            >>> df = pd.DataFrame({\r\n            ...     'APINumber': [2, 1, 2, 3],\r\n            ...     'WellAge': [5.0, None, 5.0, 3.0]\r\n            ... })\r\n            >>> processed_df = preprocessData(self, df)\r\n            >>> processed_df['APINumber'].tolist()\r\n            [1, 2, 3]\r\n        \"\"\"\r\n        # Remove duplicates and sort\r\n        df = df.drop_duplicates(keep='first')\r\n        df = df.sort_values(by='APINumber')\r\n\r\n        # Reset index and handle missing ages\r\n        df = df.reset_index(drop=True)\r\n        df['WellAge'] = df['WellAge'].fillna(0)\r\n\r\n        return df\r\n\r\n    def generateMasks(self) -> Tuple[pd.Series, pd.Series, pd.Series]:\r\n        \"\"\"\r\n        Generates boolean masks for filtering well data based on drilling status and type.\r\n\r\n        Creates three separate boolean masks for categorizing wells:\r\n        1. Drilled wells (completed or vertical)\r\n        2. Planned wells (permitted or planned vertical)\r\n        3. Currently drilling wells\r\n\r\n        Args:\r\n            self: Parent class instance containing:\r\n                - df_docket_data (pd.DataFrame): DataFrame with well information\r\n                    Required columns:\r\n                    - CitingType: Type of well citation\r\n                    - CurrentWellStatus: Current status of the well\r\n\r\n        Returns:\r\n            Tuple[pd.Series, pd.Series, pd.Series]: Three boolean masks:\r\n                - mask_drilled: True for already drilled/completed wells\r\n                - mask_planned: True for planned/permitted wells\r\n                - mask_drilling: True for currently drilling wells\r\n\r\n        Notes:\r\n            - CitingType values considered as drilled: ['asdrilled', 'vertical']\r\n            - CitingType values considered as planned: ['planned', 'vertical']\r\n            - CurrentWellStatus value for drilling: ['Drilling']\r\n            - Masks can be used directly for DataFrame filtering\r\n\r\n        Example:\r\n            >>> drilled, planned, drilling = self.generateMasks()\r\n            >>> drilled_wells = self.df_docket_data[drilled]\r\n            >>> planned_wells = self.df_docket_data[planned]\r\n            >>> drilling_wells = self.df_docket_data[drilling]\r\n        \"\"\"\r\n        # Generate mask for drilled/completed wells\r\n        print('df_docket_data')\r\n        print(self.df_docket_data)\r\n        mask_drilled = self.df_docket_data['CitingType'].isin(['asdrilled', 'vertical'])\r\n\r\n        # Generate mask for planned/permitted wells\r\n        mask_planned = self.df_docket_data['CitingType'].isin(['planned', 'vertical'])\r\n\r\n        # Generate mask for currently drilling wells\r\n        mask_drilling = self.df_docket_data['CurrentWellStatus'].isin(['Drilling'])\r\n\r\n        return mask_drilled, mask_planned, mask_drilling\r\n\r\n    def createAgeMasks(self) -> List[pd.Series]:\r\n        \"\"\"\r\n        Creates boolean masks for filtering wells based on age thresholds.\r\n\r\n        Generates four boolean masks representing different well age ranges:\r\n        1. Wells up to 1 year old (â‰¤12 months)\r\n        2. Wells up to 5 years old (â‰¤60 months)\r\n        3. Wells up to 10 years old (â‰¤120 months)\r\n        4. All wells regardless of age (â‰¤9999 months)\r\n\r\n        Args:\r\n            self: Parent class instance containing:\r\n                - df_docket_data (pd.DataFrame): DataFrame with well information\r\n                    Required columns:\r\n                    - WellAge: Age of wells in months\r\n\r\n        Returns:\r\n            List[pd.Series]: List of four boolean masks where True indicates\r\n            wells within the respective age thresholds:\r\n            - mask[0]: Age â‰¤ 12 months\r\n            - mask[1]: Age â‰¤ 60 months\r\n            - mask[2]: Age â‰¤ 120 months\r\n            - mask[3]: Age â‰¤ 9999 months (effectively all wells)\r\n\r\n        Notes:\r\n            - WellAge is expected to be in months\r\n            - Missing/NaN ages should be handled before calling this function\r\n            - Masks can be used directly for DataFrame filtering\r\n            - The 9999 threshold effectively includes all wells\r\n\r\n        Example:\r\n            >>> age_masks = self.createAgeMasks()\r\n            >>> new_wells = self.df_docket_data[age_masks[0]]  # Wells â‰¤ 1 year\r\n            >>> mature_wells = self.df_docket_data[age_masks[2]]  # Wells â‰¤ 10 years\r\n        \"\"\"\r\n        # Create list of boolean masks for different age thresholds\r\n        return [\r\n            (self.df_docket_data['WellAge'] <= 12),  # 1 year threshold\r\n            (self.df_docket_data['WellAge'] <= 60),  # 5 year threshold\r\n            (self.df_docket_data['WellAge'] <= 120),  # 10 year threshold\r\n            (self.df_docket_data['WellAge'] <= 9999)  # All wells threshold\r\n        ]\r\n\r\n    def cleanData(self, df: pd.DataFrame) -> pd.DataFrame:\r\n        \"\"\"\r\n        Cleans the input DataFrame by removing rows with missing targeted elevation values.\r\n\r\n        Performs basic data cleaning by dropping any rows where the 'Targeted Elevation'\r\n        column contains null/NaN values. This ensures downstream calculations have valid\r\n        elevation data to work with.\r\n\r\n        Args:\r\n            self: Parent class instance\r\n            df (pd.DataFrame): Input DataFrame containing well data.\r\n                Required columns:\r\n                - Targeted Elevation: Well target elevation values (can contain NaN)\r\n\r\n        Returns:\r\n            pd.DataFrame: Cleaned DataFrame with:\r\n                - All rows containing null targeted elevations removed\r\n                - Original column structure preserved\r\n                - Original index structure preserved\r\n\r\n        Notes:\r\n            - Rows with NaN values in other columns are preserved\r\n            - No modifications are made to non-null values\r\n            - Does not reset the index after dropping rows\r\n            - Operation is not performed in-place; returns new DataFrame\r\n\r\n        Example:\r\n            >>> df = pd.DataFrame({\r\n            ...     'Targeted Elevation': [100.0, None, 200.0],\r\n            ...     'Other Data': [1, 2, 3]\r\n            ... })\r\n            >>> cleaned_df = cleanData(self, df)\r\n            >>> len(cleaned_df)\r\n            2\r\n        \"\"\"\r\n        # Remove rows with missing targeted elevation values\r\n        return df.dropna(subset=['Targeted Elevation'])\r\n\r\n    def generateDataframes(\r\n            self,\r\n            mask_type: Literal['drilled', 'planned', 'drilling'],\r\n            mask: pd.Series,\r\n            age_masks: list[pd.Series]\r\n    ) -> Dict[str, pd.DataFrame]:\r\n        \"\"\"\r\n        Generates filtered DataFrames based on well type and age ranges.\r\n\r\n        Creates a dictionary of DataFrames filtered by the specified mask type\r\n        (drilled/planned/drilling) and four different age ranges. Each DataFrame\r\n        is sorted and index-reset for consistency.\r\n\r\n        Args:\r\n            self: Parent class instance containing:\r\n                - df_docket_data (pd.DataFrame): Source DataFrame with well information\r\n                    Required columns:\r\n                    - APINumber: Well identification number\r\n                    - MeasuredDepth: Well depth measurement\r\n            mask_type (Literal['drilled', 'planned', 'drilling']): Type of wells to filter\r\n            mask (pd.Series): Boolean mask identifying well type\r\n            age_masks (list[pd.Series]): List of 4 boolean masks for age filtering:\r\n                - age_masks[0]: â‰¤ 12 months\r\n                - age_masks[1]: â‰¤ 60 months\r\n                - age_masks[2]: â‰¤ 120 months\r\n                - age_masks[3]: All wells\r\n\r\n        Returns:\r\n            Dict[str, pd.DataFrame]: Dictionary containing filtered DataFrames:\r\n                - {mask_type}_year: Wells within 1 year\r\n                - {mask_type}_5years: Wells within 5 years\r\n                - {mask_type}_10years: Wells within 10 years\r\n                - {mask_type}_all: All wells of specified type\r\n\r\n        Notes:\r\n            - All DataFrames are sorted by APINumber and MeasuredDepth\r\n            - Indexes are reset for all DataFrames\r\n            - Empty DataFrames may be returned if no wells match criteria\r\n            - Original data is not modified\r\n\r\n        Example:\r\n            >>> drilled_dfs = generateDataframes(self, 'drilled', mask_drilled, age_masks)\r\n            >>> print(f\"New drilled wells: {len(drilled_dfs['drilled_year'])}\")\r\n            >>> print(f\"All drilled wells: {len(drilled_dfs['drilled_all'])}\")\r\n        \"\"\"\r\n        # Initialize dictionary for storing filtered DataFrames\r\n        dataframes = {}\r\n\r\n        # Generate DataFrames for each age range\r\n        for i, age_range in enumerate(['year', '5years', '10years', 'all']):\r\n            # Create dictionary key combining mask type and age range\r\n            key = f\"{mask_type}_{age_range}\"\r\n\r\n            # Filter data using combined masks and sort\r\n            dataframes[key] = self.df_docket_data.loc[mask & age_masks[i]]\r\n            dataframes[key] = dataframes[key].reset_index(drop=True).sort_values(\r\n                by=['APINumber', 'MeasuredDepth']\r\n            )\r\n\r\n        return dataframes\r\n\r\n    def filterPlannedData(\r\n            self,\r\n            drilled_dataframes: List[pd.DataFrame],\r\n            planned_dataframes: List[pd.DataFrame]\r\n    ) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame, pd.DataFrame]:\r\n        \"\"\"\r\n        Filters planned well data by comparing against drilled wells for different time periods.\r\n\r\n        For each time period (1 year, 5 years, 10 years, and all time), removes planned wells\r\n        that have already been drilled from the planned wells dataset.\r\n\r\n        Args:\r\n            self: Parent class instance containing filterPlannedDataForYear method\r\n            drilled_dataframes (List[pd.DataFrame]): List of 4 DataFrames containing drilled well data:\r\n                - drilled_dataframes[0]: Wells drilled within 1 year\r\n                - drilled_dataframes[1]: Wells drilled within 5 years\r\n                - drilled_dataframes[2]: Wells drilled within 10 years\r\n                - drilled_dataframes[3]: All drilled wells\r\n            planned_dataframes (List[pd.DataFrame]): List of 4 DataFrames containing planned well data:\r\n                - planned_dataframes[0]: Wells planned within 1 year\r\n                - planned_dataframes[1]: Wells planned within 5 years\r\n                - planned_dataframes[2]: Wells planned within 10 years\r\n                - planned_dataframes[3]: All planned wells\r\n\r\n        Returns:\r\n            Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame, pd.DataFrame]:\r\n                - planned_year: Filtered planned wells for 1 year\r\n                - planned_5years: Filtered planned wells for 5 years\r\n                - planned_10years: Filtered planned wells for 10 years\r\n                - planned_all: Filtered planned wells for all time\r\n\r\n        Notes:\r\n            - Uses filterPlannedDataForYear helper method for each time period\r\n            - Maintains original DataFrame structure and column organization\r\n            - Does not modify input DataFrames\r\n            - Returns empty DataFrames if all planned wells have been drilled\r\n\r\n        Example:\r\n            >>> filtered_planned = filterPlannedData(self, drilled_dfs, planned_dfs)\r\n            >>> print(f\"Remaining planned wells (1yr): {len(filtered_planned[0])}\")\r\n        \"\"\"\r\n        # Filter planned wells for each time period using helper method\r\n        planned_year = self.filterPlannedDataForYear(\r\n            drilled_dataframes[0], planned_dataframes[0])  # 1 year filter\r\n\r\n        planned_5years = self.filterPlannedDataForYear(\r\n            drilled_dataframes[1], planned_dataframes[1])  # 5 year filter\r\n\r\n        planned_10years = self.filterPlannedDataForYear(\r\n            drilled_dataframes[2], planned_dataframes[2])  # 10 year filter\r\n\r\n        planned_all = self.filterPlannedDataForYear(\r\n            drilled_dataframes[3], planned_dataframes[3])  # All time filter\r\n\r\n        return planned_year, planned_5years, planned_10years, planned_all\r\n\r\n    def filterPlannedDataForYear(\r\n            self,\r\n            drilled_df: pd.DataFrame,\r\n            planned_df: pd.DataFrame\r\n    ) -> pd.DataFrame:\r\n        \"\"\"\r\n        Filters planned wells by removing those that have been drilled or are currently drilling.\r\n\r\n        Takes a DataFrame of planned wells and removes any wells that:\r\n        1. Already exist in the drilled wells dataset (based on APINumber)\r\n        2. Have a current status of \"Drilling\"\r\n\r\n        Args:\r\n            self: Parent class instance\r\n            drilled_df (pd.DataFrame): DataFrame containing drilled well data\r\n                Required columns:\r\n                - APINumber: Unique well identifier\r\n            planned_df (pd.DataFrame): DataFrame containing planned well data\r\n                Required columns:\r\n                - APINumber: Unique well identifier\r\n                - CurrentWellStatus: Current status of the well\r\n\r\n        Returns:\r\n            pd.DataFrame: Filtered planned wells DataFrame with:\r\n                - Wells that exist in drilled_df removed\r\n                - Wells with 'Drilling' status removed\r\n                - All other columns and data preserved\r\n                - Original index structure maintained\r\n\r\n        Notes:\r\n            - Uses APINumber for well identification and matching\r\n            - Case-sensitive matching for 'Drilling' status\r\n            - Does not modify input DataFrames\r\n            - Returns empty DataFrame if all planned wells are filtered out\r\n\r\n        Example:\r\n            >>> filtered_planned = filterPlannedDataForYear(\r\n            ...     drilled_df=drilled_wells,\r\n            ...     planned_df=planned_wells\r\n            ... )\r\n            >>> print(f\"Remaining planned wells: {len(filtered_planned)}\")\r\n        \"\"\"\r\n        # Filter out wells that are either drilled or currently drilling\r\n        planned_year = planned_df[\r\n            ~planned_df['APINumber'].isin(drilled_df['APINumber']) &\r\n            (planned_df['CurrentWellStatus'] != 'Drilling')\r\n            ]\r\n\r\n        return planned_year\r\n\r\n    def prepareFinalData(\r\n            self,\r\n            drilled_dataframes: Dict[str, pd.DataFrame],\r\n            planned_dataframes: Dict[str, pd.DataFrame],\r\n            currently_drilling_dataframes: Dict[str, pd.DataFrame]\r\n    ) -> None:\r\n        \"\"\"\r\n        Prepares and processes the final well data for all well categories.\r\n\r\n        Stores well data by category (drilled, planned, currently drilling) and processes\r\n        spatial (XY) coordinates for each category. Updates instance attributes with\r\n        processed data.\r\n\r\n        Args:\r\n            drilled_dataframes (Dict[str, pd.DataFrame]): Dictionary of drilled well DataFrames\r\n                Keys: 'drilled_year', 'drilled_5years', 'drilled_10years', 'drilled_all'\r\n            planned_dataframes (Dict[str, pd.DataFrame]): Dictionary of planned well DataFrames\r\n                Keys: 'planned_year', 'planned_5years', 'planned_10years', 'planned_all'\r\n            currently_drilling_dataframes (Dict[str, pd.DataFrame]): Dictionary of currently drilling well DataFrames\r\n                Keys: 'drilling_year', 'drilling_5years', 'drilling_10years', 'drilling_all'\r\n\r\n        Notes:\r\n            - Updates instance attributes:\r\n                self.drilled: Stores drilled well data\r\n                self.planned: Stores planned well data\r\n                self.currently_drilling: Stores currently drilling well data\r\n            - Processes XY coordinates for each well category using processXYData method\r\n            - Original DataFrames are not modified\r\n            - Empty DataFrames are handled gracefully\r\n\r\n        Side Effects:\r\n            - Modifies instance attributes (self.drilled, self.planned, self.currently_drilling)\r\n            - Calls processXYData which may modify additional instance attributes\r\n        \"\"\"\r\n        # Store DataFrames as instance attributes\r\n        self.drilled = drilled_dataframes\r\n        self.planned = planned_dataframes\r\n        self.currently_drilling = currently_drilling_dataframes\r\n\r\n        # Process spatial coordinates for each well category\r\n        self.processXYData(drilled_dataframes, 'drilled')  # Process drilled wells XY data\r\n        self.processXYData(planned_dataframes, 'planned')  # Process planned wells XY data\r\n        self.processXYData(currently_drilling_dataframes, 'currently_drilling')  # Process drilling wells XY data\r\n\r\n    def processXYData(self, dataframes: Dict[str, pd.DataFrame], data_type: Literal['drilled', 'planned', 'currently_drilling']) -> None:\r\n        \"\"\"\r\n        Processes spatial (XY) coordinate data for each well dataframe in a category.\r\n\r\n        Iterates through dataframes of a specific well type and processes their spatial\r\n        coordinates using the processSingleDataframe helper method. Handles different\r\n        time periods (1 year, 5 years, 10 years, all) for each well category.\r\n\r\n        Args:\r\n            self: Parent class instance containing:\r\n                - processSingleDataframe method for individual DataFrame processing\r\n            dataframes (Dict[str, pd.DataFrame]): Dictionary of well DataFrames\r\n                Keys expected in format: f\"{data_type}_{time_period}\"\r\n                where time_period is one of: year, 5years, 10years, all\r\n            data_type (Literal['drilled', 'planned', 'currently_drilling']):\r\n                Category of wells being processed\r\n\r\n        Notes:\r\n            - Processes spatial coordinates for visualization purposes\r\n            - Each DataFrame is processed sequentially\r\n            - Order of processing matches time period sequence:\r\n                1. year (â‰¤12 months)\r\n                2. 5years (â‰¤60 months)\r\n                3. 10years (â‰¤120 months)\r\n                4. all\r\n            - Relies on processSingleDataframe method for actual coordinate processing\r\n\r\n        Side Effects:\r\n            - Calls processSingleDataframe which may modify visualization attributes\r\n            - May update plot data or other visualization components\r\n\r\n        Example:\r\n            >>> processXYData(self, drilled_dataframes, 'drilled')\r\n        \"\"\"\r\n        # Process each DataFrame in the dictionary\r\n        for i, df in enumerate(dataframes):\r\n        # Call helper method to process individual DataFrame\r\n            self.processSingleDataframe(df, data_type, i)\r\n\r\n    # def processXYData(self, dataframes, data_type):\r\n    def processSingleDataframe(\r\n            self,\r\n            df: pd.DataFrame,\r\n            data_type: Literal['drilled', 'planned', 'currently_drilling'],\r\n            index: int\r\n    ) -> None:\r\n        \"\"\"\r\n        Processes a single well DataFrame to extract and store 2D and 3D spatial coordinates.\r\n\r\n        Extracts XY coordinates and organizes them for both 2D and 3D visualization purposes.\r\n        The processed data is stored in instance attributes for later plotting.\r\n\r\n        Args:\r\n            self: Parent class instance containing:\r\n                - createXYPointsDict method for coordinate extraction\r\n                - {data_type}_xy_2d attribute lists for 2D plotting\r\n                - {data_type}_xy_3d attribute lists for 3D plotting\r\n            df (pd.DataFrame): Well data DataFrame containing:\r\n                Required columns:\r\n                - APINumber: Unique well identifier\r\n                - X: X coordinate in state plane\r\n                - Y: Y coordinate in state plane\r\n            data_type (Literal['drilled', 'planned', 'currently_drilling']):\r\n                Category of wells being processed\r\n            index (int): Index for the time period being processed (0=1yr, 1=5yr, 2=10yr, 3=all)\r\n\r\n        Notes:\r\n            - Creates separate point collections for 2D and 3D visualization\r\n            - Points are organized by API number for consistent well identification\r\n            - Handles missing or invalid coordinates gracefully\r\n            - Data is appended to existing visualization lists\r\n\r\n        Side Effects:\r\n            - Modifies instance attributes:\r\n                - self.{data_type}_xy_2d: List of 2D coordinate sets\r\n                - self.{data_type}_xy_3d: List of 3D coordinate sets\r\n\r\n        Example:\r\n            >>> processSingleDataframe(df_wells, 'drilled', 0)\r\n            # Updates self.drilled_xy_2d[0] and self.drilled_xy_3d[0] with new coordinates\r\n        \"\"\"\r\n        # Generate dictionary of XY points for each well\r\n        xy_points_dict = self.createXYPointsDict(df)\r\n\r\n        # Get unique API numbers from the DataFrame\r\n        apinums: Set[str] = set(df['APINumber'])\r\n\r\n        # Create attribute keys for storing coordinates\r\n        xy_2d_key = f\"{data_type}_xy_2d\"\r\n        xy_3d_key = f\"{data_type}_xy_3d\"\r\n\r\n        # Extract 2D coordinates (X,Y) for visualization\r\n        xy_2d_data = [[r[:2] for r in v] for k, v in xy_points_dict.items()\r\n                      if k in apinums]\r\n\r\n        # Extract 3D coordinates (Z coordinates) for visualization\r\n        xy_3d_data = [[r[2:] for r in v] for k, v in xy_points_dict.items()\r\n                      if k in apinums]\r\n\r\n        # Store processed coordinate data in instance attributes\r\n        getattr(self, xy_2d_key).append(xy_2d_data)\r\n        getattr(self, xy_3d_key).append(xy_3d_data)\r\n\r\n    def createXYPointsDict(\r\n            self,\r\n            df: pd.DataFrame\r\n    ) -> Dict[str, List[List[float]]]:\r\n        \"\"\"\r\n        Creates a dictionary mapping API numbers to their coordinate points and elevation data.\r\n\r\n        Groups well data by API number and creates coordinate lists containing surface\r\n        coordinates (X,Y), state plane coordinates (SPX,SPY) and targeted elevation for\r\n        each well.\r\n\r\n        Args:\r\n            self: Parent class instance\r\n            df (pd.DataFrame): Well data DataFrame containing:\r\n                Required columns:\r\n                - APINumber: Unique well identifier\r\n                - X: Surface X coordinate\r\n                - Y: Surface Y coordinate\r\n                - SPX: State plane X coordinate\r\n                - SPY: State plane Y coordinate\r\n                - Targeted Elevation: Well's target elevation\r\n\r\n        Returns:\r\n            Dict[str, List[List[float]]]: Dictionary where:\r\n                - Keys: API numbers (str)\r\n                - Values: List of coordinate lists, each containing:\r\n                    [x, y, spx, spy, z] where:\r\n                    - x,y: Surface coordinates\r\n                    - spx,spy: State plane coordinates\r\n                    - z: Targeted elevation\r\n\r\n        Notes:\r\n            - All coordinate values are converted to float type\r\n            - Handles missing values by converting to float (may result in NaN)\r\n            - Groups data by APINumber to maintain well identity\r\n            - Coordinates are organized for both 2D and 3D visualization use\r\n\r\n        Example:\r\n            >>> xy_dict = createXYPointsDict(well_df)\r\n            >>> first_well = next(iter(xy_dict.values()))\r\n            >>> print(f\"First well coordinates: {first_well[0]}\")\r\n            First well coordinates: [1234.5, 5678.9, 1000.0, 2000.0, 3500.0]\r\n        \"\"\"\r\n        return {k: [[x, y, spx, spy, z] for x, y, spx, spy, z in\r\n                zip(g['X'].astype(float),\r\n                    g['Y'].astype(float),\r\n                    g['SPX'].astype(float),\r\n                    g['SPY'].astype(float),\r\n                    g['Targeted Elevation'].astype(float))]\r\n            for k, g in df.groupby('APINumber')}\r\n\r\n    def returnWellDataDependingOnParametersTest(self) -> None:\r\n        \"\"\"\r\n        Updates instance attributes with well data based on selected time period radio button.\r\n\r\n        Retrieves the currently selected time period from the UI radio button group and\r\n        updates relevant instance attributes with corresponding well data and spatial\r\n        coordinates for visualization.\r\n\r\n        Args:\r\n            self: Parent class instance containing:\r\n                Required UI elements:\r\n                - ui.drilling_within_button_group: QButtonGroup for time period selection\r\n                Required data attributes:\r\n                - drilled, planned, currently_drilling: DataFrames by time period\r\n                - *_xy_2d, *_xy_3d: Spatial coordinate lists by time period\r\n\r\n        Side Effects:\r\n            Updates the following instance attributes based on selected time period:\r\n            DataFrames:\r\n            - self.drilled_df: Drilled wells data\r\n            - self.planned_df: Planned wells data\r\n            - self.currently_drilling_df: Currently drilling wells data\r\n\r\n            2D Visualization Data:\r\n            - self.drilled_segments: Drilled wells 2D coordinates\r\n            - self.planned_segments: Planned wells 2D coordinates\r\n            - self.currently_drilling_segments: Drilling wells 2D coordinates\r\n\r\n            3D Visualization Data:\r\n            - self.drilled_segments_3d: Drilled wells 3D coordinates\r\n            - self.planned_segments_3d: Planned wells 3D coordinates\r\n            - self.currently_drilling_segments_3d: Drilling wells 3D coordinates\r\n\r\n        Notes:\r\n            - Time period index (id_1) corresponds to:\r\n              0: 1 year\r\n              1: 5 years\r\n              2: 10 years\r\n              3: All time\r\n            - All data structures must be pre-populated with corresponding time period data\r\n            - No validation is performed on the button group checked state\r\n        \"\"\"\r\n        # Get selected time period from UI radio button group\r\n        id_1 = self.ui.drilling_within_button_group.checkedId()\r\n\r\n        # Update DataFrame attributes for each well category\r\n        self.drilled_df = self.drilled[id_1]\r\n        self.planned_df = self.planned[id_1]\r\n        self.currently_drilling_df = self.currently_drilling[id_1]\r\n\r\n        # Update 2D visualization coordinates\r\n        self.drilled_segments = self.drilled_xy_2d[id_1]\r\n        self.planned_segments = self.planned_xy_2d[id_1]\r\n        self.currently_drilling_segments = self.currently_drilling_xy_2d[id_1]\r\n\r\n        # Update 3D visualization coordinates\r\n        self.drilled_segments_3d = self.drilled_xy_3d[id_1]\r\n        self.planned_segments_3d = self.planned_xy_3d[id_1]\r\n        self.currently_drilling_segments_3d = self.currently_drilling_xy_3d[id_1]\r\n\r\n    def manipulateTheDfDocketDataDependingOnCheckboxes(self):\r\n        \"\"\"\r\n           Main function for managing well visualization based on UI checkbox states.\r\n\r\n           Controls the display of different well types (drilled, planned, currently drilling)\r\n           and their properties in both 2D and 3D views. Handles well filtering, visibility,\r\n           styling, and related UI elements like field names.\r\n\r\n           Attributes Modified:\r\n               currently_used_lines (DataFrame): Tracks which well lines are currently displayed\r\n               field_sections (Artist): Visual elements for field sections\r\n               labels_field (Artist): Text labels for fields\r\n               Various matplotlib artists for well visualization\r\n\r\n           Side Effects:\r\n               - Updates 2D and 3D matplotlib canvases\r\n               - Modifies well line visibility and styling\r\n               - Updates field name labels\r\n               - Adjusts 3D view limits based on well positions\r\n               - Triggers well type/status filtering\r\n\r\n           Processing Steps:\r\n               1. Initializes local data references\r\n               2. Sets up data parameters for each well category\r\n               3. Applies type/status filtering\r\n               4. Handles field name visibility\r\n               5. Processes well display parameters\r\n               6. Toggles visibility for different well categories\r\n               7. Adjusts 3D view boundaries\r\n               8. Updates visualization canvases\r\n\r\n           Notes:\r\n               - Central function for well visualization control\r\n               - Connected to multiple UI checkbox events\r\n               - Manages both 2D and 3D visualizations\r\n               - Handles three main well categories:\r\n                   * As-drilled wells\r\n                   * Planned wells\r\n                   * Currently drilling wells\r\n               - Maintains visualization consistency across views\r\n               - Uses helper functions for data setup and display\r\n\r\n           Dependencies:\r\n               - setupData(): Prepares well data parameters\r\n               - statusAndTypesEnabler(): Manages well filtering\r\n               - toggleWellDisplay(): Controls well visibility\r\n               - calculateCentroidNP(): Computes 3D view center\r\n           \"\"\"\r\n        def platBounded(\r\n                df: pd.DataFrame,\r\n                segments: List[List[List[float]]],\r\n                segments_3d: List[List[List[float]]]\r\n        ) -> Tuple[pd.DataFrame, List[List[List[float]]], List[List[List[float]]]]:\r\n            \"\"\"\r\n            Filters and reorders well data and segments based on API numbers and measured depth.\r\n\r\n            Sorts well data by API number and measured depth, then filters the 2D and 3D\r\n            segment data to match only the wells present in the DataFrame. Maintains data\r\n            consistency across different representations of the same wells.\r\n\r\n            Args:\r\n                df (pd.DataFrame): Well data containing:\r\n                    Required columns:\r\n                    - APINumber: Unique well identifier\r\n                    - MeasuredDepth: Depth measurement along wellbore\r\n                segments (List[List[List[float]]]): 2D coordinate segments for visualization\r\n                    Format: [well][segment][x,y coordinates]\r\n                segments_3d (List[List[List[float]]]): 3D coordinate segments for visualization\r\n                    Format: [well][segment][z coordinates]\r\n\r\n            Returns:\r\n                Tuple containing:\r\n                - pd.DataFrame: Sorted and filtered well data\r\n                - List[List[List[float]]]: Filtered 2D segments matching DataFrame wells\r\n                - List[List[List[float]]]: Filtered 3D segments matching DataFrame wells\r\n\r\n            Notes:\r\n                - Maintains data consistency by filtering segments to match DataFrame wells\r\n                - Preserves original data structure and relationships\r\n                - Handles potential mismatches between DataFrame and segment data\r\n                - Returns empty lists for segments if no matches found\r\n\r\n            Example:\r\n                >>> df_filtered, seg_2d, seg_3d = platBounded(well_df, segments_2d, segments_3d)\r\n                >>> print(f\"Filtered to {len(seg_2d)} wells\")\r\n            \"\"\"\r\n            # Sort DataFrame by API number and measured depth\r\n            df = df.sort_values(by=['APINumber', 'MeasuredDepth'])\r\n\r\n            # Create index mapping for API numbers\r\n            api = df[['APINumber']].drop_duplicates().reset_index(drop=True)\r\n            api['index'] = api.index\r\n\r\n            # Merge to maintain relationships\r\n            merged = pd.merge(api, df, left_on='APINumber', right_on='APINumber')\r\n\r\n            # Filter segments to match DataFrame wells\r\n            segments = [segments[i] for i in range(len(segments)) if i in merged['index'].unique()]\r\n            segments_3d = [segments_3d[i] for i in range(len(segments_3d)) if i in merged['index'].unique()]\r\n\r\n            return df, segments, segments_3d\r\n\r\n        def setupData(\r\n                df: pd.DataFrame,\r\n                segments: List[List[List[float]]],\r\n                segments_3d: List[List[List[float]]]\r\n        ) -> Tuple[pd.DataFrame, List[List[List[float]]], List[List[List[float]]], Dict, pd.DataFrame]:\r\n            \"\"\"\r\n            Prepares well data and visualization parameters by filtering data and setting up default styling.\r\n\r\n            Processes well data through platBounded filter and creates default visualization\r\n            parameters for well segments including color and width attributes.\r\n\r\n            Args:\r\n                df (pd.DataFrame): Well data containing:\r\n                    Required columns:\r\n                    - APINumber: Unique well identifier\r\n                    - MeasuredDepth: Depth measurement along wellbore\r\n                segments (List[List[List[float]]]): 2D coordinate segments for visualization\r\n                    Format: [well][segment][x,y coordinates]\r\n                segments_3d (List[List[List[float]]]): 3D coordinate segments for visualization\r\n                    Format: [well][segment][z coordinates]\r\n\r\n            Returns:\r\n                Tuple containing:\r\n                - pd.DataFrame: Filtered and sorted well data\r\n                - List[List[List[float]]]: Filtered 2D segments\r\n                - List[List[List[float]]]: Filtered 3D segments\r\n                - Dict: Default styling parameters dictionary with:\r\n                    - color: List of colors (default 'black')\r\n                    - width: List of line widths (default 0.5)\r\n                - pd.DataFrame: Styling parameters as DataFrame\r\n\r\n            Notes:\r\n                - Uses platBounded to filter and align data\r\n                - Creates consistent default styling for all well segments\r\n                - Styling can be modified later by other functions\r\n                - Returns both dict and DataFrame versions of styling parameters\r\n                - All segments receive identical initial styling\r\n\r\n            Example:\r\n                >>> df, segs_2d, segs_3d, style_dict, style_df = setupData(wells_df, segments_2d, segments_3d)\r\n                >>> print(f\"Styled {len(style_df)} well segments\")\r\n            \"\"\"\r\n            # Filter and align data using platBounded\r\n            df, segments, segments_3d = platBounded(df, segments, segments_3d)\r\n\r\n            # Create default styling parameters\r\n            data = {'color': ['black'] * len(segments), 'width': [0.5] * len(segments)}\r\n\r\n            # Convert styling parameters to DataFrame\r\n            df_parameters = pd.DataFrame(data)\r\n\r\n            return df, segments, segments_3d, data, df_parameters\r\n\r\n        def wellChecked(\r\n                type: str,\r\n                column: Literal['CurrentWellType', 'CurrentWellStatus']\r\n        ) -> None:\r\n            \"\"\"\r\n            Updates well visualization parameters based on specified well type or status filter.\r\n\r\n            Modifies the styling (color and line width) of well segments in the visualization\r\n            based on either well type (e.g., Oil, Gas) or well status (e.g., Producing,\r\n            Shut-in). Wells matching the filter criteria are highlighted with specific colors\r\n            and increased line width.\r\n\r\n            Args:\r\n                type (str): Well type or status to filter by. Valid values depend on column:\r\n                    For CurrentWellType:\r\n                        - 'Oil Well'\r\n                        - 'Gas Well'\r\n                        - 'Water Disposal Well'\r\n                        - 'Water Injection Well'\r\n                        - 'Gas Injection Well'\r\n                        - 'Dry Hole'\r\n                        - 'Test Well'\r\n                        - 'Water Source Well'\r\n                        - 'Unknown'\r\n                    For CurrentWellStatus:\r\n                        - Status values from well database\r\n                column (Literal['CurrentWellType', 'CurrentWellStatus']):\r\n                    Column to filter on, determines color mapping used\r\n\r\n            Side Effects:\r\n                Updates these visualization parameter DataFrames:\r\n                - df_drilled_parameters\r\n                - df_planned_parameters\r\n                - df_drilling_parameters\r\n\r\n                Modifies:\r\n                - 'color': Changed from default black to type-specific color\r\n                - 'width': Increased from 0.5 to 1.5 for matching wells\r\n\r\n            Notes:\r\n                - Only processes first row per API number since color/type is constant per well\r\n                - Handles three well categories: drilled, planned, and currently drilling\r\n                - Uses predefined color mappings stored in WellTypeColor or WellStatusColor\r\n                - Non-matching wells retain default black color and 0.5 width\r\n                - Changes are reflected immediately in visualization\r\n\r\n            Example:\r\n                >>> wellChecked('Oil Well', 'CurrentWellType')\r\n                # Updates visualization to highlight all oil wells in red\r\n            \"\"\"\r\n            # Determine color mapping column based on filter type\r\n            colors_lst = 'WellTypeColor' if column == 'CurrentWellType' else 'WellStatusColor'\r\n\r\n            # Get first row for each API number to determine well properties\r\n            drilled_df_restricted = drilled_df.groupby('APINumber').first().reset_index()\r\n            planned_df_restricted = planned_df.groupby('APINumber').first().reset_index()\r\n            currently_drilling_df_restricted = currently_drilling_df.groupby('APINumber').first().reset_index()\r\n\r\n            # Create masks for wells matching specified type/status\r\n            drilled_well_mask = drilled_df_restricted[column] == type\r\n            planned_well_mask = planned_df_restricted[column] == type\r\n            currently_drilling_well_mask = currently_drilling_df_restricted[column] == type\r\n\r\n            # Update styling for drilled wells\r\n            df_drilled_parameters.loc[drilled_well_mask, 'color'] = drilled_df_restricted.loc[\r\n                drilled_well_mask, colors_lst]\r\n            df_drilled_parameters.loc[drilled_well_mask, 'width'] = 1.5\r\n\r\n            # Update styling for planned wells\r\n            df_planned_parameters.loc[planned_well_mask, 'color'] = planned_df_restricted.loc[\r\n                planned_well_mask, colors_lst]\r\n            df_planned_parameters.loc[planned_well_mask, 'width'] = 1.5\r\n\r\n            # Update styling for currently drilling wells\r\n            df_drilling_parameters.loc[currently_drilling_well_mask, 'color'] = currently_drilling_df_restricted.loc[\r\n                currently_drilling_well_mask, colors_lst]\r\n            df_drilling_parameters.loc[currently_drilling_well_mask, 'width'] = 1.5\r\n\r\n\r\n        def wellCheckedMultiple(\r\n                types: List[str],\r\n                column: Literal['CurrentWellType', 'CurrentWellStatus']\r\n        ) -> None:\r\n            \"\"\"\r\n            Updates well visualization parameters for multiple well types or statuses simultaneously.\r\n\r\n            Similar to wellChecked() but handles multiple types/statuses at once. Modifies the styling\r\n            (color and line width) of well segments in the visualization based on a list of well\r\n            types or statuses. Wells matching any of the filter criteria are highlighted.\r\n\r\n            Args:\r\n                types (List[str]): List of well types or statuses to filter by. Valid values depend on column:\r\n                    For CurrentWellType:\r\n                        - 'Oil Well'\r\n                        - 'Gas Well'\r\n                        - 'Water Disposal Well'\r\n                        - 'Oil Well/Water Disposal Well'\r\n                        - 'Water Injection Well'\r\n                        - 'Gas Injection Well'\r\n                        - 'Dry Hole'\r\n                        - etc.\r\n                    For CurrentWellStatus:\r\n                        - 'Location Abandoned - APD rescinded'\r\n                        - 'Returned APD (Unapproved)'\r\n                        - 'Approved Permit'\r\n                        - 'Active'\r\n                        - 'Drilling Operations Suspended'\r\n                        - 'New Permit'\r\n                        - 'Inactive'\r\n                        - 'Temporarily-abandoned'\r\n                        - 'Test Well or Monitor Well'\r\n                        - etc.\r\n                column (Literal['CurrentWellType', 'CurrentWellStatus']):\r\n                    Column to filter on, determines color mapping used\r\n\r\n            Side Effects:\r\n                Updates these visualization parameter DataFrames:\r\n                - df_drilled_parameters\r\n                - df_planned_parameters\r\n                - df_drilling_parameters\r\n\r\n                Modifies:\r\n                - 'color': Changed from default black to type-specific color\r\n                - 'width': Increased from 0.5 to 1.5 for matching wells\r\n\r\n            Notes:\r\n                - Only processes first row per API number since color/type is constant per well\r\n                - Handles three well categories: drilled, planned, and currently drilling\r\n                - Uses predefined color mappings stored in WellTypeColor or WellStatusColor\r\n                - Non-matching wells retain default black color and 0.5 width\r\n                - Changes are reflected immediately in visualization\r\n                - Commonly used for grouping related well types (e.g., all injection wells)\r\n                - Used by the GUI checkbox handlers to update multiple well types at once\r\n\r\n            Example:\r\n                >>> wellCheckedMultiple(['Water Injection Well', 'Gas Injection Well'], 'CurrentWellType')\r\n                # Updates visualization to highlight all injection wells\r\n            \"\"\"\r\n            # Determine color mapping column based on filter type\r\n            colors_lst = 'WellTypeColor' if column == 'CurrentWellType' else 'WellStatusColor'\r\n\r\n            # Get first row for each API number to determine well properties\r\n            drilled_df_restricted = drilled_df.groupby('APINumber').first().reset_index()\r\n            planned_df_restricted = planned_df.groupby('APINumber').first().reset_index()\r\n            currently_drilling_df_restricted = currently_drilling_df.groupby('APINumber').first().reset_index()\r\n\r\n            # Create masks for wells matching any specified type/status\r\n            drilled_well_mask = drilled_df_restricted[column].isin(types)\r\n            planned_well_mask = planned_df_restricted[column].isin(types)\r\n            currently_drilling_well_mask = currently_drilling_df_restricted[column].isin(types)\r\n\r\n            # Update styling for drilled wells\r\n            df_drilled_parameters.loc[drilled_well_mask, 'color'] = drilled_df_restricted.loc[\r\n                drilled_well_mask, colors_lst]\r\n            df_drilled_parameters.loc[drilled_well_mask, 'width'] = 1.5\r\n\r\n            # Update styling for planned wells\r\n            df_planned_parameters.loc[planned_well_mask, 'color'] = planned_df_restricted.loc[\r\n                planned_well_mask, colors_lst]\r\n            df_planned_parameters.loc[planned_well_mask, 'width'] = 1.5\r\n\r\n            # Update styling for currently drilling wells\r\n            df_drilling_parameters.loc[currently_drilling_well_mask, 'color'] = currently_drilling_df_restricted.loc[\r\n                currently_drilling_well_mask, colors_lst]\r\n            df_drilling_parameters.loc[currently_drilling_well_mask, 'width'] = 1.5\r\n\r\n      \r\n        def toggleWellDisplay(\r\n                condition: bool,\r\n                data_frame: pd.DataFrame,\r\n                segments_2d: List[List[float]],\r\n                colors_init: Union[str, List[str]],\r\n                line_width: Union[float, List[float]],\r\n                well_2d: Line2D,\r\n                well_3d: Line2D,\r\n                vertical_well: Line2D,\r\n                segments_3d: List[List[float]]\r\n        ) -> None:\r\n            \"\"\"\r\n            Toggles the visibility and updates data for well visualization elements based on a boolean condition.\r\n\r\n            Controls the display state and data updates for 2D, 3D and vertical well representations in the\r\n            visualization. When enabled, updates the data and makes wells visible. When disabled, hides the wells\r\n            without removing the underlying data.\r\n\r\n            Args:\r\n                condition (bool): Toggle state - True to show and update wells, False to hide them\r\n                data_frame (pd.DataFrame): Well data to incorporate into currently displayed wells\r\n                    Required columns:\r\n                    - Well identifiers\r\n                    - Coordinate data\r\n                    - Well properties\r\n                segments_2d (List[List[float]]): 2D coordinate segments for well paths\r\n                    Format: [[x1,y1], [x2,y2], ...]\r\n                colors_init (Union[str, List[str]]): Color specification for well lines\r\n                    Either single color string or list of colors per segment\r\n                line_width (Union[float, List[float]]): Width specification for well lines\r\n                    Either single width value or list of widths per segment\r\n                well_2d (Line2D): Matplotlib line object for 2D well representation\r\n                well_3d (Line2D): Matplotlib line object for 3D well representation\r\n                vertical_well (Line2D): Matplotlib line object for vertical well projection\r\n                segments_3d (List[List[float]]): 3D coordinate segments for well paths\r\n                    Format: [[x1,y1,z1], [x2,y2,z2], ...]\r\n\r\n            Side Effects:\r\n                - Updates self.currently_used_lines with new well data when enabled\r\n                - Modifies visibility of well_2d, well_3d and vertical_well line objects\r\n                - Triggers redraw of well visualizations when enabled\r\n                - Changes persist until next toggle operation\r\n\r\n            Notes:\r\n                - Uses drawModelBasedOnParameters2d() for 2D visualization updates\r\n                - Uses drawModelBasedOnParameters() for 3D visualization updates\r\n                - Maintains data state even when wells are hidden\r\n                - Deduplicates data when adding new wells\r\n                - Preserves existing well properties when toggling visibility\r\n\r\n            Example:\r\n                >>> toggleWellDisplay(True, new_wells_df, segs_2d, 'blue', 1.0,\r\n                                      well2d, well3d, vert_well, segs_3d)\r\n                # Shows wells and updates with new data\r\n                >>> toggleWellDisplay(False, new_wells_df, segs_2d, 'blue', 1.0,\r\n                                      well2d, well3d, vert_well, segs_3d)\r\n                # Hides wells without removing data\r\n            \"\"\"\r\n            if condition:\r\n                # Update data and show wells\r\n                self.currently_used_lines = concat([self.currently_used_lines, data_frame]).drop_duplicates(\r\n                    keep='first').reset_index(drop=True)\r\n\r\n                # Redraw 2D and 3D visualizations with updated parameters\r\n                self.drawModelBasedOnParameters2d(well_2d, segments_2d, colors_init, line_width, self.ax2d,\r\n                                                  vertical_well)\r\n                self.drawModelBasedOnParameters(well_3d, segments_3d, colors_init, line_width, self.ax3d)\r\n\r\n                # Make all well representations visible\r\n                well_2d.set_visible(True)\r\n                well_3d.set_visible(True)\r\n                vertical_well.set_visible(True)\r\n            else:\r\n                # Hide all well representations\r\n                well_2d.set_visible(False)\r\n                well_3d.set_visible(False)\r\n                vertical_well.set_visible(False)\r\n\r\n\r\n        def statusAndTypesEnabler() -> NoReturn:\r\n            \"\"\"\r\n            Manages well visualization filters and field label visibility based on UI state.\r\n\r\n            Coordinates the mutual exclusivity between well type and status filters while\r\n            maintaining independent control of field label visibility. Handles three main\r\n            aspects of visualization:\r\n            1. Well type filtering (for Oil, Gas, Injection, Disposal wells etc.)\r\n            2. Well status filtering (Producing, Shut-in, P&A, Drilling etc.)\r\n            3. Field name label visibility\r\n\r\n            Radio Button IDs:\r\n                -2: Well Type filtering mode (Oil, Gas, Injection, etc.)\r\n                -3: Well Status filtering mode (Producing, Shut-in, etc.)\r\n\r\n            Field Labels:\r\n                - Displayed as red text at field centroids when enabled\r\n                - Size: 75 units\r\n                - Visibility tied to field_names_checkbox state\r\n\r\n            Side Effects:\r\n                - Updates well visibility based on selected filter mode\r\n                - Modifies field label and section visibility\r\n                - Changes currently_used_lines DataFrame content\r\n                - Triggers field label rendering when enabled\r\n                - Maintains field visibility state independent of filter changes\r\n\r\n            Notes:\r\n                - Part of the well visualization control system\r\n                - Connected to radio button and checkbox state changes\r\n                - Preserves field label state across filter changes\r\n                - Ensures proper layering of visual elements\r\n                - Manages memory by creating field labels only when visible\r\n                - Coordinates with wellTypesEnable() and wellStatusEnable()\r\n\r\n            Example:\r\n                Called when switching between well type/status or toggling field names:\r\n                >>> self.ui.well_type_or_status_button_group.buttonClicked.connect(\r\n                        self.statusAndTypesEnabler)\r\n                >>> self.ui.field_names_checkbox.stateChanged.connect(\r\n                        self.statusAndTypesEnabler)\r\n            \"\"\"\r\n            # Store field checkbox state to preserve across filter changes\r\n            field_checkbox_state = self.ui.field_names_checkbox.isChecked()\r\n\r\n            # Get the ID of currently selected radio button\r\n            active_button_id_type_status = self.ui.well_type_or_status_button_group.checkedId()\r\n\r\n            # Enable well type filtering mode\r\n            if active_button_id_type_status == -2:\r\n                wellTypesEnable()\r\n            # Enable well status filtering mode\r\n            elif active_button_id_type_status == -3:\r\n                wellStatusEnable()\r\n\r\n            # Handle field label visibility independent of filter state\r\n            if field_checkbox_state:\r\n                self.field_sections.set_visible(True)\r\n                # Create field label paths with consistent styling\r\n                paths = [\r\n                    PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\")\r\n                    for coord, text in zip(self.field_centroids_lst, self.field_labels)\r\n                ]\r\n                self.labels_field.set_paths(paths)\r\n                self.labels_field.set_visible(True)\r\n            else:\r\n                self.field_sections.set_visible(False)\r\n                self.labels_field.set_visible(False)\r\n\r\n\r\n        def wellTypesEnable() -> NoReturn:\r\n            \"\"\"\r\n            Enables well type filtering while temporarily disabling well status filters.\r\n\r\n            Updates the visualization based on selected well type checkboxes in the UI.\r\n            Temporarily blocks signals from status checkboxes to prevent interference\r\n            between type and status filters.\r\n\r\n            Well Types Handled:\r\n                - Oil Wells\r\n                - Gas Wells\r\n                - Water Disposal Wells (including dual-purpose Oil/Disposal wells)\r\n                - Dry Holes\r\n                - Injection Wells (Water and Gas)\r\n                - Other Wells (Unknown, Test Wells, Water Source Wells)\r\n\r\n            Side Effects:\r\n                # - Temporarily blocks signals from status checkboxes\r\n                - Unchecks all status checkboxes\r\n                - Updates well visualization based on checked type filters\r\n                # - Restores signal handling for status checkboxes\r\n                - Modifies well colors and visibility in the visualization\r\n                - Updates currently_used_lines DataFrame\r\n\r\n            Notes:\r\n                - Uses wellChecked() for single well types\r\n                - Uses wellCheckedMultiple() for grouped well types\r\n                - Ensures mutual exclusivity between type and status filters\r\n                - Part of the well visualization control system\r\n                - Connected to UI checkbox state changes\r\n                - Maintains separation between well type and status filtering\r\n\r\n            Example:\r\n                Called when user interacts with well type checkboxes:\r\n                >>> self.ui.oil_well_check.stateChanged.connect(self.wellTypesEnable)\r\n            \"\"\"\r\n            # Temporarily disable status checkbox signals\r\n            # for q in self.status_checks:\r\n            #     q.blockSignals(True)\r\n            #     q.setChecked(False)\r\n\r\n            # Handle Oil Well selection\r\n            if self.ui.oil_well_check.isChecked():\r\n                wellChecked('Oil Well', 'CurrentWellType')\r\n\r\n            # Handle Gas Well selection\r\n            if self.ui.gas_well_check.isChecked():\r\n                wellChecked('Gas Well', 'CurrentWellType')\r\n\r\n            # Handle Water Disposal Well selection (including combination wells)\r\n            if self.ui.water_disposal_check.isChecked():\r\n                wellCheckedMultiple(['Water Disposal Well', 'Oil Well/Water Disposal Well'], 'CurrentWellType')\r\n\r\n            # Handle Dry Hole selection\r\n            if self.ui.dry_hole_check.isChecked():\r\n                wellChecked('Dry Hole', 'CurrentWellType')\r\n\r\n            # Handle Injection Well selection (both water and gas)\r\n            if self.ui.injection_check.isChecked():\r\n                wellCheckedMultiple(['Water Injection Well', 'Gas Injection Well'], 'CurrentWellType')\r\n\r\n            # Handle Other Well Types selection\r\n            if self.ui.other_well_status_check.isChecked():\r\n                wellCheckedMultiple(['Unknown', 'Test Well', 'Water Source Well'], 'CurrentWellType')\r\n\r\n            # Re-enable status checkbox signals\r\n            # for q in self.status_checks:\r\n                # q.blockSignals(False)\r\n\r\n        def wellStatusEnable() -> NoReturn:\r\n            \"\"\"\r\n            Enables well status filtering while temporarily disabling well type filters.\r\n\r\n            Updates the visualization based on selected well status checkboxes in the UI.\r\n            Temporarily blocks signals from type checkboxes to prevent interference\r\n            between status and type filters.\r\n\r\n            Well Statuses Handled:\r\n                - Shut-in wells\r\n                - Plugged & Abandoned wells\r\n                - Producing wells\r\n                - Currently drilling wells\r\n                - Miscellaneous statuses:\r\n                    - Location Abandoned (APD rescinded)\r\n                    - Returned APD (Unapproved)\r\n                    - Approved Permit\r\n                    - Active\r\n                    - Drilling Operations Suspended\r\n                    - New Permit\r\n                    - Inactive\r\n                    - Temporarily-abandoned\r\n                    - Test/Monitor Wells\r\n\r\n            Side Effects:\r\n                - Temporarily blocks signals from type checkboxes\r\n                - Unchecks all type checkboxes\r\n                - Updates well visualization based on checked status filters\r\n                - Restores signal handling for type checkboxes\r\n                - Modifies well colors and visibility in visualization\r\n                - Updates currently_used_lines DataFrame\r\n\r\n            Notes:\r\n                - Uses wellChecked() for single well statuses\r\n                - Uses wellCheckedMultiple() for grouped miscellaneous statuses\r\n                - Ensures mutual exclusivity between status and type filters\r\n                - Part of the well visualization control system\r\n                - Connected to UI checkbox state changes\r\n                - Maintains separation between well status and type filtering\r\n\r\n            Example:\r\n                Called when user interacts with well status checkboxes:\r\n                >>> self.ui.shut_in_check.stateChanged.connect(self.wellStatusEnable)\r\n            \"\"\"\r\n            # Temporarily disable type checkbox signals\r\n            # for q in self.type_checks:\r\n            #     q.blockSignals(True)\r\n            #     q.setChecked(False)\r\n\r\n            # Handle Shut-in wells\r\n            if self.ui.shut_in_check.isChecked():\r\n                wellChecked('Shut-in', 'CurrentWellStatus')\r\n\r\n            # Handle Plugged & Abandoned wells\r\n            if self.ui.pa_check.isChecked():\r\n                wellChecked('Plugged & Abandoned', 'CurrentWellStatus')\r\n\r\n            # Handle Producing wells\r\n            if self.ui.producing_check.isChecked():\r\n                wellChecked('Producing', 'CurrentWellStatus')\r\n\r\n            # Handle Currently Drilling wells\r\n            if self.ui.drilling_status_check.isChecked():\r\n                wellChecked('Drilling', 'CurrentWellStatus')\r\n\r\n            # Handle Miscellaneous well statuses\r\n            if self.ui.misc_well_type_check.isChecked():\r\n                wellCheckedMultiple(['Location Abandoned - APD rescinded',\r\n                                     'Returned APD (Unapproved)', 'Approved Permit',\r\n                                     'Active', 'Drilling Operations Suspended', 'New Permit', 'Inactive',\r\n                                     'Temporarily-abandoned', 'Test Well or Monitor Well'], 'CurrentWellStatus')\r\n\r\n            # Re-enable type checkbox signals\r\n            # for q in self.type_checks:\r\n            #     q.blockSignals(False)\r\n\r\n        # Reset current line tracking\r\n        self.currently_used_lines = None\r\n\r\n        # Store segment and DataFrame references locally\r\n        drilled_segments = self.drilled_segments\r\n        planned_segments = self.planned_segments\r\n        currently_drilling_segments = self.currently_drilling_segments\r\n\r\n        drilled_segments_3d = self.drilled_segments_3d\r\n        planned_segments_3d = self.planned_segments_3d\r\n        currently_drilling_segments_3d = self.currently_drilling_segments_3d\r\n\r\n        drilled_df = self.drilled_df\r\n        planned_df = self.planned_df\r\n        currently_drilling_df = self.currently_drilling_df\r\n\r\n        # Process each well category data\r\n        drilled_df, drilled_segments, drilled_segments_3d, data_drilled, df_drilled_parameters = setupData(\r\n            drilled_df, drilled_segments, drilled_segments_3d)\r\n        planned_df, planned_segments, planned_segments_3d, data_planned, df_planned_parameters = setupData(\r\n            planned_df, planned_segments, planned_segments_3d)\r\n        currently_drilling_df, currently_drilling_segments, currently_drilling_segments_3d, data_drilling, df_drilling_parameters = setupData(\r\n            currently_drilling_df, currently_drilling_segments, currently_drilling_segments_3d)\r\n\r\n        # Update well type/status filters\r\n        statusAndTypesEnabler()\r\n        # Handle field name visibility\r\n        if self.ui.field_names_checkbox.isChecked():\r\n            self.field_sections.set_visible(True)\r\n            paths = [PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\")\r\n                     for coord, text in zip(self.field_centroids_lst, self.field_labels)]\r\n            self.labels_field.set_paths(paths)\r\n            self.labels_field.set_visible(True)\r\n        else:\r\n            self.field_sections.set_visible(False)\r\n            self.labels_field.set_visible(False)\r\n\r\n        # Extract visualization parameters\r\n        drilled_colors_init, drilled_line_width = df_drilled_parameters['color'].tolist(), df_drilled_parameters[\r\n            'width'].tolist()\r\n        planned_colors_init, planned_line_width = df_planned_parameters['color'].tolist(), df_planned_parameters[\r\n            'width'].tolist()\r\n        currently_drilling_colors_init, currently_drilling_width = df_drilling_parameters['color'].tolist(), \\\r\n        df_drilling_parameters['width'].tolist()\r\n\r\n        # Toggle visibility for each well category\r\n        toggleWellDisplay(\r\n            self.ui.asdrilled_check.isChecked(), drilled_df,\r\n            drilled_segments, drilled_colors_init, drilled_line_width,\r\n            self.all_wells_2d_asdrilled, self.all_wells_3d_asdrilled,\r\n            self.all_wells_2d_vertical_asdrilled, drilled_segments_3d)\r\n\r\n        toggleWellDisplay(\r\n            self.ui.planned_check.isChecked(), planned_df,\r\n            planned_segments, planned_colors_init, planned_line_width,\r\n            self.all_wells_2d_planned, self.all_wells_3d_planned,\r\n            self.all_wells_2d_vertical_planned, planned_segments_3d)\r\n\r\n        toggleWellDisplay(\r\n            self.ui.currently_drilling_check.isChecked(), currently_drilling_df,\r\n            currently_drilling_segments, currently_drilling_colors_init, currently_drilling_width,\r\n            self.all_wells_2d_current, self.all_wells_3d_current,\r\n            self.all_wells_2d_vertical_current, currently_drilling_segments_3d)\r\n\r\n        # Update 3D plot boundaries if drilled segments exist\r\n        if drilled_segments_3d:\r\n            self.centroid, std_vals = self.calculateCentroidNP(drilled_segments_3d)\r\n            new_xlim = [self.centroid[0] - 10000, self.centroid[0] + 10000]\r\n            new_ylim = [self.centroid[1] - 10000, self.centroid[1] + 10000]\r\n            new_zlim = [self.centroid[2] - 10000, self.centroid[2] + 10000]\r\n            self.ax3d.set_xlim3d(new_xlim)\r\n            self.ax3d.set_ylim3d(new_ylim)\r\n            self.ax3d.set_zlim3d(new_zlim)\r\n\r\n        # Refresh all canvases\r\n        self.canvas2d.blit(self.ax2d.bbox)\r\n        self.canvas2d.draw()\r\n        self.canvas3d.blit(self.ax3d.bbox)\r\n        self.canvas3d.draw()\r\n\r\n    def returnSegmentsFromDF(self, df: pd.DataFrame) -> List[List[List[float]]]:\r\n        \"\"\"\r\n        Converts well coordinate data from a DataFrame into nested segment lists.\r\n\r\n        Takes a DataFrame containing well coordinates and groups them by API number,\r\n        converting X/Y coordinates into lists of [x,y] float pairs for each well segment.\r\n\r\n        Args:\r\n            df: pd.DataFrame containing well coordinate data with columns:\r\n                - APINumber: Well identifier\r\n                - X: X-coordinate values\r\n                - Y: Y-coordinate values\r\n\r\n        Returns:\r\n            List[List[List[float]]]: Nested list structure where:\r\n                - Outer list contains all wells\r\n                - Middle list contains segments for each well\r\n                - Inner list contains [x,y] float coordinate pairs\r\n\r\n        Note:\r\n            - Assumes coordinates are numeric/string convertible to float\r\n            - Groups data by APINumber to maintain well segment relationships\r\n            - Preserves coordinate order within each well grouping\r\n\r\n        Example:\r\n            >>> df = pd.DataFrame({\r\n            ...     'APINumber': [1, 1, 2, 2],\r\n            ...     'X': ['100.5', '101.5', '200.5', '201.5'],\r\n            ...     'Y': ['500.5', '501.5', '600.5', '601.5']\r\n            ... })\r\n            >>> segments = returnSegmentsFromDF(df)\r\n            >>> segments\r\n            [\r\n                [[100.5, 500.5], [101.5, 501.5]],  # Well 1\r\n                [[200.5, 600.5], [201.5, 601.5]]   # Well 2\r\n            ]\r\n        \"\"\"\r\n        return [[[float(x), float(y)] for x, y in zip(group['X'], group['Y'])]\r\n                for _, group in df.groupby('APINumber')]\r\n\r\n    def drawModelBasedOnParameters2d(\r\n            self,\r\n            lst: LineCollection,\r\n            segments: List[List[List[float]]],\r\n            colors: List[str],\r\n            line_width: List[float],\r\n            ax: plt.Axes,\r\n            scat_line: plt.scatter\r\n    ) -> None:\r\n        \"\"\"\r\n        Draws 2D well segments with specialized handling for vertical wells.\r\n\r\n        Renders well segments on a 2D matplotlib plot, with different handling for\r\n        vertical vs directional wells. Vertical wells (segments with exactly 2 points)\r\n        are displayed as scatter points, while other wells are shown as line segments.\r\n\r\n        Args:\r\n            lst: LineCollection object for drawing well segments\r\n            segments: List of well segments, where each segment is a list of [x,y] coordinates\r\n            colors: List of colors corresponding to each segment\r\n            line_width: List of line widths for each segment\r\n            ax: Matplotlib axes object for drawing\r\n            scat_line: Scatter plot object for vertical well visualization\r\n\r\n        Side Effects:\r\n            - Updates scatter plot data for vertical wells\r\n            - Updates LineCollection for directional wells\r\n            - Refreshes plot artists\r\n            - Modifies scatter point colors and positions\r\n            - Updates line segment properties\r\n\r\n        Notes:\r\n            - Vertical wells are identified by having exactly 2 points\r\n            - Empty segments result in scatter points being reset\r\n            - Color matching is maintained between segments and scatter points\r\n            - Drawing is optimized to minimize redraw operations\r\n            - Handles both single-point and multi-point segments\r\n\r\n        Example Usage:\r\n            >>> self.drawModelBasedOnParameters2d(\r\n                    well_collection,\r\n                    [[x1,y1], [x2,y2]],  # segments\r\n                    ['red', 'blue'],      # colors\r\n                    [1.0, 1.0],          # line widths\r\n                    ax,\r\n                    scatter_points\r\n                )\r\n        \"\"\"\r\n        colors_scatter = []\r\n        collapsed_points = []\r\n\r\n        try:\r\n            # Extract vertical well data (segments with exactly 2 points)\r\n            lst_vertical_indexes, lst_vertical_data = zip(*[\r\n                (i, val) for i, val in enumerate(segments) if len(val) == 2\r\n            ])\r\n            # Convert vertical well coordinates to tuples\r\n            lst_vertical_data = [tuple(i[0]) for i in lst_vertical_data]\r\n            # Match colors to vertical well indices\r\n            data_color = [colors[i] for i in lst_vertical_indexes]\r\n            # Update scatter plot with vertical well data\r\n            scat_line.set_offsets(lst_vertical_data)\r\n            scat_line.set_facecolor(data_color)\r\n        except ValueError:\r\n            scat_line.set_offsets([None, None])\r\n\r\n        # Handle empty or populated segments\r\n        if len(segments) == 0:\r\n            scat_line.set_offsets([None, None])\r\n        else:\r\n            # Process segments for visualization\r\n            for i in range(len(segments)):\r\n                if len(segments[i]) <= 2:\r\n                    used_colors = [colors[i]] * len(segments[i])\r\n                    colors_scatter.extend(used_colors)\r\n                    collapsed_points.extend(segments[i])\r\n            if len(collapsed_points) > 0:\r\n                scat_line.set_offsets(collapsed_points)\r\n\r\n        # Update visual properties\r\n        scat_line.set_facecolor(colors_scatter)\r\n        lst.set_segments(segments)\r\n        lst.set_colors(colors)\r\n        lst.set_linewidth(line_width)\r\n        ax.draw_artist(lst)\r\n\r\n    def drawModelBasedOnParameters(\r\n            self,\r\n            lst: LineCollection,\r\n            segments: List[List[List[float]]],\r\n            colors: List[str],\r\n            line_width: List[float],\r\n            ax: plt.Axes\r\n    ) -> None:\r\n        \"\"\"\r\n        Sets basic visual properties for well segments and renders them on the plot.\r\n\r\n        A simplified version of drawModelBasedOnParameters2d that handles only line\r\n        segments without special cases for vertical wells. Used primarily for 3D\r\n        visualization where scatter points are not needed.\r\n\r\n        Args:\r\n            lst: LineCollection object containing the well segments to be drawn\r\n            segments: List of well segments where each segment is a list of coordinate pairs\r\n            colors: List of colors corresponding to each well segment\r\n            line_width: List of line widths for each segment\r\n            ax: Matplotlib axes object to draw on\r\n\r\n        Side Effects:\r\n            - Updates LineCollection segment data\r\n            - Modifies segment colors and line widths\r\n            - Triggers redraw of plot artist\r\n\r\n        Notes:\r\n            - Part of the well visualization pipeline\r\n            - Handles both 2D and 3D plotting contexts\r\n            - No special handling for vertical wells\r\n            - Coordinates must be in the correct format for the plotting dimension\r\n            - Colors should match the number of segments\r\n\r\n        Example:\r\n            >>> self.drawModelBasedOnParameters(\r\n                    well_collection,\r\n                    [[[x1,y1,z1], [x2,y2,z2]]],  # 3D segments\r\n                    ['blue'],                      # colors\r\n                    [1.0],                         # line widths\r\n                    ax3d\r\n                )\r\n        \"\"\"\r\n        lst.set_segments(segments)\r\n        lst.set_colors(colors)\r\n        lst.set_linewidth(line_width)\r\n        ax.draw_artist(lst)\r\n\r\n    def generateColorPalette(self) -> List[QColor]:\r\n        \"\"\"\r\n        Generates a color-blind friendly palette of QColor objects.\r\n\r\n        Creates a carefully selected palette of colors that are distinguishable\r\n        by colorblind individuals while maintaining aesthetic appeal. The palette\r\n        includes a mix of primary, secondary, and tertiary colors with sufficient\r\n        contrast between adjacent colors.\r\n\r\n        Returns:\r\n            List[QColor]: List of QColor objects representing the color palette\r\n\r\n        Color Categories:\r\n            - Base Colors (0-7): Primary distinctive colors for main categories\r\n            - Extended Set (8-15): Secondary colors for additional categories\r\n            - Accent Colors (16-23): Tertiary colors for highlighting\r\n            - Supplementary (24-38): Additional colors for large datasets\r\n\r\n        Color Properties:\r\n            - All colors are specified in hex format for precision\r\n            - Includes a mix of warm and cool tones\r\n            - Maintains sufficient brightness contrast\r\n            - Avoids problematic color combinations for common types of color blindness\r\n\r\n        Usage Notes:\r\n            - Colors are ordered by visual distinctiveness\r\n            - Black is included last as a fallback/default color\r\n            - Suitable for both light and dark backgrounds\r\n            - Verified for deuteranopia and protanopia visibility\r\n\r\n        Example:\r\n            >>> palette = self.generateColorPalette()\r\n            >>> first_color = palette[0]  # Returns QColor for blue (#0072B2)\r\n        \"\"\"\r\n        # Color-blind friendly palette with semantic groupings\r\n        colors = [\r\n            \"#0072B2\",  # Blue - Primary visual anchor\r\n            \"#E69F00\",  # Orange - Strong contrast to blue\r\n            \"#009E73\",  # Green - Natural/environmental\r\n            \"#CC79A7\",  # Pink - Soft highlight\r\n            \"#56B4E9\",  # Sky Blue - Light accent\r\n            \"#D55E00\",  # Vermillion - Warning/alert\r\n            \"#660099\",  # Purple - Rich accent\r\n            \"#994F00\",  # Brown - Earth tone\r\n            \"#334B5C\",  # Dark Slate - Neutral accent\r\n            \"#0000FF\",  # Pure Blue - Basic reference\r\n            \"#FF0000\",  # Red - Critical/alert\r\n            \"#006600\",  # Dark Green - Secondary natural\r\n            \"#FF00FF\",  # Magenta - High visibility\r\n            \"#8B4513\",  # Saddle Brown - Natural accent\r\n            \"#800000\",  # Maroon - Deep accent\r\n            \"#808000\",  # Olive - Muted natural\r\n            \"#FF1493\",  # Deep Pink - Vibrant accent\r\n            \"#00CED1\",  # Dark Turquoise - Cool accent\r\n            \"#8B008B\",  # Dark Magenta - Rich contrast\r\n            \"#556B2F\",  # Dark Olive Green - Muted accent\r\n            \"#FF8C00\",  # Dark Orange - Warm accent\r\n            \"#9932CC\",  # Dark Orchid - Royal accent\r\n            \"#8B0000\",  # Dark Red - Deep warning\r\n            \"#008080\",  # Teal - Professional accent\r\n            \"#4B0082\",  # Indigo - Deep cool\r\n            \"#B8860B\",  # Dark Goldenrod - Warm natural\r\n            \"#32CD32\",  # Lime Green - Bright natural\r\n            \"#800080\",  # Purple - Deep rich\r\n            \"#A0522D\",  # Sienna - Earth accent\r\n            \"#FF4500\",  # Orange Red - High alert\r\n            \"#00FF00\",  # Lime - Maximum visibility\r\n            \"#4682B4\",  # Steel Blue - Industrial\r\n            \"#FFA500\",  # Orange - Standard warning\r\n            \"#DEB887\",  # Burlywood - Neutral natural\r\n            \"#5F9EA0\",  # Cadet Blue - Muted cool\r\n            \"#D2691E\",  # Chocolate - Rich warm\r\n            \"#CD5C5C\",  # Indian Red - Soft warning\r\n            \"#708090\",  # Slate Gray - Neutral cool\r\n            \"#000000\"  # Black - Ultimate contrast\r\n        ]\r\n\r\n        # Convert hex colors to QColor objects\r\n        return [QColor(color) for color in colors]\r\n    def getColorForIndex(self, index: int) -> QColor:\r\n        \"\"\"\r\n        Retrieves a color from the color palette using modulo indexing.\r\n\r\n        Safely accesses the color palette by wrapping around to the start when\r\n        the index exceeds the palette length, ensuring a color is always returned\r\n        regardless of the input index value.\r\n\r\n        Args:\r\n            index: Integer index to select a color from the palette. Can be any value\r\n                   as modulo arithmetic will be applied\r\n\r\n        Returns:\r\n            QColor: Color object from the palette corresponding to the wrapped index\r\n\r\n        Notes:\r\n            - Uses modulo operation to wrap indices exceeding palette length\r\n            - Assumes self.color_palette is initialized with QColor objects\r\n            - Part of the color management system for visualization\r\n            - Returns consistent colors for the same index values\r\n\r\n        Example:\r\n            >>> color = self.getColorForIndex(5)  # Returns 6th color\r\n            >>> color = self.getColorForIndex(len(palette) + 2)  # Wraps to 3rd color\r\n        \"\"\"\r\n        return self.color_palette[index % len(self.color_palette)]\r\n\r\n    def createOwnershipLabels(self) -> None:\r\n        \"\"\"\r\n        Creates and manages ownership label display based on checkbox and radio button states.\r\n\r\n        Handles the creation and display of ownership labels by either owner or agency,\r\n        depending on UI selection. Cleans up existing labels before creating new ones\r\n        and processes the data according to the selected view mode.\r\n\r\n        Side Effects:\r\n            - Clears existing owner and agency labels\r\n            - Creates new labels based on selection\r\n            - Updates the owner layout with new labels\r\n            - Modifies visibility of ownership information\r\n\r\n        Notes:\r\n            - Requires initialized self.owner_label_list and self.agency_label_list\r\n            - Depends on self.ui.ownership_checkbox state\r\n            - Uses ownership button group with IDs:\r\n                * -2: Owner view\r\n                * -3: Agency view\r\n            - Processes data using owner_model or agency_model based on selection\r\n\r\n        UI Dependencies:\r\n            - self.ui.ownership_checkbox: Controls overall visibility\r\n            - self.ui.ownership_button_group: Controls view mode\r\n            - self.owner_layout: Layout container for labels\r\n\r\n        Data Dependencies:\r\n            - self.owner_model: Contains owner information\r\n            - self.agency_model: Contains agency information\r\n            - owner_color/agency_color: Color coding for visual representation\r\n\r\n        Example:\r\n            >>> self.createOwnershipLabels()  # Updates ownership display based on current UI state\r\n        \"\"\"\r\n        def wipeModel(lst: List[QWidget]) -> None:\r\n            \"\"\"\r\n            Removes all widgets from a list and clears their parent relationships.\r\n\r\n            Iterates through a list of Qt widgets, removes their parent associations,\r\n            and then clears the list. This is typically used for cleanup before\r\n            recreating UI elements.\r\n\r\n            Args:\r\n                lst: List of QWidget objects to be removed and cleared\r\n\r\n            Side Effects:\r\n                - Removes parent relationships from all widgets in the list\r\n                - Clears the input list\r\n                - Widgets become candidates for garbage collection after parent removal\r\n\r\n            Notes:\r\n                - Important for proper Qt widget cleanup\r\n                - Prevents memory leaks by removing parent references\r\n                - Should be called before recreating UI elements\r\n                - Does not delete the widgets directly, only removes references\r\n\r\n            Example:\r\n                >>> label_list = [QLabel(\"Test1\"), QLabel(\"Test2\")]\r\n                >>> wipeModel(label_list)\r\n                >>> print(len(label_list))  # Output: 0\r\n            \"\"\"\r\n            for label in lst:\r\n                label.setParent(None)  # Remove parent relationship for proper cleanup\r\n            lst.clear()  # Remove all references from the list\r\n\r\n        # def wipeModel(lst):\r\n        #     for label in lst:\r\n        #         label.setParent(None)\r\n        #     lst.clear()\r\n        def processOwnershipData(\r\n                model: QAbstractItemModel,\r\n                variable: str,\r\n                variable_color: str,\r\n                lst: List[QLabel],\r\n                layout: QLayout\r\n        ) -> None:\r\n            \"\"\"\r\n            Creates and styles labels for ownership data visualization.\r\n\r\n            Processes each row in the model to create interactive labels with custom\r\n            styling based on ownership data. Labels are colored according to the\r\n            specified variable color and include hover effects.\r\n\r\n            Args:\r\n                model: Item model containing ownership data in first column\r\n                variable: Column name to match in ownership data\r\n                variable_color: Column name containing color values\r\n                lst: List to store created label widgets\r\n                layout: Layout widget to add labels to\r\n\r\n            Side Effects:\r\n                - Creates new QLabel widgets\r\n                - Adds widgets to provided layout\r\n                - Appends widgets to provided list\r\n                - Applies custom styling to labels\r\n\r\n            Notes:\r\n                - Assumes self.docket_ownership_data exists as a pandas DataFrame\r\n                - Labels include white text shadow for visibility\r\n                - Hover effect adds colored border\r\n                - Labels maintain 2px padding\r\n                - Uses transparent borders by default\r\n\r\n            Example:\r\n                >>> labels = []\r\n                >>> processOwnershipData(\r\n                ...     model=ownership_model,\r\n                ...     variable='Owner',\r\n                ...     variable_color='OwnerColor',\r\n                ...     lst=labels,\r\n                ...     layout=vertical_layout\r\n                ... )\r\n            \"\"\"\r\n            for row in range(model.rowCount()):\r\n                item = model.item(row, 0)  # Get item from first column\r\n                if item:\r\n                    # Create and configure label\r\n                    label_text = item.text()\r\n                    label = QLabel(label_text)\r\n                    lst.append(label)\r\n                    layout.addWidget(label)\r\n\r\n                    # Get color from ownership data\r\n                    color_used = self.docket_ownership_data[\r\n                        self.docket_ownership_data[variable] == label_text\r\n                        ][variable_color].iloc[0]\r\n\r\n                    # Apply custom styling with hover effect\r\n                    label.setStyleSheet(f\"\"\"\r\n                        QLabel {{\r\n                            color: {color_used};\r\n                            text-shadow: 0 0 20px #fff;\r\n                            padding: 2px;\r\n                            border: 1px solid transparent;\r\n                        }}\r\n                        QLabel:hover {{\r\n                            border: 1px solid {color_used};\r\n                        }}\r\n                    \"\"\")\r\n\r\n        # Clear existing labels\r\n        wipeModel(self.owner_label_list)\r\n        wipeModel(self.agency_label_list)\r\n\r\n        # Process and display new labels if ownership checkbox is checked\r\n        if self.ui.ownership_checkbox.isChecked():\r\n            active_button_id = self.ui.ownership_button_group.checkedId()\r\n\r\n            if active_button_id == -2:  # Owner view selected\r\n                processOwnershipData(\r\n                    self.owner_model,\r\n                    'owner',\r\n                    'owner_color',\r\n                    self.owner_label_list,\r\n                    self.owner_layout\r\n                )\r\n\r\n            if active_button_id == -3:  # Agency view selected\r\n                processOwnershipData(\r\n                    self.agency_model,\r\n                    'state_legend',\r\n                    'agency_color',\r\n                    self.agency_label_list,\r\n                    self.owner_layout\r\n                )\r\n\r\n    def createCheckboxes(self) -> None:\r\n        \"\"\"\r\n        Creates and configures interactive checkboxes for operator selection with associated well visualizations.\r\n\r\n        Generates checkboxes based on operator data, configures their styling, and sets up connections\r\n        for interactive well data visualization. Each checkbox controls the visibility of associated\r\n        well paths on both 2D and 3D plots.\r\n\r\n        Side Effects:\r\n            - Clears existing operator checkboxes\r\n            - Creates new checkboxes in the checkbox layout\r\n            - Initializes well path visualizations\r\n            - Updates matplotlib collections\r\n            - Modifies the state of self.operator_checkbox_list\r\n\r\n        Dependencies:\r\n            - self.operators_model: Model containing operator data\r\n            - self.df_docket: DataFrame with well/operator information\r\n            - self.dx_df: DataFrame containing directional survey data\r\n            - self.ax2d: Matplotlib axis for 2D visualization\r\n\r\n        Notes:\r\n            - Each checkbox gets a white glow effect for visibility\r\n            - Well paths are initially invisible until checkbox is checked\r\n            - Uses LineCollection for efficient path rendering\r\n            - Processes both planned and drilled wells\r\n\r\n        UI Elements:\r\n            - Creates checkboxes with operator names\r\n            - Applies custom styling with drop shadows\r\n            - Connects state change handlers\r\n\r\n        Example:\r\n            >>> self.createCheckboxes()  # Refreshes operator selection interface\r\n        \"\"\"\r\n        def refineBasedOnIfDrilledOrPlanned(df: pd.DataFrame, apis: Set[str]) -> pd.DataFrame:\r\n            \"\"\"\r\n            Filters and processes well data to select either drilled or planned wells based on priority.\r\n\r\n            For each API number, prioritizes drilled wells over planned wells. If a well has both\r\n            drilled and planned data, only the drilled data is retained. If only planned data exists,\r\n            that data is kept.\r\n\r\n            Args:\r\n                df: DataFrame containing well data with 'APINumber' and 'CitingType' columns\r\n                apis: Set of API numbers to filter the data\r\n\r\n            Returns:\r\n                pd.DataFrame: Filtered and processed DataFrame containing unique well records,\r\n                             prioritizing drilled over planned wells\r\n\r\n            Notes:\r\n                - CitingType values:\r\n                    * 'planned': Indicates planned well data\r\n                    * Not 'planned': Indicates drilled well data (includes 'asdrilled')\r\n                - Performs grouping by APINumber to handle multiple records\r\n                - Removes duplicates after processing\r\n                - Maintains original column structure\r\n\r\n            Example:\r\n                >>> apis_set = {'API123', 'API456'}\r\n                >>> result_df = refineBasedOnIfDrilledOrPlanned(well_data_df, apis_set)\r\n\r\n            Performance Considerations:\r\n                - Uses set lookup for efficient API filtering\r\n                - Applies groupby operations for organized processing\r\n                - Removes duplicates to minimize data size\r\n            \"\"\"\r\n            # Convert apis to set for O(1) lookup performance\r\n            apis_set = set(apis)\r\n\r\n            # Filter DataFrame to include only relevant APIs\r\n            df_filtered = df[df['APINumber'].isin(apis_set)]\r\n\r\n            # Create masks for well type identification\r\n            drilled_mask = df_filtered['CitingType'] != 'planned'\r\n            planned_mask = df_filtered['CitingType'] == 'planned'\r\n\r\n            def select_drilled_or_planned(group: pd.DataFrame) -> pd.DataFrame:\r\n                \"\"\"\r\n                Helper function to select appropriate well data based on CitingType.\r\n\r\n                Args:\r\n                    group: DataFrame group containing records for a single API\r\n\r\n                Returns:\r\n                    DataFrame containing either drilled or planned records\r\n                \"\"\"\r\n                group_drilled = group.loc[drilled_mask.loc[group.index]]\r\n                if not group_drilled.empty:\r\n                    return group_drilled\r\n                else:\r\n                    return group.loc[planned_mask.loc[group.index]]\r\n\r\n            # Process groups and clean up results\r\n            result = df_filtered.groupby('APINumber').apply(\r\n                lambda x: select_drilled_or_planned(x),\r\n                include_groups=False\r\n            ).reset_index()\r\n\r\n            return result.reset_index(drop=True).drop_duplicates(keep='first')\r\n        # Clear existing checkboxes\r\n        print(self.operator_checkbox_list)\r\n        for checkbox in self.operator_checkbox_list:\r\n            checkbox.setParent(None)\r\n        self.operator_checkbox_list.clear()\r\n        tester_lst = []\r\n\r\n        # Process each operator from the model\r\n        for row in range(self.operators_model.rowCount()):\r\n            item = self.operators_model.item(row, 0)\r\n            if item:\r\n                # Create and configure checkbox\r\n                checkbox_text = item.text()\r\n                checkbox = QCheckBox(checkbox_text)\r\n                self.checkbox_layout.addWidget(checkbox)\r\n\r\n                # Apply visual styling\r\n                color_used = self.getColorForIndex(row)\r\n                shadow = QGraphicsDropShadowEffect()\r\n                shadow.setColor(QColor('white'))\r\n                shadow.setBlurRadius(10)\r\n                shadow.setOffset(0, 0)\r\n                checkbox.setGraphicsEffect(shadow)\r\n                checkbox.setStyleSheet(f\"QCheckBox {{color: {color_used.name()}}}\")\r\n\r\n                # Connect state change handler\r\n                checkbox.stateChanged.connect(\r\n                    lambda state, index=row, text=checkbox_text, color=color_used:\r\n                    self.onCheckboxStateChanged(index, text, state, color)\r\n                )\r\n\r\n                # Store checkbox reference\r\n                self.operator_checkbox_list.append(checkbox)\r\n\r\n                # Process well data for visualization\r\n                operator_data = self.df_docket[self.df_docket['Operator'] == checkbox_text]\r\n                apis = operator_data['WellID'].unique()\r\n\r\n                try:\r\n                    # Filter and process directional survey data\r\n                    df_wells = self.dx_df[self.dx_df['APINumber'].isin(apis)]\r\n                    df_wells = refineBasedOnIfDrilledOrPlanned(df_wells, apis)\r\n                    df_wells = df_wells.sort_values(by=['APINumber', 'MeasuredDepth'])\r\n\r\n                    # Create well path visualizations\r\n                    xy_points_dict_drilled = {\r\n                        k: [[x, y, spx, spy] for x, y, spx, spy, in zip(\r\n                            g['X'].astype(float), g['Y'].astype(float),\r\n                            g['SPX'].astype(float), g['SPY'].astype(float)\r\n                        )] for k, g in df_wells.groupby('APINumber')\r\n                    }\r\n                    output = [[r[:2] for r in v] for k, v in xy_points_dict_drilled.items() if k in apis]\r\n                    tester_lst.append(output)\r\n\r\n                    # Configure visualization properties\r\n                    colors = [color_used.name()] * len(output)\r\n                    line_widths = [4] * len(output)\r\n                    current_segment_data = LineCollection(\r\n                        output, color=color_used.name(),\r\n                        linewidth=1, linestyle=\"-\", zorder=1\r\n                    )\r\n                    vertical_data = self.ax2d.scatter([], [], s=45, zorder=1, edgecolors='black')\r\n\r\n                    # Add to collections and configure visibility\r\n                    self.all_wells_2d_operators.append(current_segment_data)\r\n                    self.all_wells_2d_operators_vertical.append(vertical_data)\r\n                    self.ax2d.add_collection(current_segment_data)\r\n                    self.drawModelBasedOnParameters2d(\r\n                        current_segment_data, output, colors,\r\n                        line_widths, self.ax2d, vertical_data\r\n                    )\r\n                    self.all_wells_2d_operators[-1].set_visible(False)\r\n                    self.all_wells_2d_operators_vertical[-1].set_visible(False)\r\n\r\n                except KeyError:\r\n                    pass\r\n\r\n    def updateCheckboxes(self):\r\n        self.createCheckboxes()\r\n\r\n    def updateOwnershipCheckboxes(self):\r\n        self.createOwnershipLabels()\r\n\r\n    def onCheckboxStateChanged(\r\n            self,\r\n            index: int,\r\n            checkbox_text: str,\r\n            state: int,\r\n            color: QColor\r\n    ) -> None:\r\n        \"\"\"\r\n        Handles state changes for operator checkboxes and updates visualizations accordingly.\r\n\r\n        Processes checkbox state changes, emits signals for state tracking, and triggers\r\n        plot updates to reflect the new selection state. Used for dynamically updating\r\n        well path visibility in both 2D and 3D views.\r\n\r\n        Args:\r\n            index: Zero-based index of the checkbox in the operator list\r\n            checkbox_text: Display text/operator name for the checkbox\r\n            state: Qt checkbox state value (Qt.Checked or Qt.Unchecked)\r\n            color: Color associated with the operator/checkbox\r\n\r\n        Side Effects:\r\n            - Emits checkbox_state_changed signal\r\n            - Triggers plot update\r\n            - Updates well path visibility\r\n\r\n        Signals Emitted:\r\n            checkbox_state_changed(int, str, bool, QColor):\r\n                - index: Checkbox index\r\n                - checkbox_text: Operator name\r\n                - is_checked: Boolean state\r\n                - color: Operator color\r\n\r\n        Notes:\r\n            - Part of the dynamic update system for well visualization\r\n            - Avoids full plot redraw for performance\r\n            - Integrates with operator-specific well path collections\r\n\r\n        Example:\r\n            >>> # Triggered automatically when checkbox state changes\r\n            >>> self.checkbox.stateChanged.connect(\r\n            ...     lambda state: self.onCheckboxStateChanged(0, \"OperatorA\", state, QColor(\"red\"))\r\n            ... )\r\n        \"\"\"\r\n        # Emit signal with processed state\r\n        self.checkbox_state_changed.emit(index, checkbox_text, state == Qt.Checked, color)\r\n\r\n        # Update visualization\r\n        self.updatePlot()\r\n\r\n    def updatePlot(self) -> None:\r\n        \"\"\"\r\n        Updates well path visibility in the 2D plot based on operator checkbox states.\r\n\r\n        Efficiently updates the visualization by only modifying visibility states of\r\n        existing plot elements rather than redrawing the entire plot. Uses matplotlib's\r\n        blitting functionality for optimized rendering performance.\r\n\r\n        Side Effects:\r\n            - Updates visibility of well path line collections\r\n            - Updates visibility of vertical well markers\r\n            - Triggers canvas redraw using blitting optimization\r\n\r\n        Notes:\r\n            - Operates on self.all_wells_2d_operators collections\r\n            - Maintains synchronization between checkboxes and visualizations\r\n            - Uses blit() for efficient updates without full redraw\r\n            - Handles both horizontal and vertical well representations\r\n\r\n        Performance Considerations:\r\n            - Avoids full plot redraw for better performance\r\n            - Uses matplotlib's blitting for efficient updates\r\n            - Only updates changed elements\r\n\r\n        Dependencies:\r\n            - self.operator_checkbox_list: List of operator checkboxes\r\n            - self.all_wells_2d_operators: Line collections for well paths\r\n            - self.all_wells_2d_operators_vertical: Scatter collections for vertical wells\r\n            - self.canvas2d: Matplotlib canvas for 2D visualization\r\n            - self.ax2d: Matplotlib axis for 2D plot\r\n\r\n        Example:\r\n            >>> self.updatePlot()  # Updates visibility based on current checkbox states\r\n        \"\"\"\r\n        # Update visibility based on checkbox states\r\n        for index, checkbox in enumerate(self.operator_checkbox_list):\r\n            is_visible = checkbox.isChecked()\r\n            self.all_wells_2d_operators[index].set_visible(is_visible)\r\n            self.all_wells_2d_operators_vertical[index].set_visible(is_visible)\r\n\r\n        # Efficiently update display using blitting\r\n        self.canvas2d.blit(self.ax2d.bbox)\r\n        self.canvas2d.draw()\r\n\r\n    def returnWellsWithParameters(self) -> DataFrame:\r\n        \"\"\"\r\n        Processes and returns well data with color-coded parameters for visualization.\r\n\r\n        Creates a filtered and enriched DataFrame containing well information with\r\n        standardized color mappings for well types and operational status. Merges\r\n        directional survey data with docket information for comprehensive visualization.\r\n\r\n        Color Schemes:\r\n            Well Types:\r\n                - Oil Wells: Red (#c34c00)\r\n                - Gas Wells: Orange (#f1aa00)\r\n                - Water Disposal Wells: Blue (#0032b0)\r\n                - Injection Wells: Cyan (#93ebff)\r\n                - Dry Holes: Dark Gray (#4f494b)\r\n                - Unknown/Test Wells: Magenta (#985bee)\r\n\r\n            Well Status:\r\n                - Producing: Green (#a2e361)\r\n                - Plugged & Abandoned: Purple (#4c2d77)\r\n                - Shut In: Tan (#D2B48C)\r\n                - Drilling: Navy (#001958)\r\n                - Other: Teal (#4a7583)\r\n\r\n        Returns:\r\n            DataFrame with columns:\r\n                - APINumber: Well identifier\r\n                - X, Y: Well coordinates\r\n                - Targeted Elevation\r\n                - CitingType\r\n                - SPX, SPY: Surface point coordinates\r\n                - CurrentWellType\r\n                - CurrentWellStatus\r\n                - WellAge\r\n                - MeasuredDepth\r\n                - ConcCode_y\r\n                - WellTypeColor: Hex color based on well type\r\n                - WellStatusColor: Hex color based on well status\r\n\r\n        Side Effects:\r\n            None - Pure data processing function\r\n\r\n        Notes:\r\n            - Merges directional survey data with docket information\r\n            - Removes duplicate entries\r\n            - Sorts by APINumber and MeasuredDepth\r\n            - Maps colors based on standardized industry visualization schemes\r\n            - Handles unknown status values with default teal color\r\n        \"\"\"\r\n        # Define color mappings for well types\r\n        colors_type = {\r\n            'Oil Well': '#c34c00',  # Red\r\n            'Gas Well': '#f1aa00',  # Orange\r\n            'Water Disposal Well': '#0032b0',  # Blue\r\n            'Oil Well/Water Disposal Well': '#0032b0',  # Blue\r\n            'Water Injection Well': '#93ebff',  # Cyan\r\n            'Gas Injection Well': '#93ebff',  # Cyan\r\n            'Dry Hole': '#4f494b',  # Dark Gray\r\n            'Unknown': '#985bee',  # Magenta\r\n            'Test Well': '#985bee',  # Magenta\r\n            'Water Source Well': '#985bee'  # Magenta\r\n        }\r\n\r\n        # Define color mappings for well status\r\n        colors_status = {\r\n            'Producing': '#a2e361',  # Green\r\n            'Plugged & Abandoned': '#4c2d77',  # Purple\r\n            'Shut In': '#D2B48C',  # tan\r\n            'Drilling': '#001958',  # Navy\r\n            'Other': '#4a7583'  # Teal\r\n        }\r\n\r\n        # Define required columns for final dataset\r\n        necessary_columns = [\r\n            'APINumber', 'X', 'Y', 'Targeted Elevation', 'CitingType',\r\n            'SPX', 'SPY', 'CurrentWellType', 'CurrentWellStatus',\r\n            'WellAge', 'MeasuredDepth', 'ConcCode_y'\r\n        ]\r\n\r\n        # Process and filter data\r\n        apis = self.df_docket['WellID'].unique()\r\n        operators = self.df_docket['Operator'].unique()\r\n        dx_filtered = self.dx_df[self.dx_df['APINumber'].isin(apis)]\r\n        docket_filtered = self.df_docket[self.df_docket['WellID'].isin(apis)]\r\n\r\n        # Merge and clean data\r\n        merged_df = pd.merge(dx_filtered, docket_filtered,\r\n                             left_on='APINumber', right_on='WellID')\r\n        merged_df = merged_df.drop_duplicates(keep='first')\r\n        merged_df = merged_df.sort_values(by=['APINumber', 'MeasuredDepth'])\r\n\r\n        # Create final dataset with necessary columns\r\n        final_df = merged_df[necessary_columns]\r\n        final_df.reset_index(drop=True, inplace=True)\r\n\r\n        # Add color coding\r\n        final_df['WellTypeColor'] = final_df['CurrentWellType'].map(colors_type)\r\n        final_df['WellStatusColor'] = final_df['CurrentWellStatus'].apply(\r\n            lambda x: colors_status.get(x, '#4a7583')\r\n        )\r\n\r\n        return final_df.sort_values(by=['APINumber', 'MeasuredDepth'])\r\n\r\n    def draw2dModelSections(self) -> Tuple[List[List[List[float]]], List[str]]:\r\n        \"\"\"\r\n        Processes and transforms plat (section) data for 2D visualization of well sections.\r\n\r\n        Extracts section boundary coordinates and labels from plat data, grouping by\r\n        concession codes and transforming labels into a readable format. Used to create\r\n        the base layout for the 2D well visualization model.\r\n\r\n        Returns:\r\n            tuple containing:\r\n                - plat_data: List of section boundary coordinates grouped by section\r\n                  Each section is a list of [easting, northing] coordinate pairs\r\n                - plat_labels: List of transformed section labels in readable format\r\n                  (e.g., '1 23S 2W B' instead of '01235S02WB')\r\n\r\n        Side Effects:\r\n            - Updates self.all_wells_plat_labels_for_editing with raw section labels\r\n\r\n        Notes:\r\n            - Processes data from self.df_plat DataFrame\r\n            - Groups coordinates by concession code\r\n            - Transforms section labels using transformString helper function\r\n            - Coordinate pairs are in [Easting, Northing] format\r\n\r\n        Example Output:\r\n            (\r\n                [[[100.0, 200.0], [150.0, 200.0], ...]], # Coordinates for sections\r\n                ['1 23S 2W B', '2 23S 2W B', ...]        # Transformed section labels\r\n            )\r\n        \"\"\"\r\n        def transformString(s: str) -> str:\r\n            \"\"\"\r\n            Transforms a well location string from compact format to readable format.\r\n\r\n            Converts strings like '01235S02WB' to formatted strings like '1 23S 2W B'\r\n            by removing leading zeros and adding spaces between components. Used for\r\n            standardizing location representations in well data visualization.\r\n\r\n            Format components:\r\n                - First 2 digits: Section number\r\n                - Next 2 digits + 'S': Township number with direction\r\n                - Next 2 digits + 'W': Range number with direction\r\n                - Last character: Baseline identifier\r\n\r\n            Args:\r\n                s: Input string in format 'SSTTDRRDB' where:\r\n                   SS = Section (2 digits)\r\n                   TT = Township (2 digits)\r\n                   D = Direction (S)\r\n                   RR = Range (2 digits)\r\n                   D = Direction (W)\r\n                   B = Baseline identifier\r\n\r\n            Returns:\r\n                Formatted string with components separated by spaces and leading zeros removed.\r\n                Returns original string if it doesn't match the expected pattern.\r\n\r\n            Examples:\r\n                >>> transformString('01235S02WB')\r\n                '1 23S 2W B'\r\n                >>> transformString('12345S67WN')\r\n                '12 34S 67W N'\r\n                >>> transformString('invalid')\r\n                'invalid'\r\n            \"\"\"\r\n\r\n            # Parse string using regex pattern for well location format\r\n            parts = re.match(r'(\\d{2})(\\d{2}S)(\\d{2}W)([A-Z])', s)\r\n            if not parts:\r\n                return s  # Return unchanged if pattern doesn't match\r\n\r\n            # Extract and format components, removing leading zeros\r\n            part1 = str(int(parts.group(1)))  # Section number\r\n            part2 = str(int(parts.group(2)[:-1])) + parts.group(2)[-1]  # Township\r\n            part3 = str(int(parts.group(3)[:-1])) + parts.group(3)[-1]  # Range\r\n            part4 = parts.group(4)  # Baseline\r\n\r\n            # Return formatted string with proper spacing\r\n            return f\"{part1} {part2} {part3} {part4}\"\r\n\r\n        # generate a list of data of the plat, with its xy and ID values\r\n        # Extract coordinate and concession data\r\n        plat_data = self.df_plat[['Easting', 'Northing', 'Conc']].values.tolist()\r\n\r\n        # Group coordinates by concession code\r\n        plat_data = [list(group) for _, group in itertools.groupby(plat_data, lambda x: x[2])]\r\n\r\n        # Extract raw section labels\r\n        plat_labels = [i[0][2] for i in plat_data]\r\n\r\n        # Store raw labels for potential future use\r\n        self.all_wells_plat_labels_for_editing = plat_labels\r\n\r\n        # Transform labels to readable format\r\n        plat_labels = [transformString(i) for i in plat_labels]\r\n\r\n        # Extract only coordinate pairs from grouped data\r\n        plat_data = [[j[:2] for j in i] for i in plat_data]\r\n\r\n        return plat_data, plat_labels\r\n\r\n\r\n\r\n    def calculateCentroidNP(\r\n            self,\r\n            points: List[List[Union[float, int]]]\r\n    ) -> Tuple[Tuple[float, ...], Tuple[float, ...]]:\r\n        \"\"\"\r\n        Calculates the centroid and standard deviation of a set of multi-dimensional points.\r\n\r\n        Processes a nested list of points to find their geometric center (centroid) and\r\n        the spread of points (standard deviation) along each dimension. Commonly used\r\n        for determining visualization bounds and central focus points for well plots.\r\n\r\n        Args:\r\n            points: Nested list of coordinate points where each point is a list of\r\n                   coordinates [x, y] or [x, y, z]. Points can be grouped in sublists.\r\n\r\n        Returns:\r\n            tuple containing:\r\n                - centroid: Tuple of coordinates representing the geometric center\r\n                - std_vals: Tuple of standard deviations for each dimension\r\n\r\n        Notes:\r\n            - Flattens nested point structure before calculation\r\n            - Uses numpy for efficient array operations\r\n            - Handles both 2D and 3D point sets\r\n            - Used for camera/view positioning in visualization\r\n\r\n        Example:\r\n            >>> points = [[[1.0, 2.0], [3.0, 4.0]], [[5.0, 6.0]]]\r\n            >>> centroid, std_vals = calculateCentroidNP(points)\r\n            >>> print(centroid)  # (3.0, 4.0)\r\n            >>> print(std_vals)  # (1.63, 1.63)  # approximate values\r\n        \"\"\"\r\n        # Flatten nested point structure and convert to numpy array\r\n        flat_array = array([point for sublist in points for point in sublist])\r\n\r\n        # Calculate standard deviation along each dimension\r\n        std_vals = std(flat_array, axis=0)\r\n\r\n        # Calculate mean position (centroid)\r\n        centroid = flat_array.mean(axis=0)\r\n\r\n        return tuple(centroid), tuple(std_vals)\r\n\r\n    def ownershipSelection(self) -> None:\r\n        \"\"\"\r\n        Controls visibility of ownership section layers based on UI checkbox and radio button states.\r\n\r\n        Manages the display of ownership visualization layers on the 2D map, toggling between\r\n        agency and owner views based on user selection. Uses efficient canvas blitting for\r\n        performance optimization.\r\n\r\n        Side Effects:\r\n            - Updates visibility of ownership section layers\r\n            - Updates ownership labels when layers are visible\r\n            - Triggers canvas redraw\r\n\r\n        Notes:\r\n            - Radio button IDs:\r\n                -2: Owner view\r\n                -3: Agency view\r\n            - Uses matplotlib's blitting for efficient updates\r\n            - Ownership layers are mutually exclusive\r\n\r\n        Dependencies:\r\n            - self.ui.ownership_checkbox: Main ownership toggle\r\n            - self.ui.ownership_button_group: Radio button group for view selection\r\n            - self.ownership_sections_agency: Agency ownership layer\r\n            - self.ownership_sections_owner: Owner ownership layer\r\n            - self.canvas2d: Matplotlib canvas\r\n            - self.createOwnershipLabels(): Helper method for label generation\r\n\r\n        Example:\r\n            >>> self.ownershipSelection()  # Updates visibility based on current UI state\r\n        \"\"\"\r\n        if self.ui.ownership_checkbox.isChecked():\r\n            # Get active radio button selection\r\n            active_button_id = self.ui.ownership_button_group.checkedId()\r\n\r\n            # Toggle visibility based on selection\r\n            if active_button_id == -2:  # Owner view\r\n                self.ownership_sections_agency.set_visible(False)\r\n                self.ownership_sections_owner.set_visible(True)\r\n            if active_button_id == -3:  # Agency view\r\n                self.ownership_sections_owner.set_visible(False)\r\n                self.ownership_sections_agency.set_visible(True)\r\n\r\n            # Update ownership labels\r\n            self.createOwnershipLabels()\r\n        else:\r\n            # Hide all ownership layers if checkbox is unchecked\r\n            self.ownership_sections_agency.set_visible(False)\r\n            self.ownership_sections_owner.set_visible(False)\r\n\r\n        # Efficiently update display using blitting\r\n        self.canvas2d.blit(self.ax2d.bbox)\r\n        self.canvas2d.draw()\r\n\r\n    def _updateOilPlots(self, current_data_row: pd.DataFrame) -> None:\r\n        \"\"\"\r\n        Updates visualization plots for oil production data.\r\n\r\n        Args:\r\n            current_data_row: DataFrame containing filtered oil production data\r\n                Required columns:\r\n                - Date: datetime\r\n                - Potential Oil Profit: float\r\n                - Potential Cumulative Oil Profit: float\r\n                - Oil Volume (bbl): float\r\n                - Cumulative Potential Oil Production (bbl): float\r\n\r\n        Side Effects:\r\n            - Updates titles, data, and labels for oil production plots\r\n            - Modifies self.ax_prod_1 and self.ax_prod_2 plot elements\r\n            - Updates line plots for monthly and cumulative values\r\n        \"\"\"\r\n        # Set titles for both axes\r\n        self.ax_prod_1.set_title('Potential Profit')\r\n        self.ax_prod_2.set_title('Produced Oil (bbl)')\r\n\r\n        # Update profit plots\r\n        self.profit_line.set_data(current_data_row['Date'], current_data_row['Potential Oil Profit'])\r\n        self.profit_line_cum.set_data(current_data_row['Date'], current_data_row['Potential Cumulative Oil Profit'])\r\n\r\n        # Update production volume plots\r\n        self.prod_line.set_data(current_data_row['Date'], current_data_row['Oil Volume (bbl)'])\r\n        self.prod_line_cum.set_data(current_data_row['Date'],\r\n                                    current_data_row['Cumulative Potential Oil Production (bbl)'])\r\n\r\n        # Update plot labels\r\n        self.profit_line.set_label('Monthly Oil Profit')\r\n        self.profit_line_cum.set_label('Cumulative Oil Profit')\r\n        self.prod_line.set_label('Monthly Oil Production')\r\n        self.prod_line_cum.set_label('Cumulative Oil Production')\r\n\r\n    def _updateGasPlots(self, current_data_row: pd.DataFrame) -> None:\r\n        \"\"\"\r\n        Updates visualization plots for gas production data.\r\n\r\n        Args:\r\n            current_data_row: DataFrame containing filtered gas production data\r\n                Required columns:\r\n                - Date: datetime\r\n                - Potential Gas Profit: float\r\n                - Potential Cumulative Gas Profit: float\r\n                - Gas Volume (mcf): float\r\n                - Cumulative Potential Gas Production (mcf): float\r\n\r\n        Side Effects:\r\n            - Updates titles, data, and labels for gas production plots\r\n            - Modifies self.ax_prod_1 and self.ax_prod_2 plot elements\r\n            - Updates line plots for monthly and cumulative values\r\n        \"\"\"\r\n        # Set titles for both axes\r\n        self.ax_prod_1.set_title('Potential Profit')\r\n        self.ax_prod_2.set_title('Produced Gas Volume (mcf)')\r\n\r\n        # Update profit plots\r\n        self.profit_line.set_data(current_data_row['Date'], current_data_row['Potential Gas Profit'])\r\n        self.profit_line_cum.set_data(current_data_row['Date'], current_data_row['Potential Cumulative Gas Profit'])\r\n\r\n        # Update production volume plots\r\n        self.prod_line.set_data(current_data_row['Date'], current_data_row['Gas Volume (mcf)'])\r\n        self.prod_line_cum.set_data(current_data_row['Date'],\r\n                                    current_data_row['Cumulative Potential Gas Production (mcf)'])\r\n\r\n        # Update plot labels\r\n        self.profit_line.set_label('Monthly Gas Profit')\r\n        self.profit_line_cum.set_label('Cumulative Gas Profit')\r\n        self.prod_line.set_label('Monthly Gas Production')\r\n        self.prod_line_cum.set_label('Cumulative Gas Production')\r\n\r\n    def drawProductionGraphic(self) -> None:\r\n        \"\"\"\r\n        Generates and updates production visualization graphs for oil and gas wells.\r\n\r\n        Creates dual-panel visualization showing profit potential and production volumes\r\n        for either oil or gas wells. Handles data processing, cumulative calculations,\r\n        and dynamic graph updates based on user selection.\r\n\r\n        Side Effects:\r\n            - Updates self.ax_prod_1 with profit data\r\n            - Updates self.ax_prod_2 with production volume data\r\n            - Refreshes both canvases with new data\r\n\r\n        Notes:\r\n            - Automatically formats large numbers in millions (M)\r\n            - Handles date formatting for x-axis\r\n            - Adjusts tick density based on data volume\r\n            - Supports both oil (bbl) and gas (mcf) visualization\r\n            - Uses matplotlib's blitting for efficient updates\r\n\r\n        Dependencies:\r\n            - self.df_prod: DataFrame containing production data\r\n            - self.targeted_well: Currently selected well ID\r\n            - self.current_prod: Current production type ('oil' or 'gas')\r\n            - self.ui.prod_button_group: Button group for production type selection\r\n                -2: Gas selection\r\n                -3: Oil selection\r\n        \"\"\"\r\n\r\n        def millions_formatter(x: float, pos: Optional[int]) -> str:\r\n            \"\"\"\r\n            Formats axis labels to display millions with M suffix.\r\n\r\n            Args:\r\n                x: Value to format\r\n                pos: Position on axis (unused but required by FuncFormatter)\r\n\r\n            Returns:\r\n                Formatted string with M suffix for millions, rounded to 1 decimal\r\n            \"\"\"\r\n            if abs(x) >= 1e6:\r\n                return f\"{x / 1e6:.1f}M\"\r\n            return f\"{x:.0f}\"\r\n\r\n\r\n        # Filter and prepare production data\r\n        current_data_row = self.df_prod[self.df_prod['WellID'] == self.targeted_well]\r\n        current_data_row = current_data_row.sort_values(by='Date')\r\n\r\n        # Remove cumulative columns for recalculation\r\n        drop_columns = ['Potential Cumulative Gas Profit', 'Cumulative Potential Gas Production (mcf)',\r\n                        'Cumulative Potential Oil Production (bbl)', 'Potential Cumulative Oil Profit']\r\n        current_data_row = current_data_row.drop(drop_columns, axis=1)\r\n\r\n        # Clean and process data\r\n        current_data_row.drop_duplicates(keep='first', inplace=True)\r\n        current_data_row = current_data_row.sort_values(by='Date').reset_index(drop=True)\r\n        current_data_row['Date'] = current_data_row['Date'].str.slice(0, 7).str.pad(7, side='right')\r\n\r\n        # Calculate cumulative values\r\n        current_data_row['Potential Cumulative Gas Profit'] = current_data_row['Potential Gas Profit'].cumsum()\r\n        current_data_row['Potential Cumulative Oil Profit'] = current_data_row['Potential Oil Profit'].cumsum()\r\n        current_data_row['Cumulative Potential Oil Production (bbl)'] = current_data_row['Oil Volume (bbl)'].cumsum()\r\n        current_data_row['Cumulative Potential Gas Production (mcf)'] = current_data_row['Gas Volume (mcf)'].cumsum()\r\n\r\n        # Convert dates to datetime\r\n        current_data_row['Date'] = pd.to_datetime(current_data_row['Date'])\r\n\r\n        # Determine production type and adjust tick density\r\n        active_button_id = self.ui.prod_button_group.checkedId()\r\n        if len(current_data_row) > 10:\r\n            for ax in [self.ax_prod_1, self.ax_prod_2]:\r\n                ax.xaxis.set_major_locator(plt.MaxNLocator(nbins=10))\r\n            self.current_prod = 'gas' if active_button_id == -2 else 'oil'\r\n\r\n        # Update plots based on production type\r\n        if self.current_prod == 'oil':\r\n            self._updateOilPlots(current_data_row)\r\n        else:\r\n            self._updateGasPlots(current_data_row)\r\n\r\n        # Configure axes formatting\r\n        for ax in [self.ax_prod_1, self.ax_prod_2]:\r\n            ax.xaxis.set_major_locator(mdates.YearLocator())\r\n            ax.xaxis.set_minor_locator(mdates.MonthLocator())\r\n            ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))\r\n            ax.relim()\r\n            ax.autoscale_view()\r\n            ax.legend(loc='upper left', bbox_to_anchor=(-0.15, -0.25))\r\n\r\n        # Apply custom formatting\r\n        formatter = ScalarFormatter(useOffset=False)\r\n        formatter.set_scientific(False)\r\n        self.ax_prod_1.yaxis.set_major_formatter(FuncFormatter(millions_formatter))\r\n\r\n        # Update display\r\n        for canvas in [self.canvas_prod_1, self.canvas_prod_2]:\r\n            canvas.blit(canvas.figure.bbox)\r\n            canvas.draw()\r\n\r\n    def loadData(self) -> None:\r\n        \"\"\"\r\n        Initializes and loads all necessary data from the database for well visualization.\r\n\r\n        Loads and processes multiple datasets including field information, ownership data,\r\n        directional surveys, well data, and production history. Establishes core data\r\n        structures needed for visualization and analysis.\r\n\r\n        Side Effects:\r\n            - Populates multiple DataFrame attributes:\r\n                self.df_field: Field information\r\n                self.df_owner: Ownership records\r\n                self.df_prod: Production data\r\n                self.dx_data: Directional survey data\r\n            - Sets unique identifiers:\r\n                self.used_dockets: Unique board docket numbers\r\n                self.used_years: Unique years in dataset\r\n\r\n        Dependencies:\r\n            - Requires active database connection in self.conn_db\r\n            - Helper methods:\r\n                - loadDfFields(): Processes field data\r\n                - loadBoardData(): Loads board meeting data\r\n                - loadPlatData(): Processes plat information\r\n                - loadDirectionalData(): Loads directional survey data\r\n                - loadWellData(): Processes well-specific information\r\n\r\n        Notes:\r\n            - Database must contain tables: Field, Owner, Production\r\n            - Removes duplicate production records\r\n            - Preserves original data structure for visualization\r\n            - Critical for initializing visualization components\r\n        \"\"\"\r\n        # Load field and ownership base data\r\n        self.df_field = read_sql('select * from Field', self.conn_db)\r\n        self.df_owner = read_sql('select * from Owner', self.conn_db)\r\n\r\n        # Process core datasets through helper functions\r\n        self.loadDfFields()  # Process field information\r\n        self.loadBoardData()  # Load board meeting records\r\n        self.loadPlatData()  # Process plat mapping data\r\n\r\n        # Load and process directional survey data\r\n        dx_data_unique = self.loadDirectionalData()\r\n        self.loadWellData(dx_data_unique)\r\n\r\n        # Extract unique identifiers for filtering\r\n        self.used_dockets = self.dx_data['Board_Docket'].unique()\r\n        self.used_years = self.dx_data['Board_Year'].unique()\r\n\r\n        # Load and clean production data\r\n        self.df_prod = read_sql('select * from Production', self.conn_db)\r\n        self.df_prod.drop_duplicates(keep='first', inplace=True)\r\n\r\n    def loadPlatData(self) -> None:\r\n        \"\"\"\r\n        Loads and processes plat (land survey) data from database, converting geographic\r\n        coordinates to UTM projection and creating geometry objects.\r\n\r\n        Loads plat and adjacent plat data from database tables, removes duplicates and\r\n        invalid coordinates, then transforms coordinates from Lat/Lon to UTM projection\r\n        for spatial analysis.\r\n\r\n        Side Effects:\r\n            - Creates/Updates following DataFrame attributes:\r\n                self.df_plat: Primary plat data with columns:\r\n                    - Lat: float - Latitude coordinates\r\n                    - Lon: float - Longitude coordinates\r\n                    - Easting: float - UTM easting coordinate\r\n                    - Northing: float - UTM northing coordinate\r\n                    - geometry: Point - Shapely Point geometry\r\n                self.df_adjacent_plats: Adjacent plat reference data\r\n\r\n        Notes:\r\n            - Requires active database connection in self.conn_db\r\n            - Removes rows with null Lat/Lon values\r\n            - Converts geographic coordinates to UTM projection\r\n            - Creates Shapely Point geometries for spatial operations\r\n            - Database must contain tables: PlatData, Adjacent\r\n\r\n        Dependencies:\r\n            - utm package for coordinate transformation\r\n            - shapely.geometry for spatial objects\r\n        \"\"\"\r\n        # Load raw plat data from database\r\n        self.df_plat = read_sql('select * from PlatData', self.conn_db)\r\n        self.df_adjacent_plats = read_sql('select * from Adjacent', self.conn_db)\r\n\r\n        # Clean plat data by removing duplicates and invalid coordinates\r\n        self.df_plat.drop_duplicates(keep='first', inplace=True)\r\n        self.df_plat = self.df_plat.dropna(subset=['Lat', 'Lon'])\r\n\r\n        # Convert geographic coordinates (Lat/Lon) to UTM projection (Easting/Northing)\r\n        self.df_plat['Easting'], self.df_plat['Northing'] = zip(\r\n            *self.df_plat.apply(\r\n                lambda row: utm.from_latlon(row['Lat'], row['Lon'])[:2],\r\n                axis=1\r\n            )\r\n        )\r\n\r\n        # Create Shapely Point geometries for spatial analysis\r\n        self.df_plat['geometry'] = self.df_plat.apply(\r\n            lambda row: Point(row['Easting'], row['Northing']),\r\n            axis=1\r\n        )\r\n\r\n    def loadDfFields(self) -> None:\r\n        \"\"\"\r\n        Processes field data to create geometric representations and identify adjacent fields.\r\n\r\n        Converts field coordinates to geometric objects, creates field polygons, and identifies\r\n        neighboring fields using spatial analysis. Uses a buffer zone to determine field\r\n        adjacency relationships.\r\n\r\n        Side Effects:\r\n            - Creates/Updates following attributes:\r\n                self.df_field: Enhanced with geometry column\r\n                self.df_adjacent_fields: DataFrame containing adjacent field relationships\r\n                    Columns:\r\n                    - Field_Name: str - Name of the reference field\r\n                    - adjacent_Field_Name: str - Name of the neighboring field\r\n\r\n        Notes:\r\n            - Requires self.df_field to contain:\r\n                - Field_Name: str\r\n                - Easting: float - UTM easting coordinate\r\n                - Northing: float - UTM northing coordinate\r\n            - Uses 10-unit buffer for intersection detection\r\n            - Creates point geometries for individual locations\r\n            - Generates polygons for field boundaries\r\n\r\n        Implementation Details:\r\n            - Creates point geometries from coordinates\r\n            - Groups coordinates by field to create field polygons\r\n            - Uses spatial buffer of 10 units to detect field intersections\r\n            - Identifies and stores all adjacent field relationships\r\n        \"\"\"\r\n        # Initialize storage for adjacent field relationships\r\n        adjacent_fields: List[Dict[str, str]] = []\r\n\r\n        # Create point geometries for field locations\r\n        self.df_field['geometry'] = self.df_field.apply(\r\n            lambda row: Point(row['Easting'], row['Northing']),\r\n            axis=1\r\n        )\r\n\r\n        # Extract relevant fields for polygon creation\r\n        used_fields = self.df_field[['Field_Name', 'Easting', 'Northing']]\r\n\r\n        # Generate field polygons from coordinate groups\r\n        polygons = used_fields.groupby('Field_Name').apply(\r\n            lambda x: Polygon(zip(x['Easting'], x['Northing'])),\r\n            include_groups=False\r\n        ).reset_index()\r\n        polygons.columns = ['Field_Name', 'geometry']\r\n\r\n        # Create GeoDataFrame with buffer zones\r\n        gdf = gpd.GeoDataFrame(polygons, geometry='geometry')\r\n        gdf['buffer'] = gdf['geometry'].buffer(10)\r\n\r\n        # Identify adjacent fields using spatial analysis\r\n        for _, row in gdf.iterrows():\r\n            # Find neighboring fields using buffer intersection\r\n            neighbors = gdf[gdf['buffer'].intersects(row['geometry'])]['Field_Name'].tolist()\r\n            neighbors.remove(row['Field_Name'])  # Remove self-reference\r\n\r\n            # Create adjacency relationships\r\n            adjacent_fields.extend([\r\n                {'Field_Name': row['Field_Name'], 'adjacent_Field_Name': neighbor}\r\n                for neighbor in neighbors\r\n            ])\r\n\r\n        # Convert adjacency list to DataFrame\r\n        self.df_adjacent_fields = pd.DataFrame(adjacent_fields)\r\n        print(self.df_adjacent_fields)\r\n\r\n    def loadBoardData(self) -> None:\r\n        \"\"\"\r\n        Loads board data and links from database, adding concatenated location codes.\r\n\r\n        Retrieves board meeting records and associated links from database, then adds\r\n        concatenated location codes by combining section, township, range, and meridian\r\n        information for easier reference and filtering.\r\n\r\n        Side Effects:\r\n            - Creates/Updates following DataFrame attributes:\r\n                self.df_BoardData: Primary board data with columns:\r\n                    - Sec: int - Section number\r\n                    - Township: int - Township number\r\n                    - TownshipDir: str - Township direction (N/S)\r\n                    - Range: int - Range number\r\n                    - RangeDir: str - Range direction (E/W)\r\n                    - PM: str - Principal Meridian\r\n                    - Conc: str - Concatenated location code\r\n                self.df_BoardDataLinks: Links related to board data\r\n\r\n        Notes:\r\n            - Requires active database connection in self.conn_db\r\n            - Uses ModuleAgnostic.reTranslateData for location code generation\r\n            - Database must contain tables: BoardData, BoardDataLinks\r\n\r\n        Dependencies:\r\n            - ModuleAgnostic module for location code translation\r\n            - Active database connection with required tables\r\n        \"\"\"\r\n        # Load board meeting records and associated links\r\n        self.df_BoardData = read_sql('select * from BoardData', self.conn_db)\r\n        self.df_BoardDataLinks = read_sql('select * from BoardDataLinks', self.conn_db)\r\n\r\n        # Generate concatenated location codes using ModuleAgnostic translator\r\n        self.df_BoardData['Conc'] = self.df_BoardData[[\r\n            'Sec', 'Township', 'TownshipDir',\r\n            'Range', 'RangeDir', 'PM'\r\n        ]].apply(lambda x: self.reTranslateData(x), axis=1)\r\n\r\n    def loadDirectionalData(self) -> DataFrame:\r\n        \"\"\"\r\n        Loads and processes directional well data from database, performing data cleanup\r\n        and standardization.\r\n\r\n        Loads well information, removes plugged wells, standardizes field names, and calculates\r\n        well ages. Processes dates and creates display names for wells.\r\n\r\n        Args:\r\n            None\r\n\r\n        Returns:\r\n            DataFrame: Processed well data with unique WellIDs containing columns:\r\n                - WellID: str - Unique identifier for well\r\n                - WellName: str - Name of the well\r\n                - DisplayName: str - Combined WellID and WellName for UI display\r\n                - Operator: str - Well operator name\r\n                - WorkType: str - Type of well work being performed\r\n                - DrySpud: str - Formatted spud date (YYYY-MM-DD)\r\n                - WellAge: int - Age of well in months\r\n                - CurrentWellStatus: str - Current status of well\r\n                - FieldName: str - Standardized field name\r\n                - Board_Year: int - Year of board approval\r\n                - Docket_Month: str - Month of board approval\r\n\r\n        Side Effects:\r\n            - Creates/Updates self.dx_data with processed well information\r\n\r\n        Notes:\r\n            - Filters out plugged wells (WorkType = 'PLUG')\r\n            - Removes duplicate entries\r\n            - Standardizes field names using translation dictionary\r\n            - Calculates well age in months from spud date\r\n            - Sets well age to 0 for approved permits without spud dates\r\n        \"\"\"\r\n        # Define field name translations for standardization\r\n        translated_fields: Dict[str, str] = {'AAGARD RANCH': 'AAGARD RANCH FIELD', 'ANDERSON JUNCTION': 'ANDERSON JUNCTION FIELD', 'ANSCHUTZ RANCH WEBER': 'ANSCHUTZ RANCH (WEBER) FIELD', 'BAR X': 'BAR X FIELD', 'BIG FLAT': 'BIG FLAT FIELD', 'BIG FLAT WEST': 'BIG FLAT WEST FIELD', 'BIG INDIAN SOUTH': 'BIG INDIAN (SOUTH) FIELD', 'BONANZA': 'BONANZA FIELD', 'BOUNDARY BUTTE': 'BOUNDARY BUTTE FIELD', 'BRADFORD CYN': 'BRADFORD CANYON FIELD', 'BUZZARD BENCH': 'BUZZARD BENCH FIELD', 'CABALLO': 'CABALLO FIELD',\r\n                             'CACTUS PARK': 'CACTUS PARK FIELD', 'CHOKECHERRY CYN': 'CHOKECHERRY CANYON FIELD', 'CLAY HILL': 'CLAY HILL FIELD', 'CLEAR CREEK': 'CLEAR CREEK FIELD', 'DARK CANYON': 'DARK CANYON FIELD', 'DESERT CREEK': 'DESERT CREEK FIELD', 'ELKHORN': 'ELKHORN FIELD', 'FARNHAM DOME': 'FARNHAM DOME FIELD', 'FENCE CANYON': 'FENCE CANYON FIELD', 'GREATER CISCO': 'GREATER CISCO FIELD', 'HALFWAY HOLLOW': 'HALFWAY HOLLOW FIELD', 'HATCH POINT': 'HATCH POINT FIELD', 'HOGAN': 'HOGAN FIELD',\r\n                             'HOGBACK RIDGE': 'HOGBACK RIDGE FIELD', 'HORSEHEAD POINT': 'HORSEHEAD POINT FIELD', 'HORSESHOE BEND': 'HORSESHOE BEND FIELD', 'ICE CANYON (DK-MR)': 'ICE CANYON FIELD', 'LAKE CANYON': 'LAKE CANYON FIELD', 'LAST CHANCE': 'LAST CHANCE FIELD', 'LODGEPOLE': 'LODGEPOLE FIELD', 'MAIN CANYON': 'MAIN CANYON FIELD', 'MANCOS FLAT': 'MANCOS FLAT FIELD', 'MCELMO MESA': 'MCELMO MESA FIELD', 'NAVAJO CANYON': 'NAVAJO CANYON FIELD', 'NORTH MYTON BENCH': 'NORTH MYTON BENCH',\r\n                             'PARIETTE BENCH': 'PARIETTE BENCH FIELD', 'PARK ROAD': 'PARK ROAD FIELD', 'PETERS POINT': 'PETERS POINT FIELD', 'PETES WASH': 'PETES WASH FIELD', 'RABBIT EARS': 'RABBIT EARS FIELD', 'RANDLETT': 'RANDLETT FIELD', 'ROBIDOUX': 'ROBIDOUX FIELD', 'ROCK HOUSE': 'ROCK HOUSE FIELD', 'RUNWAY': 'RUNWAY FIELD', 'SEGUNDO CANYON': 'SEGUNDO CANYON FIELD', 'SOUTH PINE RIDGE': 'SOUTH PINE RIDGE FIELD', 'STRAWBERRY': 'STRAWBERRY FIELD', 'SWEET WATER RIDGE': 'SWEETWATER RIDGE FIELD',\r\n                             'TOHONADLA': 'TOHONADLA FIELD', 'UCOLO': 'UCOLO FIELD', 'UTELAND BUTTE': 'UTELAND BUTTE FIELD', 'WHITE MESA': 'WHITE MESA FIELD', 'WILD STALLION': 'WILD STALLION FIELD', 'WINDY RIDGE': 'WINDY RIDGE FIELD', 'WONSITS VALLEY': 'WONSITS VALLEY FIELD', 'WOODSIDE': 'WOODSIDE FIELD', '8 MILE FLAT NORTH': 'EIGHT MILE FLAT NORTH FIELD', 'AGENCY DRAW': 'AGENCY DRAW FIELD', 'ALKALI CANYON': 'ALKALI CANYON FIELD', 'ALTAMONT': 'ALTAMONT FIELD', 'ANETH': 'ANETH FIELD',\r\n                             'ANTELOPE CREEK': 'ANTELOPE CREEK FIELD', 'BIG VALLEY': 'BIG VALLEY FIELD', 'BLUEBELL': 'BLUEBELL FIELD', 'BLUFF': 'BLUFF FIELD', 'BLUFF BENCH': 'BLUFF BENCH FIELD', 'BRIDGELAND': 'BRIDGELAND FIELD', 'BRIDGER LAKE': 'BRIDGER LAKE FIELD', 'BRUNDAGE CANYON': 'BRUNDAGE CANYON FIELD', 'BUCK CANYON': 'BUCK CANYON FIELD', 'BUSHY': 'BUSHY FIELD', 'CEDAR CAMP': 'CEDAR CAMP FIELD', 'CHEROKEE': 'CHEROKEE FIELD', 'CHINLE WASH': 'CHINLE WASH FIELD',\r\n                             'CISCO DOME': 'CISCO DOME FIELD', 'CLAY BASIN': 'CLAY BASIN FIELD', 'CLEFT': 'CLEFT FIELD', 'CONE ROCK': 'CONE ROCK FIELD', 'COVENANT': 'COVENANT FIELD', 'COWBOY': 'COWBOY FIELD', 'DAVIS CANYON': 'DAVIS CANYON FIELD', 'DEAD MAN CANYON': 'DEADMAN CANYON FIELD', 'DEADMAN-ISMY': 'DEADMAN (ISMAY) FIELD', 'DELTA SALT CAVERN STORAGE': 'DELTA SALT CAVERN STORAGE FIELD', 'DEVILS PLAYGROUND': \"DEVIL'S PLAYGROUND FIELD\", 'DRY BURN': 'DRY BURN FIELD',\r\n                             'EAST CANYON': 'EAST CANYON FIELD', 'EVACUATION CREEK': 'EVACUATION CREEK FIELD', 'FARMINGTON': 'FARMINGTON FIELD', 'GRASSY TRAIL': 'GRASSY TRAIL FIELD', 'GRAYSON': 'GRAYSON FIELD', 'GUSHER': 'GUSHER FIELD', 'HATCH': 'HATCH FIELD', \"HELL'S HOLE\": \"HELL'S HOLE FIELD\", 'HELPER': 'HELPER FIELD', 'HORSE CANYON': 'HORSE CANYON FIELD', 'INDEPENDENCE': 'INDEPENDENCE FIELD', 'KACHINA': 'KACHINA FIELD', 'KICKER': 'KICKER FIELD', 'LIGHTNING DRAW': 'LIGHTNING DRAW FIELD',\r\n                             'LION MESA': 'LION MESA FIELD', 'LISBON': 'LISBON FIELD', 'MC CRACKEN SPRING': 'MCCRACKEN SPRING FIELD', 'MOAB GAS STORAGE': 'MOAB GAS STORAGE', 'MONUMENT': 'MONUMENT FIELD', 'MONUMENT BUTTE': 'MONUMENT BUTTE FIELD', 'MUSTANG FLAT': 'MUSTANG FLAT FIELD', 'NATURAL BUTTES': 'NATURAL BUTTES FIELD', 'NINE MILE CANYON': 'NINE MILE CANYON FIELD', 'NORTH BONANZA': 'NORTH BONANZA FIELD', 'PAIUTE KNOLL': 'PAIUTE KNOLL FIELD', 'PEAR PARK': 'PEAR PARK FIELD',\r\n                             'POWDER SPRINGS': 'POWDER SPRINGS FIELD', 'RAT HOLE CANYON': 'RAT HOLE CANYON FIELD', 'RECAPTURE CREEK': 'RECAPTURE CREEK FIELD', 'ROCKWELL FLAT': 'ROCKWELL FLAT FIELD', 'SAN ARROYO': 'SAN ARROYO FIELD', 'SEEP RIDGE': 'SEEP RIDGE FIELD', 'SHUMWAY POINT': 'SHUMWAY POINT FIELD', 'SODA SPRING': 'SODA SPRING FIELD', 'SOLDIER CREEK': 'SOLDIER CREEK FIELD', 'SOUTH ISMAY': 'SOUTH ISMAY FIELD', 'SOWERS CANYON': 'SOWER CANYON FIELD', 'STONE CABIN': 'STONE CABIN FIELD',\r\n                             'SWEETWATER CYN': 'SWEETWATER CANYON FIELD', 'TIN CUP MESA': 'TIN CUP MESA FIELD', 'TOWER': 'TOWER FIELD', 'TURNER BLUFF': 'TURNER BLUFF FIELD', 'VIRGIN': 'VIRGIN FIELD', 'WHITE RIVER': 'WHITE RIVER FIELD', 'WINTER CAMP': 'WINTER CAMP FIELD', 'ALGER PASS': 'ALGER PASS FIELD', 'ALKALI POINT': 'ALKALI POINT FIELD', 'ANIDO CREEK': 'ANIDO CREEK FIELD', 'ASPHALT WASH': 'ASPHALT WASH FIELD', 'ATCHEE RIDGE': 'ATCHEE RIDGE FIELD', 'BANNOCK': 'BANNOCK FIELD',\r\n                             'BIG SPRING': 'BIG SPRING FIELD', 'BITTER CREEK': 'BITTER CREEK FIELD', 'BLACK BULL': 'BLACK BULL FIELD', 'BLACK HORSE CYN': 'BLACK HORSE CANYON FIELD', 'BOOK CLIFFS': 'BOOK CLIFFS FIELD', 'BRENNAN BOTTOM': 'BRENNAN BOTTOM FIELD', 'BROKEN HILLS': 'BROKEN HILLS FIELD', 'BRONCO': 'BRONCO FIELD', 'BRYSON CANYON': 'BRYSON CANYON FIELD', 'CAJON LAKE': 'CAJON LAKE FIELD', 'CANE CREEK': 'KANE CREEK FIELD', 'CASA MESA': 'CASA MESA FIELD',\r\n                             'CHALK CREEK GAS STORAGE': 'CHALK CREEK GAS STORAGE', 'COTTONWOOD WASH': 'COTTONWOOD WASH FIELD', 'CROOKED CANYON': 'CROOKED CANYON FIELD', 'DUCHESNE': 'DUCHESNE FIELD', 'FLAT CANYON': 'FLAT CANYON FIELD', 'GATE CANYON': 'GATE CANYON FIELD', 'GORDON CREEK': 'GORDON CREEK FIELD', 'GOTHIC MESA': 'GOTHIC MESA FIELD', 'GYPSUM HILLS': 'GYPSUM HILLS FIELD', 'HELL ROARING': 'HELL ROARING FIELD', 'HERON': 'HERON FIELD', 'HILL CREEK': 'HILL CREEK FIELD',\r\n                             'HORSE POINT': 'HORSE POINT FIELD', \"JOE'S VALLEY\": \"JOE'S VALLEY FIELD\", 'KENNEDY WASH': 'KENNEDY WASH FIELD', 'LIGHTNING DRAW SE': 'LIGHTNING DRAW FIELD', 'LITTLE NANCY': 'LITTLE NANCY FIELD', 'LITTLE VALLEY': 'LITTLE VALLEY FIELD', 'LONE SPRING': 'LONE SPRING FIELD', 'LONG CANYON': 'LONG CANYON FIELD', 'MIDDLE BENCH': 'MIDDLE BENCH FIELD', 'MOON RIDGE': 'MOON RIDGE FIELD', 'NAVAL RESERVE': 'NAVAL RESERVE FIELD', 'PETERSON SPRING': 'PETERSON SPRINGS FIELD',\r\n                             'PLEASANT VALLEY': 'PLEASANT VALLEY FIELD', 'RED WASH': 'RED WASH FIELD', 'SALT WASH': 'SALT WASH FIELD', 'SCOFIELD': 'UCOLO FIELD', 'SHAFER CANYON': 'SHAFER CANYON FIELD', 'SOUTH CANYON': 'SOUTH CANYON FIELD', 'SOUTH MYTON BENCH': 'NORTH MYTON BENCH', 'SQUAW POINT': 'SQUAW POINT FIELD', 'WALKER HOLLOW': 'WALKER HOLLOW FIELD', 'WESTWATER': 'WESTWATER FIELD', 'WHITEBELLY WASH': 'WHITEBELLY WASH FIELD', 'YELLOW ROCK': 'YELLOW ROCK FIELD',\r\n                             'AGENCY DRAW WEST': 'AGENCY DRAW WEST FIELD', 'ANSCHUTZ RANCH': 'ANSCHUTZ RANCH FIELD', 'ANSCHUTZ RANCH EAST': 'ANSCHUTZ RANCH EAST FIELD', 'ASHLEY VALLEY': 'ASHLEY VALLEY FIELD', 'BIG INDIAN NORTH': 'BIG INDIAN (NORTH) FIELD', 'BLAZE CANYON': 'BLAZE CANYON FIELD', 'CAJON MESA': 'CAJON MESA FIELD', 'CASTLEGATE': 'CASTLEGATE FIELD', 'CAVE CANYON': 'CAVE CANYON FIELD', 'CAVE CREEK': 'CAVE CREEK FIELD', 'CEDAR RIM': 'CEDAR RIM FIELD',\r\n                             'COALVILLE GAS STORAGE': 'COALVILLE GAS STORAGE', 'COYOTE BASIN': 'COYOTE BASIN FIELD', 'DIAMOND RIDGE': 'DIAMOND RIDGE FIELD', 'DRUNKARDS WASH': 'DRUNKARDS WASH FIELD', 'EIGHT MILE FLAT': 'EIGHT MILE FLAT FIELD', 'FERRON': 'FERRON FIELD', 'FIRTH': 'FIRTH FIELD', 'FLAT ROCK': 'FLAT ROCK FIELD', 'GREATER ANETH': 'GREATER ANETH FIELD', 'GREENTOWN': 'GREENTOWN FIELD', 'INDIAN CANYON': 'INDIAN CANYON FIELD', 'ISMAY': 'ISMAY FIELD',\r\n                             'LEFT HAND CYN': 'LEFT HAND CANYON FIELD', 'LELAND BENCH': 'LELAND BENCH FIELD', 'MATHEWS': 'MATHEWS FIELD', 'MEXICAN HAT': 'MEXICAN HAT FIELD', 'MIDDLE CANYON (DKTA)': 'MIDDLE CANYON FIELD', 'MILLER CREEK': 'MILLER CREEK FIELD', 'MOFFAT CANAL': 'MOFFAT CANAL FIELD', 'NORTH PINEVIEW': 'NORTH PINEVIEW FIELD', 'OIL SPRINGS': 'OIL SPRINGS FIELD', 'PATTERSON CANYON': 'PATTERSON CANYON FIELD', 'PINE SPRINGS': 'PINE SPRINGS FIELD', 'PINEVIEW': 'PINEVIEW FIELD',\r\n                             'PROVIDENCE': 'PROVIDENCE FIELD', 'RECAPTURE POCKET': 'RECAPTURE POCKET FIELD', 'RIVER BANK': 'RIVER BANK FIELD', 'ROAD CANYON': 'ROAD CANYON FIELD', 'ROZEL POINT': 'ROZEL POINT FIELD', 'SEEP RIDGE B (DKTA)': 'SEEP RIDGE B FIELD', 'SQUAW CANYON': 'SQUAW CANYON FIELD', 'STARR FLAT': 'STARR FLAT FIELD', 'STATELINE': 'STATE LINE FIELD', 'TEN MILE': 'TEN MILE FIELD', 'THREE RIVERS': 'THREE RIVERS FIELD', 'UPPER VALLEY': 'UPPER VALLEY FIELD',\r\n                             'WEST WILLOW CREEK': 'WEST WILLOW CREEK FIELD', 'WHISKEY CREEK': 'WHISKEY CREEK FIELD', 'WILSON CANYON': 'WILSON CANYON FIELD', 'WOLF POINT': 'WOLF POINT FIELD', 'TABYAGO': 'TABYAGO CANYON FIELD', 'KIVA': 'KIVA FIELD', 'AKAH': 'AKAH FIELD', 'BUG': 'BUG FIELD', 'LOVE': 'LOVE FIELD', '12 MILE WASH': 'TWELVE MILE WASH FIELD'}\r\n\r\n        # Define month name to number mapping\r\n        month_dict: Dict[str, int] = {\r\n            'January': 1, 'February': 2, 'March': 3, 'April': 4,\r\n            'May': 5, 'June': 6, 'July': 7, 'August': 8,\r\n            'September': 9, 'October': 10, 'November': 11, 'December': 12\r\n        }\r\n\r\n        # Load and initial processing of well data\r\n        self.dx_data = read_sql('select * from WellInfo', self.conn_db)\r\n        self.dx_data = self.dx_data.rename(columns={'entityname': 'Operator'})\r\n\r\n        # Remove plugged wells and duplicates\r\n        self.dx_data = self.dx_data[self.dx_data['WorkType'] != 'PLUG']\r\n        self.dx_data.drop_duplicates(keep='first', inplace=True)\r\n\r\n        # Create display names for wells\r\n        self.dx_data['DisplayName'] = self.dx_data['WellID'].astype(str) + ' - ' + self.dx_data['WellName'].astype(str)\r\n\r\n        # Process dates and calculate well age\r\n        self.dx_data['DrySpud'] = to_datetime(self.dx_data['DrySpud'])\r\n        self.dx_data['WellAge'] = (datetime.now().year - self.dx_data['DrySpud'].dt.year) * 12 + datetime.now().month - \\\r\n                                  self.dx_data['DrySpud'].dt.month\r\n        self.dx_data['DrySpud'] = self.dx_data['DrySpud'].dt.strftime('%Y-%m-%d')\r\n\r\n        # Set well age to 0 for approved permits without spud dates\r\n        condition = pd.isna(self.dx_data['WellAge']) & (self.dx_data['CurrentWellStatus'] == 'Approved Permit')\r\n        self.dx_data.loc[condition, 'WellAge'] = 0\r\n\r\n        # Sort by month and year\r\n        self.dx_data['month_order'] = self.dx_data['Docket_Month'].map(month_dict)\r\n        df_sorted = self.dx_data.sort_values(by=['Board_Year', 'month_order'])\r\n        self.dx_data = df_sorted.drop('month_order', axis=1)\r\n\r\n        # Standardize field names\r\n        self.dx_data['FieldName'] = self.dx_data['FieldName'].map(translated_fields)\r\n\r\n        # Return unique wells only\r\n        dx_data_unique = self.dx_data.drop_duplicates(subset=['WellID'])\r\n        return dx_data_unique\r\n\r\n    def loadWellData(self, dx_data_unique: DataFrame) -> None:\r\n        \"\"\"Loads and processes well directional survey data, merging it with unique well information\r\n        and performing necessary coordinate and elevation calculations.\r\n\r\n        This method queries the DX table, merges it with well-specific data, and performs various\r\n        data transformations including elevation calculations and coordinate conversions.\r\n\r\n        Args:\r\n            dx_data_unique (DataFrame): DataFrame containing unique well records with columns:\r\n                - WellID: Well identifier\r\n                - Elevation: Surface elevation of well\r\n                - FieldName: Name of the oil/gas field\r\n                - Mineral Lease: Associated mineral lease information\r\n                - ConcCode: Concentration code\r\n\r\n        Notes:\r\n            - Updates several class attributes including self.dx_df and self.df_shl\r\n            - Performs coordinate conversions from meters to state plane (feet)\r\n            - Adjusts vertical well coordinates slightly to enable linestring creation\r\n            - All depth and elevation calculations are in consistent units (feet)\r\n\r\n        Side Effects:\r\n            - Modifies self.dx_df: Main directional survey DataFrame\r\n            - Creates self.df_shl: Surface hole location DataFrame\r\n        \"\"\"\r\n        # Load directional survey data and remove duplicates\r\n        self.dx_df = read_sql('select * from DX', self.conn_db)\r\n        self.dx_df.drop_duplicates(keep='first', inplace=True)\r\n\r\n        # Merge directional survey data with well-specific information\r\n        self.dx_df = pd.merge(\r\n            self.dx_df,\r\n            dx_data_unique[['WellID', 'Elevation', 'FieldName', 'Mineral Lease', 'ConcCode']],\r\n            how='left',\r\n            left_on='APINumber',\r\n            right_on='WellID'\r\n        )\r\n\r\n        # Convert coordinate columns to float type\r\n        self.dx_df['X'] = self.dx_df['X'].astype(float)\r\n        self.dx_df['Y'] = self.dx_df['Y'].astype(float)\r\n\r\n        # Calculate true elevation relative to well head elevation\r\n        self.dx_df['TrueElevation'] = self.dx_df['Elevation'] - to_numeric(self.dx_df['TrueVerticalDepth'],\r\n                                                                           errors='coerce')\r\n        self.dx_df['MeasuredDepth'] = to_numeric(self.dx_df['MeasuredDepth'], errors='coerce')\r\n\r\n        # Standardize citing type to lowercase\r\n        self.dx_df['CitingType'] = self.dx_df['CitingType'].str.lower()\r\n\r\n        # Adjust Y coordinates for vertical wells to create valid linestrings\r\n        # Adds small incremental offset (0.001) to Y coordinate for each point\r\n        self.dx_df.loc[self.dx_df['CitingType'] == 'vertical', 'Y'] += self.dx_df.groupby(['X', 'Y']).cumcount() * 1e-3\r\n\r\n        # Convert coordinates to state plane (meters to feet)\r\n        self.dx_df['SPX'] = self.dx_df['X'].astype(float) / 0.3048  # Convert meters to feet\r\n        self.dx_df['SPY'] = self.dx_df['Y'].astype(float) / 0.3048  # Convert meters to feet\r\n\r\n        # Sort data by well ID and measured depth\r\n        self.dx_df = self.dx_df.sort_values(by=['WellID', 'MeasuredDepth'])\r\n\r\n        # Create surface hole location DataFrame from first point of each well\r\n        self.df_shl = self.dx_df.groupby('WellID').first().reset_index()\r\n\r\n    def reTranslateData(self, i):\r\n        conc_code_merged = i[:6]\r\n        conc_code_merged.iloc[2] = self.translateNumberToDirection('township', str(conc_code_merged.iloc[2])).upper()\r\n        conc_code_merged.iloc[4] = self.translateNumberToDirection('rng', str(conc_code_merged.iloc[4])).upper()\r\n        conc_code_merged.iloc[5] = self.translateNumberToDirection('baseline', str(conc_code_merged.iloc[5])).upper()\r\n        conc_code_merged.iloc[0] = str(int(float(conc_code_merged.iloc[0]))).zfill(2)\r\n        conc_code_merged.iloc[1] = str(int(float(conc_code_merged.iloc[1]))).zfill(2)\r\n        conc_code_merged.iloc[3] = str(int(float(conc_code_merged.iloc[3]))).zfill(2)\r\n        conc_code = \"\".join([str(q) for q in conc_code_merged])\r\n        return conc_code\r\n\r\n    def translateNumberToDirection(self, variable, val):\r\n        translations = {\r\n            'rng': {'2': 'W', '1': 'E'},\r\n            'township': {'2': 'S', '1': 'N'},\r\n            'baseline': {'2': 'U', '1': 'S'},\r\n            'alignment': {'1': 'SE', '2': 'NE', '3': 'SW', '4': 'NW'}\r\n        }\r\n        return translations.get(variable, {}).get(val, val)\r\nclass ZoomPan:\r\n    \"\"\"A class to handle zoom and pan functionality for matplotlib plots with dynamic text scaling.\r\n\r\n    This class provides interactive zoom and pan capabilities for matplotlib figures, including\r\n    automatic text size adjustment based on the zoom level.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        \"\"\"Initialize the ZoomPan instance with default values for tracking interaction states.\"\"\"\r\n        self.press: Optional[Tuple[float, float, float, float]] = None  # Stores press event data\r\n        self.cur_xlim: Optional[Tuple[float, float]] = None  # Current x-axis limits\r\n        self.cur_ylim: Optional[Tuple[float, float]] = None  # Current y-axis limits\r\n        self.x0: Optional[float] = None  # Initial x coordinate\r\n        self.y0: Optional[float] = None  # Initial y coordinate\r\n        self.x1: Optional[float] = None  # Final x coordinate\r\n        self.y1: Optional[float] = None  # Final y coordinate\r\n        self.xpress: Optional[float] = None  # x coordinate at press\r\n        self.ypress: Optional[float] = None  # y coordinate at press\r\n        self.text_objects: List[Text] = []  # List to store text annotations\r\n\r\n    def zoom_factory(self, ax: Axes, base_scale: float) -> Callable:\r\n        \"\"\"Creates and returns a zoom handler function for the specified axes.\r\n\r\n        Args:\r\n            ax: Matplotlib axes object to enable zooming on\r\n            base_scale: Scale factor for zoom operations (>1 for zoom out, <1 for zoom in)\r\n\r\n        Returns:\r\n            Callable function that handles zoom events\r\n\r\n        Notes:\r\n            The zoom handler automatically adjusts text annotation sizes based on zoom level\r\n        \"\"\"\r\n\r\n        def zoom(event: MouseEvent) -> None:\r\n            \"\"\"Handle mouse scroll events for zooming.\"\"\"\r\n            cur_xlim = ax.get_xlim()\r\n            cur_ylim = ax.get_ylim()\r\n\r\n            xdata = event.xdata\r\n            ydata = event.ydata\r\n\r\n            # Determine zoom direction and scale factor\r\n            scale_factor = 1 / base_scale if event.button == 'down' else base_scale\r\n\r\n            # Calculate new dimensions\r\n            new_width = (cur_xlim[1] - cur_xlim[0]) * scale_factor\r\n            new_height = (cur_ylim[1] - cur_ylim[0]) * scale_factor\r\n\r\n            # Calculate relative positions\r\n            relx = (cur_xlim[1] - xdata) / (cur_xlim[1] - cur_xlim[0])\r\n            rely = (cur_ylim[1] - ydata) / (cur_ylim[1] - cur_ylim[0])\r\n\r\n            # Set new limits\r\n            ax.set_xlim([xdata - new_width * (1 - relx), xdata + new_width * (relx)])\r\n            ax.set_ylim([ydata - new_height * (1 - rely), ydata + new_height * (rely)])\r\n\r\n            # Update text annotation sizes\r\n            scale_factor = ax.get_xlim()[1] - ax.get_xlim()[0]\r\n            for text in self.text_objects:\r\n                new_fontsize = 12 / scale_factor * 2500\r\n                text.set_fontsize(new_fontsize)\r\n            ax.figure.canvas.draw()\r\n\r\n        fig = ax.get_figure()\r\n        fig.canvas.mpl_connect('scroll_event', zoom)\r\n        return zoom\r\n\r\n    def add_text(self, ax: Axes, x: float, y: float, text_str: str) -> None:\r\n        \"\"\"Add a text annotation to the plot with dynamic size scaling.\r\n\r\n        Args:\r\n            ax: Matplotlib axes object to add text to\r\n            x: X-coordinate for text placement\r\n            y: Y-coordinate for text placement\r\n            text_str: Text string to display\r\n        \"\"\"\r\n        scale_factor = ax.get_xlim()[1] - ax.get_xlim()[0]\r\n        text = ax.text(x, y, text_str, ha='center', va='center',\r\n                       fontsize=12 / scale_factor * 2500, transform=ax.transData)\r\n        self.text_objects.append(text)\r\n\r\n    def pan_factory(self, ax: Axes) -> Callable:\r\n        \"\"\"Creates and returns a pan handler function for the specified axes.\r\n\r\n        Args:\r\n            ax: Matplotlib axes object to enable panning on\r\n\r\n        Returns:\r\n            Callable function that handles pan motion events\r\n        \"\"\"\r\n\r\n        def onPress(event: MouseEvent) -> None:\r\n            \"\"\"Handle mouse button press events.\"\"\"\r\n            if event.inaxes != ax: return\r\n            self.cur_xlim = ax.get_xlim()\r\n            self.cur_ylim = ax.get_ylim()\r\n            self.press = self.x0, self.y0, event.xdata, event.ydata\r\n            self.x0, self.y0, self.xpress, self.ypress = self.press\r\n\r\n        def onRelease(event: MouseEvent) -> None:\r\n            \"\"\"Handle mouse button release events.\"\"\"\r\n            self.press = None\r\n            ax.figure.canvas.draw()\r\n\r\n        def onMotion(event: MouseEvent) -> None:\r\n            \"\"\"Handle mouse motion events for panning.\"\"\"\r\n            if self.press is None: return\r\n            if event.inaxes != ax: return\r\n            dx = event.xdata - self.xpress\r\n            dy = event.ydata - self.ypress\r\n            self.cur_xlim -= dx\r\n            self.cur_ylim -= dy\r\n            ax.set_xlim(self.cur_xlim)\r\n            ax.set_ylim(self.cur_ylim)\r\n            ax.figure.canvas.draw()\r\n\r\n        fig = ax.get_figure()\r\n        fig.canvas.mpl_connect('button_press_event', onPress)\r\n        fig.canvas.mpl_connect('button_release_event', onRelease)\r\n        fig.canvas.mpl_connect('motion_notify_event', onMotion)\r\n        return onMotion\r\n\r\ndef except_hook(cls, exception, traceback):\r\n    sys.__excepthook__(cls, exception, traceback)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    import sys\r\n\r\n    app = QApplication(sys.argv)\r\n    w = wellVisualizationProcess()\r\n    w.show()\r\n    sys.excepthook = except_hook\r\n    sys.exit(app.exec_())\r\n\r\nmain()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../WellVisualizerMain.py b/../WellVisualizerMain.py
--- a/../WellVisualizerMain.py	(revision 11c8d433909f415072d1821b99a7cb0108153144)
+++ b/../WellVisualizerMain.py	(date 1743024540436)
@@ -1048,14 +1048,14 @@
         """
         self.test_df: pd.DataFrame = (
             # Filter for wells in current docket
-            self.dx_df[self.dx_df['APINumber'].isin(self.apis)]
+            self.dx_df[self.dx_df['api_number'].isin(self.apis)]
             # Remove duplicate entries
             .drop_duplicates(keep='first')
             # Sort by API number and depth for proper trajectory ordering
-            .sort_values(by=['APINumber', 'MeasuredDepth']))
+            .sort_values(by=['api_number', 'MeasuredDepth']))
 
     def filterDocketForDirectionalSurveyData2(self):
-        unique_apis_with_data = self.test_df['APINumber'].unique()
+        unique_apis_with_data = self.test_df['api_number'].unique()
         self.df_docket = self.df_docket[self.df_docket['WellID'].isin(unique_apis_with_data)]
 
     def filterDocketForDirectionalSurveyData(self) -> None:
@@ -1088,7 +1088,7 @@
             KeyError: If 'APINumber' column is missing from test_df or 'WellID' from df_docket
         """
         # Get unique API numbers from wells with directional survey data
-        unique_apis_with_data: Set[str] = self.test_df['APINumber'].unique()
+        unique_apis_with_data: Set[str] = self.test_df['api_number'].unique()
 
         # Filter docket to include only wells that have directional survey data
         self.df_docket = self.df_docket[self.df_docket['WellID'].isin(unique_apis_with_data)]
@@ -1895,7 +1895,7 @@
             for column in range(self.all_wells_model.columnCount())]
 
         # Filter well data based on API Number and extract coordinates
-        filtered_df: pd.DataFrame = self.currently_used_lines[self.currently_used_lines['APINumber'] == row_data[0]]
+        filtered_df: pd.DataFrame = self.currently_used_lines[self.currently_used_lines['api_number'] == row_data[0]]
         data_select_2d: np.ndarray = filtered_df[['X', 'Y']].to_numpy().astype(float)
         data_select_3d: np.ndarray = filtered_df[['SPX', 'SPY', 'Targeted Elevation']].to_numpy().astype(float)
 
@@ -2146,10 +2146,10 @@
                 closest_point: pd.Series = closest_points.loc[closest_points['distance'].idxmin()]
 
                 # Get API number of selected well
-                selected_well_api: str = closest_point['APINumber']
+                selected_well_api: str = closest_point['api_number']
 
                 # Filter full well data
-                filtered_df: pd.DataFrame = self.currently_used_lines[self.currently_used_lines['APINumber'] == selected_well_api]
+                filtered_df: pd.DataFrame = self.currently_used_lines[self.currently_used_lines['api_number'] == selected_well_api]
 
                 # Extract 2D and 3D coordinate data
                 data_select_2d: np.ndarray = filtered_df[['X', 'Y']].to_numpy().astype(float)
@@ -2434,7 +2434,7 @@
         print(self.dx_data)
         print(foo)
         # Filter directional survey data for selected well
-        df_well: pd.DataFrame = self.dx_df[self.dx_df['APINumber'] == df_well_data['WellID'].iloc[0]]
+        df_well: pd.DataFrame = self.dx_df[self.dx_df['api_number'] == df_well_data['WellID'].iloc[0]]
 
         # Separate data by citing type
         drilled_df: pd.DataFrame = df_well[df_well['CitingType'].isin(['asdrilled'])]
@@ -2843,7 +2843,7 @@
         """
         # Remove duplicates and sort
         df = df.drop_duplicates(keep='first')
-        df = df.sort_values(by='APINumber')
+        df = df.sort_values(by='api_number')
 
         # Reset index and handle missing ages
         df = df.reset_index(drop=True)
@@ -3035,7 +3035,7 @@
             # Filter data using combined masks and sort
             dataframes[key] = self.df_docket_data.loc[mask & age_masks[i]]
             dataframes[key] = dataframes[key].reset_index(drop=True).sort_values(
-                by=['APINumber', 'MeasuredDepth']
+                by=['api_number', 'MeasuredDepth']
             )
 
         return dataframes
Index: ../.idea/OGMBoardProject.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <excludeFolder url=\"file://$MODULE_DIR$/.venv\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../.idea/OGMBoardProject.iml b/../.idea/OGMBoardProject.iml
--- a/../.idea/OGMBoardProject.iml	(revision 11c8d433909f415072d1821b99a7cb0108153144)
+++ b/../.idea/OGMBoardProject.iml	(date 1743518605556)
@@ -3,6 +3,7 @@
   <component name="NewModuleRootManager">
     <content url="file://$MODULE_DIR$">
       <excludeFolder url="file://$MODULE_DIR$/.venv" />
+      <excludeFolder url="file://$MODULE_DIR$/MiscFunctions/.venv" />
     </content>
     <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
Index: ../main_process.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nWellVisualizerMain.py\r\nAuthor: Colton Goodrich\r\nDate: 11/10/2024\r\nPython Version: 3.12\r\nThis module is a PyQt5 application that provides a graphical user interface (GUI) for\r\nvisualizing and analyzing well data, board matters, and related information from the\r\nState of Utah, Division of Oil, Gas, and Mining.\r\n\r\nThe application features various functionalities, including:\r\n\r\n- Interactive visualization of well trajectories in both 2D and 3D views, including\r\n  planned, currently drilling, and completed wells\r\n- Real-time well path visualization with different line styles for different well states\r\n  (planned: dashed, drilling: solid, completed: solid)\r\n- Advanced filtering system for wells based on type (oil, gas, water disposal, dry hole,\r\n  injection) and status (shut-in, PA, producing, drilling)\r\n- Mineral ownership visualization with section-level detail and agency tracking\r\n- Dynamic operator filtering system with color-coded checkboxes and scrollable interfaces\r\n- Production data visualization with cumulative and time-series analysis\r\n- Field boundary and plat code visualization with centroid labeling\r\n- Interactive well selection system with detailed data display\r\n- Customizable visualization features including zoom, pan, and scale adjustment\r\n\r\nClasses:\r\n- MultiBoldRowDelegate: A custom delegate for applying bold formatting to specific rows\r\n  in Qt views, particularly useful for emphasizing important wells\r\n- BoldDelegate: A custom delegate for applying bold formatting to specific values in\r\n  Qt views\r\n- wellVisualizationProcess: The main application class that inherits from QMainWindow\r\n  and BoardMattersVisualizer, handling all core functionality\r\n\r\nKey Components:\r\n- Data Management: Utilizes Pandas, GeoPandas, and SQLite for efficient data handling\r\n- Visualization: Combines Matplotlib with PyQt5 for interactive plotting\r\n- Geospatial Processing: Integrates UTM and Shapely for coordinate transformations\r\n  and geometric operations\r\n- User Interface: Custom-designed PyQt5 interface with scrollable areas and\r\n  dynamic updates\r\n\r\nThe module serves as a comprehensive tool for analyzing and visualizing well data,\r\nproviding detailed insights into well operations, ownership, and regulatory matters\r\nfor the State of Utah's Division of Oil, Gas, and Mining operations.\r\n\r\nDependencies:\r\n- Core Scientific: numpy, pandas, geopandas\r\n- GUI Framework: PyQt5\r\n- Visualization: matplotlib\r\n- Geospatial: shapely, utm\r\n- Database: sqlite3, sqlalchemy\r\n- Utility: regex\r\n\r\nNote: This application requires specific data structures and database connectivity\r\nto function properly. See accompanying documentation for setup requirements.\r\n\"\"\"\r\n\r\n# Python standard library imports\r\nimport itertools\r\nimport os\r\nimport sqlite3\r\nfrom datetime import datetime\r\nfrom typing import Callable, Dict, List, Literal, NoReturn, Optional, Set, Tuple, Union\r\n\r\n# Third-party imports - Core Data/Scientific\r\nimport numpy as np\r\nfrom numpy import array, std\r\nimport pandas as pd\r\nfrom pandas import DataFrame, concat, options, read_sql, set_option, to_datetime, to_numeric\r\nimport geopandas as gpd\r\nimport utm\r\nfrom sqlalchemy import create_engine\r\n\r\n# Third-party imports - PyQt5\r\nimport PyQt5\r\nfrom PyQt5.QtCore import QAbstractItemModel, QModelIndex, Qt\r\nfrom PyQt5.QtGui import QColor, QStandardItem, QStandardItemModel\r\nfrom PyQt5.QtWidgets import (\r\n    QApplication, QCheckBox, QGraphicsDropShadowEffect, QHeaderView,\r\n    QHBoxLayout, QLabel, QLayout, QMainWindow, QScrollArea,\r\n    QStyledItemDelegate, QTableWidget, QTableWidgetItem,\r\n    QVBoxLayout, QWidget\r\n)\r\n\r\n# Third-party imports - Matplotlib\r\nimport matplotlib.dates as mdates\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.axes import Axes\r\nfrom matplotlib.backend_bases import MouseEvent\r\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\r\nfrom matplotlib.collections import LineCollection, PatchCollection, PolyCollection\r\nfrom matplotlib.figure import Figure\r\nfrom matplotlib.lines import Line2D\r\nfrom matplotlib.patches import PathPatch, Polygon\r\nfrom matplotlib.text import Text\r\nfrom matplotlib.textpath import TextPath\r\nfrom matplotlib.ticker import FuncFormatter, ScalarFormatter\r\nfrom mpl_toolkits.mplot3d.art3d import Line3DCollection\r\n\r\n# Third-party imports - Geospatial\r\nfrom shapely import wkt\r\nfrom shapely.geometry import Point, Polygon\r\nfrom shapely.ops import unary_union\r\n\r\n# Third-party imports - Other\r\nimport regex as re\r\n\r\n# Local application imports\r\nfrom WellVisualizerBoardMatters import BoardMattersVisualizer\r\nfrom WellVisualizationUI import Ui_Dialog\r\nfrom main_process_year import Year\r\n\r\nclass wellVisualizationProcess(QMainWindow):\r\n    def __init__(self, flag=True):\r\n        super().__init__()\r\n        set_option('display.max_columns', None)\r\n        options.mode.chained_assignment = None\r\n        self.ui = Ui_Dialog()\r\n        self.ui.setupUi(self)\r\n        path = r\"C:\\Work\\databases\"\r\n        apd_data_dir = os.path.join(path, 'Board_DB.db')\r\n        self.conn_db = sqlite3.connect(apd_data_dir)\r\n        self.cursor_db = self.conn_db.cursor()\r\n        # Create SQLAlchemy engine\r\n        self.engine = create_engine(f'sqlite:///{apd_data_dir}')\r\n        self.df_field, self.df_owner = None, None\r\n        self.df_adjacent_fields = None\r\n        self.df_plat = None\r\n        self.df_adjacent_plats = None\r\n        self.well_data_unique_df = None\r\n        self.well_df = None\r\n        self.dx_df = None\r\n        self.df_shl = None\r\n        self.used_dockets = None\r\n        self.used_years = None\r\n        self.df_board_data = None\r\n        self.df_board_data_links = None\r\n        \"\"\"Setup the tables so that they are prepped and ready to go.\"\"\"\r\n        self.setup_tables()\r\n        \"\"\"Load the data to be used, process it, alter it, etc for usage\"\"\"\r\n        self.load_data()\r\n        self.populate_year_combo_box()\r\n        self.ui.year_lst_combobox.activated.connect(lambda: self.do_this_when_year_combo_box_pressed(self.well_df))\r\n\r\n    def populate_year_combo_box(self):\r\n        self.ui.year_lst_combobox.clear()\r\n        self.ui.month_lst_combobox.clear()\r\n        self.ui.board_matter_lst_combobox.clear()\r\n        self.ui.well_lst_combobox.clear()\r\n        model: QStandardItemModel = QStandardItemModel()\r\n        for year in self.used_years:\r\n            item: QStandardItem = QStandardItem(str(year))\r\n            model.appendRow(item)\r\n        self.ui.year_lst_combobox.setModel(model)\r\n\r\n    def do_this_when_year_combo_box_pressed(self, well_df):\r\n        selected_year: str = self.ui.year_lst_combobox.currentText()\r\n        df_year = well_df[well_df['board_year'] == selected_year]\r\n        year_obj = Year(ui=self.ui, year=selected_year, df_year=df_year, dx_df = self.dx_df)\r\n\r\n\r\n    def load_data(self):\r\n        # Load field and ownership base data\r\n        df_field = read_sql('select * from Field', self.conn_db)\r\n        df_owner = read_sql('select * from Owner', self.conn_db)\r\n        df_adjacent_fields = self.load_df_fields(df_field)  # Process field information\r\n        df_board_data, df_board_data_links = self.load_board_data()\r\n        df_plat, df_adjacent_plats = self.load_plat_data()\r\n        well_data_unique_df, well_df = self.load_well_df_data()\r\n        dx_df, df_shl = self.load_well_data(well_data_unique_df)\r\n        used_dockets = well_df['board_docket'].unique()\r\n        used_years = well_df['board_year'].unique()\r\n        df_prod = read_sql('select * from Production', self.conn_db)\r\n        df_prod.drop_duplicates(keep='first', inplace=True)\r\n\r\n        self.df_adjacent_fields = df_adjacent_fields\r\n        self.df_plat = df_plat\r\n        self.df_adjacent_plats = df_adjacent_plats\r\n        self.well_data_unique_df = well_data_unique_df #dx_data_unique\r\n        self.well_df = well_df #dx_data\r\n        self.dx_df = dx_df\r\n        self.df_shl = df_shl\r\n        self.used_dockets = used_dockets\r\n        self.used_years = used_years\r\n        self.df_board_data = df_board_data\r\n        self.df_board_data_links = df_board_data_links\r\n        self.df_field = df_field\r\n        self.df_owner = df_owner\r\n\r\n\r\n\r\n    def load_df_fields(self, df_field):\r\n        # Initialize storage for adjacent field relationships\r\n        adjacent_fields: List[Dict[str, str]] = []\r\n        # Create point geometries for field locations\r\n        df_field['geometry'] = df_field.apply(\r\n            lambda row: Point(row['easting'], row['northing']),\r\n            axis=1\r\n        )\r\n\r\n        # Extract relevant fields for polygon creation\r\n        used_fields = df_field[['field_name', 'easting', 'northing']]\r\n\r\n        # Generate field polygons from coordinate groups\r\n        polygons = used_fields.groupby('field_name').apply(\r\n            lambda x: Polygon(zip(x['easting'], x['northing'])),\r\n            include_groups=False\r\n        ).reset_index()\r\n        polygons.columns = ['field_name', 'geometry']\r\n\r\n        # Create GeoDataFrame with buffer zones\r\n        gdf = gpd.GeoDataFrame(polygons, geometry='geometry')\r\n        gdf['buffer'] = gdf['geometry'].buffer(10)\r\n\r\n        # Identify adjacent fields using spatial analysis\r\n        for _, row in gdf.iterrows():\r\n            # Find neighboring fields using buffer intersection\r\n            neighbors = gdf[gdf['buffer'].intersects(row['geometry'])]['field_name'].tolist()\r\n            neighbors.remove(row['field_name'])  # Remove self-reference\r\n\r\n            # Create adjacency relationships\r\n            adjacent_fields.extend([\r\n                {'field_name': row['field_name'], 'adjacent_Field_Name': neighbor}\r\n                for neighbor in neighbors\r\n            ])\r\n        columns = [k for k,v in adjacent_fields[0].items()]\r\n        return pd.DataFrame(data = adjacent_fields, columns=columns)\r\n\r\n    def load_board_data(self):\r\n        def translateNumberToDirection(variable, val):\r\n            translations = {\r\n                'rng': {'2': 'W', '1': 'E'},\r\n                'township': {'2': 'S', '1': 'N'},\r\n                'baseline': {'2': 'U', '1': 'S'},\r\n                'alignment': {'1': 'SE', '2': 'NE', '3': 'SW', '4': 'NW'}\r\n            }\r\n            return translations.get(variable, {}).get(val, val)\r\n        def conc_code_maker(i):\r\n            conc_code_merged = i[:6]\r\n            conc_code_merged.iloc[2] = translateNumberToDirection('township',\r\n                                                                       str(conc_code_merged.iloc[2])).upper()\r\n            conc_code_merged.iloc[4] = translateNumberToDirection('rng', str(conc_code_merged.iloc[4])).upper()\r\n            conc_code_merged.iloc[5] = translateNumberToDirection('baseline',\r\n                                                                       str(conc_code_merged.iloc[5])).upper()\r\n            conc_code_merged.iloc[0] = str(int(float(conc_code_merged.iloc[0]))).zfill(2)\r\n            conc_code_merged.iloc[1] = str(int(float(conc_code_merged.iloc[1]))).zfill(2)\r\n            conc_code_merged.iloc[3] = str(int(float(conc_code_merged.iloc[3]))).zfill(2)\r\n            conc_code = \"\".join([str(q) for q in conc_code_merged])\r\n            return conc_code\r\n\r\n        # Load board meeting records and associated links\r\n        df_board_data = read_sql('select * from BoardData', self.conn_db)\r\n        df_board_data_links = read_sql('select * from BoardDataLinks', self.conn_db)\r\n\r\n        # Generate concatenated location codes using ModuleAgnostic translator\r\n        df_board_data['conc'] = df_board_data[[\r\n            'sec', 'township', 'township_dir',\r\n            'range', 'range_dir', 'pm'\r\n        ]].apply(lambda x: conc_code_maker(x), axis=1)\r\n        return df_board_data, df_board_data_links\r\n\r\n    def load_plat_data(self):\r\n        # Load raw plat data from database\r\n        df_plat = read_sql('select * from PlatData', self.conn_db)\r\n        df_adjacent_plats = read_sql('select * from Adjacent', self.conn_db)\r\n\r\n        # Clean plat data by removing duplicates and invalid coordinates\r\n        df_plat.drop_duplicates(keep='first', inplace=True)\r\n        df_plat = df_plat.dropna(subset=['lat', 'lon'])\r\n\r\n        # Convert geographic coordinates (Lat/Lon) to UTM projection (Easting/Northing)\r\n        df_plat['easting'], df_plat['northing'] = zip(\r\n            *df_plat.apply(lambda row: utm.from_latlon(row['lat'], row['lon'])[:2], axis=1))\r\n\r\n        # Create Shapely Point geometries for spatial analysis\r\n        df_plat['geometry'] = df_plat.apply(\r\n            lambda row: Point(row['easting'], row['northing']),\r\n            axis=1)\r\n        return df_plat, df_adjacent_plats\r\n    \r\n    def load_well_df_data(self):\r\n        \"\"\"\r\n        Loads and processes directional well data from database, performing data cleanup\r\n        and standardization.\r\n\r\n        Loads well information, removes plugged wells, standardizes field names, and calculates\r\n        well ages. Processes dates and creates display names for wells.\r\n\r\n        Args:\r\n            None\r\n\r\n        Returns:\r\n            DataFrame: Processed well data with unique WellIDs containing columns:\r\n                - WellID: str - Unique identifier for well\r\n                - WellName: str - Name of the well\r\n                - DisplayName: str - Combined WellID and WellName for UI display\r\n                - Operator: str - Well operator name\r\n                - WorkType: str - Type of well work being performed\r\n                - DrySpud: str - Formatted spud date (YYYY-MM-DD)\r\n                - WellAge: int - Age of well in months\r\n                - CurrentWellStatus: str - Current status of well\r\n                - FieldName: str - Standardized field name\r\n                - Board_Year: int - Year of board approval\r\n                - Docket_Month: str - Month of board approval\r\n\r\n        Side Effects:\r\n            - Creates/Updates self.well_df with processed well information\r\n\r\n        Notes:\r\n            - Filters out plugged wells (WorkType = 'PLUG')\r\n            - Removes duplicate entries\r\n            - Standardizes field names using translation dictionary\r\n            - Calculates well age in months from spud date\r\n            - Sets well age to 0 for approved permits without spud dates\r\n        \"\"\"\r\n        # Define field name translations for standardization\r\n        translated_fields: Dict[str, str] = {'AAGARD RANCH': 'AAGARD RANCH FIELD', 'ANDERSON JUNCTION': 'ANDERSON JUNCTION FIELD', 'ANSCHUTZ RANCH WEBER': 'ANSCHUTZ RANCH (WEBER) FIELD', 'BAR X': 'BAR X FIELD', 'BIG FLAT': 'BIG FLAT FIELD', 'BIG FLAT WEST': 'BIG FLAT WEST FIELD', 'BIG INDIAN SOUTH': 'BIG INDIAN (SOUTH) FIELD', 'BONANZA': 'BONANZA FIELD', 'BOUNDARY BUTTE': 'BOUNDARY BUTTE FIELD', 'BRADFORD CYN': 'BRADFORD CANYON FIELD', 'BUZZARD BENCH': 'BUZZARD BENCH FIELD', 'CABALLO': 'CABALLO FIELD',\r\n                             'CACTUS PARK': 'CACTUS PARK FIELD', 'CHOKECHERRY CYN': 'CHOKECHERRY CANYON FIELD', 'CLAY HILL': 'CLAY HILL FIELD', 'CLEAR CREEK': 'CLEAR CREEK FIELD', 'DARK CANYON': 'DARK CANYON FIELD', 'DESERT CREEK': 'DESERT CREEK FIELD', 'ELKHORN': 'ELKHORN FIELD', 'FARNHAM DOME': 'FARNHAM DOME FIELD', 'FENCE CANYON': 'FENCE CANYON FIELD', 'GREATER CISCO': 'GREATER CISCO FIELD', 'HALFWAY HOLLOW': 'HALFWAY HOLLOW FIELD', 'HATCH POINT': 'HATCH POINT FIELD', 'HOGAN': 'HOGAN FIELD',\r\n                             'HOGBACK RIDGE': 'HOGBACK RIDGE FIELD', 'HORSEHEAD POINT': 'HORSEHEAD POINT FIELD', 'HORSESHOE BEND': 'HORSESHOE BEND FIELD', 'ICE CANYON (DK-MR)': 'ICE CANYON FIELD', 'LAKE CANYON': 'LAKE CANYON FIELD', 'LAST CHANCE': 'LAST CHANCE FIELD', 'LODGEPOLE': 'LODGEPOLE FIELD', 'MAIN CANYON': 'MAIN CANYON FIELD', 'MANCOS FLAT': 'MANCOS FLAT FIELD', 'MCELMO MESA': 'MCELMO MESA FIELD', 'NAVAJO CANYON': 'NAVAJO CANYON FIELD', 'NORTH MYTON BENCH': 'NORTH MYTON BENCH',\r\n                             'PARIETTE BENCH': 'PARIETTE BENCH FIELD', 'PARK ROAD': 'PARK ROAD FIELD', 'PETERS POINT': 'PETERS POINT FIELD', 'PETES WASH': 'PETES WASH FIELD', 'RABBIT EARS': 'RABBIT EARS FIELD', 'RANDLETT': 'RANDLETT FIELD', 'ROBIDOUX': 'ROBIDOUX FIELD', 'ROCK HOUSE': 'ROCK HOUSE FIELD', 'RUNWAY': 'RUNWAY FIELD', 'SEGUNDO CANYON': 'SEGUNDO CANYON FIELD', 'SOUTH PINE RIDGE': 'SOUTH PINE RIDGE FIELD', 'STRAWBERRY': 'STRAWBERRY FIELD', 'SWEET WATER RIDGE': 'SWEETWATER RIDGE FIELD',\r\n                             'TOHONADLA': 'TOHONADLA FIELD', 'UCOLO': 'UCOLO FIELD', 'UTELAND BUTTE': 'UTELAND BUTTE FIELD', 'WHITE MESA': 'WHITE MESA FIELD', 'WILD STALLION': 'WILD STALLION FIELD', 'WINDY RIDGE': 'WINDY RIDGE FIELD', 'WONSITS VALLEY': 'WONSITS VALLEY FIELD', 'WOODSIDE': 'WOODSIDE FIELD', '8 MILE FLAT NORTH': 'EIGHT MILE FLAT NORTH FIELD', 'AGENCY DRAW': 'AGENCY DRAW FIELD', 'ALKALI CANYON': 'ALKALI CANYON FIELD', 'ALTAMONT': 'ALTAMONT FIELD', 'ANETH': 'ANETH FIELD',\r\n                             'ANTELOPE CREEK': 'ANTELOPE CREEK FIELD', 'BIG VALLEY': 'BIG VALLEY FIELD', 'BLUEBELL': 'BLUEBELL FIELD', 'BLUFF': 'BLUFF FIELD', 'BLUFF BENCH': 'BLUFF BENCH FIELD', 'BRIDGELAND': 'BRIDGELAND FIELD', 'BRIDGER LAKE': 'BRIDGER LAKE FIELD', 'BRUNDAGE CANYON': 'BRUNDAGE CANYON FIELD', 'BUCK CANYON': 'BUCK CANYON FIELD', 'BUSHY': 'BUSHY FIELD', 'CEDAR CAMP': 'CEDAR CAMP FIELD', 'CHEROKEE': 'CHEROKEE FIELD', 'CHINLE WASH': 'CHINLE WASH FIELD',\r\n                             'CISCO DOME': 'CISCO DOME FIELD', 'CLAY BASIN': 'CLAY BASIN FIELD', 'CLEFT': 'CLEFT FIELD', 'CONE ROCK': 'CONE ROCK FIELD', 'COVENANT': 'COVENANT FIELD', 'COWBOY': 'COWBOY FIELD', 'DAVIS CANYON': 'DAVIS CANYON FIELD', 'DEAD MAN CANYON': 'DEADMAN CANYON FIELD', 'DEADMAN-ISMY': 'DEADMAN (ISMAY) FIELD', 'DELTA SALT CAVERN STORAGE': 'DELTA SALT CAVERN STORAGE FIELD', 'DEVILS PLAYGROUND': \"DEVIL'S PLAYGROUND FIELD\", 'DRY BURN': 'DRY BURN FIELD',\r\n                             'EAST CANYON': 'EAST CANYON FIELD', 'EVACUATION CREEK': 'EVACUATION CREEK FIELD', 'FARMINGTON': 'FARMINGTON FIELD', 'GRASSY TRAIL': 'GRASSY TRAIL FIELD', 'GRAYSON': 'GRAYSON FIELD', 'GUSHER': 'GUSHER FIELD', 'HATCH': 'HATCH FIELD', \"HELL'S HOLE\": \"HELL'S HOLE FIELD\", 'HELPER': 'HELPER FIELD', 'HORSE CANYON': 'HORSE CANYON FIELD', 'INDEPENDENCE': 'INDEPENDENCE FIELD', 'KACHINA': 'KACHINA FIELD', 'KICKER': 'KICKER FIELD', 'LIGHTNING DRAW': 'LIGHTNING DRAW FIELD',\r\n                             'LION MESA': 'LION MESA FIELD', 'LISBON': 'LISBON FIELD', 'MC CRACKEN SPRING': 'MCCRACKEN SPRING FIELD', 'MOAB GAS STORAGE': 'MOAB GAS STORAGE', 'MONUMENT': 'MONUMENT FIELD', 'MONUMENT BUTTE': 'MONUMENT BUTTE FIELD', 'MUSTANG FLAT': 'MUSTANG FLAT FIELD', 'NATURAL BUTTES': 'NATURAL BUTTES FIELD', 'NINE MILE CANYON': 'NINE MILE CANYON FIELD', 'NORTH BONANZA': 'NORTH BONANZA FIELD', 'PAIUTE KNOLL': 'PAIUTE KNOLL FIELD', 'PEAR PARK': 'PEAR PARK FIELD',\r\n                             'POWDER SPRINGS': 'POWDER SPRINGS FIELD', 'RAT HOLE CANYON': 'RAT HOLE CANYON FIELD', 'RECAPTURE CREEK': 'RECAPTURE CREEK FIELD', 'ROCKWELL FLAT': 'ROCKWELL FLAT FIELD', 'SAN ARROYO': 'SAN ARROYO FIELD', 'SEEP RIDGE': 'SEEP RIDGE FIELD', 'SHUMWAY POINT': 'SHUMWAY POINT FIELD', 'SODA SPRING': 'SODA SPRING FIELD', 'SOLDIER CREEK': 'SOLDIER CREEK FIELD', 'SOUTH ISMAY': 'SOUTH ISMAY FIELD', 'SOWERS CANYON': 'SOWER CANYON FIELD', 'STONE CABIN': 'STONE CABIN FIELD',\r\n                             'SWEETWATER CYN': 'SWEETWATER CANYON FIELD', 'TIN CUP MESA': 'TIN CUP MESA FIELD', 'TOWER': 'TOWER FIELD', 'TURNER BLUFF': 'TURNER BLUFF FIELD', 'VIRGIN': 'VIRGIN FIELD', 'WHITE RIVER': 'WHITE RIVER FIELD', 'WINTER CAMP': 'WINTER CAMP FIELD', 'ALGER PASS': 'ALGER PASS FIELD', 'ALKALI POINT': 'ALKALI POINT FIELD', 'ANIDO CREEK': 'ANIDO CREEK FIELD', 'ASPHALT WASH': 'ASPHALT WASH FIELD', 'ATCHEE RIDGE': 'ATCHEE RIDGE FIELD', 'BANNOCK': 'BANNOCK FIELD',\r\n                             'BIG SPRING': 'BIG SPRING FIELD', 'BITTER CREEK': 'BITTER CREEK FIELD', 'BLACK BULL': 'BLACK BULL FIELD', 'BLACK HORSE CYN': 'BLACK HORSE CANYON FIELD', 'BOOK CLIFFS': 'BOOK CLIFFS FIELD', 'BRENNAN BOTTOM': 'BRENNAN BOTTOM FIELD', 'BROKEN HILLS': 'BROKEN HILLS FIELD', 'BRONCO': 'BRONCO FIELD', 'BRYSON CANYON': 'BRYSON CANYON FIELD', 'CAJON LAKE': 'CAJON LAKE FIELD', 'CANE CREEK': 'KANE CREEK FIELD', 'CASA MESA': 'CASA MESA FIELD',\r\n                             'CHALK CREEK GAS STORAGE': 'CHALK CREEK GAS STORAGE', 'COTTONWOOD WASH': 'COTTONWOOD WASH FIELD', 'CROOKED CANYON': 'CROOKED CANYON FIELD', 'DUCHESNE': 'DUCHESNE FIELD', 'FLAT CANYON': 'FLAT CANYON FIELD', 'GATE CANYON': 'GATE CANYON FIELD', 'GORDON CREEK': 'GORDON CREEK FIELD', 'GOTHIC MESA': 'GOTHIC MESA FIELD', 'GYPSUM HILLS': 'GYPSUM HILLS FIELD', 'HELL ROARING': 'HELL ROARING FIELD', 'HERON': 'HERON FIELD', 'HILL CREEK': 'HILL CREEK FIELD',\r\n                             'HORSE POINT': 'HORSE POINT FIELD', \"JOE'S VALLEY\": \"JOE'S VALLEY FIELD\", 'KENNEDY WASH': 'KENNEDY WASH FIELD', 'LIGHTNING DRAW SE': 'LIGHTNING DRAW FIELD', 'LITTLE NANCY': 'LITTLE NANCY FIELD', 'LITTLE VALLEY': 'LITTLE VALLEY FIELD', 'LONE SPRING': 'LONE SPRING FIELD', 'LONG CANYON': 'LONG CANYON FIELD', 'MIDDLE BENCH': 'MIDDLE BENCH FIELD', 'MOON RIDGE': 'MOON RIDGE FIELD', 'NAVAL RESERVE': 'NAVAL RESERVE FIELD', 'PETERSON SPRING': 'PETERSON SPRINGS FIELD',\r\n                             'PLEASANT VALLEY': 'PLEASANT VALLEY FIELD', 'RED WASH': 'RED WASH FIELD', 'SALT WASH': 'SALT WASH FIELD', 'SCOFIELD': 'UCOLO FIELD', 'SHAFER CANYON': 'SHAFER CANYON FIELD', 'SOUTH CANYON': 'SOUTH CANYON FIELD', 'SOUTH MYTON BENCH': 'NORTH MYTON BENCH', 'SQUAW POINT': 'SQUAW POINT FIELD', 'WALKER HOLLOW': 'WALKER HOLLOW FIELD', 'WESTWATER': 'WESTWATER FIELD', 'WHITEBELLY WASH': 'WHITEBELLY WASH FIELD', 'YELLOW ROCK': 'YELLOW ROCK FIELD',\r\n                             'AGENCY DRAW WEST': 'AGENCY DRAW WEST FIELD', 'ANSCHUTZ RANCH': 'ANSCHUTZ RANCH FIELD', 'ANSCHUTZ RANCH EAST': 'ANSCHUTZ RANCH EAST FIELD', 'ASHLEY VALLEY': 'ASHLEY VALLEY FIELD', 'BIG INDIAN NORTH': 'BIG INDIAN (NORTH) FIELD', 'BLAZE CANYON': 'BLAZE CANYON FIELD', 'CAJON MESA': 'CAJON MESA FIELD', 'CASTLEGATE': 'CASTLEGATE FIELD', 'CAVE CANYON': 'CAVE CANYON FIELD', 'CAVE CREEK': 'CAVE CREEK FIELD', 'CEDAR RIM': 'CEDAR RIM FIELD',\r\n                             'COALVILLE GAS STORAGE': 'COALVILLE GAS STORAGE', 'COYOTE BASIN': 'COYOTE BASIN FIELD', 'DIAMOND RIDGE': 'DIAMOND RIDGE FIELD', 'DRUNKARDS WASH': 'DRUNKARDS WASH FIELD', 'EIGHT MILE FLAT': 'EIGHT MILE FLAT FIELD', 'FERRON': 'FERRON FIELD', 'FIRTH': 'FIRTH FIELD', 'FLAT ROCK': 'FLAT ROCK FIELD', 'GREATER ANETH': 'GREATER ANETH FIELD', 'GREENTOWN': 'GREENTOWN FIELD', 'INDIAN CANYON': 'INDIAN CANYON FIELD', 'ISMAY': 'ISMAY FIELD',\r\n                             'LEFT HAND CYN': 'LEFT HAND CANYON FIELD', 'LELAND BENCH': 'LELAND BENCH FIELD', 'MATHEWS': 'MATHEWS FIELD', 'MEXICAN HAT': 'MEXICAN HAT FIELD', 'MIDDLE CANYON (DKTA)': 'MIDDLE CANYON FIELD', 'MILLER CREEK': 'MILLER CREEK FIELD', 'MOFFAT CANAL': 'MOFFAT CANAL FIELD', 'NORTH PINEVIEW': 'NORTH PINEVIEW FIELD', 'OIL SPRINGS': 'OIL SPRINGS FIELD', 'PATTERSON CANYON': 'PATTERSON CANYON FIELD', 'PINE SPRINGS': 'PINE SPRINGS FIELD', 'PINEVIEW': 'PINEVIEW FIELD',\r\n                             'PROVIDENCE': 'PROVIDENCE FIELD', 'RECAPTURE POCKET': 'RECAPTURE POCKET FIELD', 'RIVER BANK': 'RIVER BANK FIELD', 'ROAD CANYON': 'ROAD CANYON FIELD', 'ROZEL POINT': 'ROZEL POINT FIELD', 'SEEP RIDGE B (DKTA)': 'SEEP RIDGE B FIELD', 'SQUAW CANYON': 'SQUAW CANYON FIELD', 'STARR FLAT': 'STARR FLAT FIELD', 'STATELINE': 'STATE LINE FIELD', 'TEN MILE': 'TEN MILE FIELD', 'THREE RIVERS': 'THREE RIVERS FIELD', 'UPPER VALLEY': 'UPPER VALLEY FIELD',\r\n                             'WEST WILLOW CREEK': 'WEST WILLOW CREEK FIELD', 'WHISKEY CREEK': 'WHISKEY CREEK FIELD', 'WILSON CANYON': 'WILSON CANYON FIELD', 'WOLF POINT': 'WOLF POINT FIELD', 'TABYAGO': 'TABYAGO CANYON FIELD', 'KIVA': 'KIVA FIELD', 'AKAH': 'AKAH FIELD', 'BUG': 'BUG FIELD', 'LOVE': 'LOVE FIELD', '12 MILE WASH': 'TWELVE MILE WASH FIELD'}\r\n\r\n        # Define month name to number mapping\r\n        month_dict: Dict[str, int] = {\r\n            'January': 1, 'February': 2, 'March': 3, 'April': 4,\r\n            'May': 5, 'June': 6, 'July': 7, 'August': 8,\r\n            'September': 9, 'October': 10, 'November': 11, 'December': 12\r\n        }\r\n\r\n        # Load and initial processing of well data\r\n        well_df = read_sql('select * from WellInfo', self.conn_db)\r\n        well_df = well_df.rename(columns={'entityname': 'Operator'})\r\n\r\n        # Remove plugged wells and duplicates\r\n        well_df = well_df[well_df['work_type'] != 'PLUG']\r\n        well_df.drop_duplicates(keep='first', inplace=True)\r\n\r\n        # Create display names for wells\r\n        well_df['display_name'] = well_df['well_id'].astype(str) + ' - ' + well_df['well_name'].astype(str)\r\n        # Process dates and calculate well age\r\n        well_df['dry_spud'] = to_datetime(well_df['dry_spud'])\r\n        well_df['well_age'] = (datetime.now().year - well_df['dry_spud'].dt.year) * 12 + datetime.now().month - \\\r\n                                  well_df['dry_spud'].dt.month\r\n        well_df['dry_spud'] = well_df['dry_spud'].dt.strftime('%Y-%m-%d')\r\n\r\n        # Set well age to 0 for approved permits without spud dates\r\n        condition = pd.isna(well_df['well_age']) & (well_df['current_well_status'] == 'Approved Permit')\r\n        well_df.loc[condition, 'well_age'] = 0\r\n\r\n        # Sort by month and year\r\n        well_df['month_order'] = well_df['docket_month'].map(month_dict)\r\n        df_sorted = well_df.sort_values(by=['board_year', 'month_order'])\r\n        well_df = df_sorted.drop('month_order', axis=1)\r\n\r\n        # Standardize field names\r\n        well_df['field_name'] = well_df['field_name'].map(translated_fields)\r\n\r\n        # Return unique wells only\r\n        well_data_unique_df = well_df.drop_duplicates(subset=['well_id'])\r\n        return well_data_unique_df, well_df\r\n\r\n    def load_well_data(self, well_data_unique_df: DataFrame):\r\n        \"\"\"Loads and processes well directional survey data, merging it with unique well information\r\n        and performing necessary coordinate and elevation calculations.\r\n\r\n        This method queries the DX table, merges it with well-specific data, and performs various\r\n        data transformations including elevation calculations and coordinate conversions.\r\n\r\n        Args:\r\n            well_data_unique_df (DataFrame): DataFrame containing unique well records with columns:\r\n                - WellID: Well identifier\r\n                - Elevation: Surface elevation of well\r\n                - FieldName: Name of the oil/gas field\r\n                - Mineral Lease: Associated mineral lease information\r\n                - ConcCode: Concentration code\r\n\r\n        Notes:\r\n            - Updates several class attributes including self.dx_df and self.df_shl\r\n            - Performs coordinate conversions from meters to state plane (feet)\r\n            - Adjusts vertical well coordinates slightly to enable linestring creation\r\n            - All depth and elevation calculations are in consistent units (feet)\r\n\r\n        Side Effects:\r\n            - Modifies self.dx_df: Main directional survey DataFrame\r\n            - Creates self.df_shl: Surface hole location DataFrame\r\n        \"\"\"\r\n        # Load directional survey data and remove duplicates\r\n        dx_df = read_sql('select * from DX', self.conn_db)\r\n        dx_df.drop_duplicates(keep='first', inplace=True)\r\n        # Merge directional survey data with well-specific information\r\n        dx_df = pd.merge(\r\n            dx_df,\r\n            well_data_unique_df[['well_id', 'elevation', 'field_name', 'mineral_lease', 'conc_code']],\r\n            how='left',\r\n            left_on='apinumber',\r\n            right_on='well_id'\r\n        )\r\n\r\n        # Convert coordinate columns to float type\r\n        dx_df['x'] = dx_df['x'].astype(float)\r\n        dx_df['y'] = dx_df['y'].astype(float)\r\n\r\n        # Calculate true elevation relative to well head elevation\r\n        dx_df['true_elevation'] = dx_df['elevation'] - to_numeric(dx_df['true_vertical_depth'],\r\n                                                                           errors='coerce')\r\n        dx_df['measured_depth'] = to_numeric(dx_df['measured_depth'], errors='coerce')\r\n\r\n        # Standardize citing type to lowercase\r\n        dx_df['citing_type'] = dx_df['citing_type'].str.lower()\r\n\r\n        # Adjust Y coordinates for vertical wells to create valid linestrings\r\n        # Adds small incremental offset (0.001) to Y coordinate for each point\r\n        dx_df.loc[dx_df['citing_type'] == 'vertical', 'y'] += dx_df.groupby(['x', 'y']).cumcount() * 1e-3\r\n\r\n        # Convert coordinates to state plane (meters to feet)\r\n        dx_df['spx'] = dx_df['x'].astype(float) / 0.3048  # Convert meters to feet\r\n        dx_df['spx'] = dx_df['y'].astype(float) / 0.3048  # Convert meters to feet\r\n\r\n        # Sort data by well ID and measured depth\r\n        dx_df = dx_df.sort_values(by=['well_id', 'measured_depth'])\r\n\r\n        # Create surface hole location DataFrame from first point of each well\r\n        df_shl = dx_df.groupby('well_id').first().reset_index()\r\n        return dx_df, df_shl\r\n\r\n    def setup_tables(self) -> None:\r\n        \"\"\"Initializes UI tables with empty QTableWidgetItems for data display.\r\n\r\n        Creates and sets up the initial state of three well data tables and one\r\n        board data table in the user interface. Each table is populated with empty\r\n        QTableWidgetItem instances to prepare for later data insertion.\r\n\r\n        Table Structure:\r\n            - Well Data Tables (3):\r\n                - 1 row x 12 columns each\r\n                - All cells initialized as empty\r\n            - Board Data Table:\r\n                - 3 rows x 1 column\r\n                - All cells initialized as empty\r\n\r\n        Side Effects:\r\n            Modifies the following UI components:\r\n            - self.ui.well_data_table_1\r\n            - self.ui.well_data_table_2\r\n            - self.ui.well_data_table_3\r\n            - self.ui.board_data_table\r\n\r\n        Note:\r\n            This method should be called once during UI initialization before\r\n            any data population occurs.\r\n\r\n        Raises:\r\n            AttributeError: If any of the required UI table widgets are not properly initialized.\r\n        \"\"\"\r\n        # Initialize list of well data tables for batch processing\r\n        well_tables: List[QTableWidget] = [\r\n            self.ui.well_data_table_1,\r\n            self.ui.well_data_table_2,\r\n            self.ui.well_data_table_3\r\n        ]\r\n\r\n        # Initialize all well data tables (12 columns x 1 row each)\r\n        for table in well_tables:  # type: QTableWidget\r\n            for column in range(12):  # Create empty cells across all columns\r\n                empty_item = QTableWidgetItem()  # Create empty cell\r\n                table.setItem(0, column, empty_item)  # Set cell in first row\r\n\r\n        # Initialize board data table (1 column x 3 rows)\r\n        for row in range(3):  # Create empty cells down first column\r\n            empty_item = QTableWidgetItem()  # Create empty cell\r\n            self.ui.board_data_table.setItem(row, 0, empty_item)  # Set cell in first column\r\n\r\ndef except_hook(cls, exception, traceback):\r\n    sys.__excepthook__(cls, exception, traceback)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    import sys\r\n    app = QApplication(sys.argv)\r\n    w = wellVisualizationProcess()\r\n    w.show()\r\n    sys.excepthook = except_hook\r\n    sys.exit(app.exec_())
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../main_process.py b/../main_process.py
--- a/../main_process.py	(revision 11c8d433909f415072d1821b99a7cb0108153144)
+++ b/../main_process.py	(date 1743025093720)
@@ -60,7 +60,7 @@
 import sqlite3
 from datetime import datetime
 from typing import Callable, Dict, List, Literal, NoReturn, Optional, Set, Tuple, Union
-
+import regex as re
 # Third-party imports - Core Data/Scientific
 import numpy as np
 from numpy import array, std
@@ -81,34 +81,23 @@
     QVBoxLayout, QWidget
 )
 
-# Third-party imports - Matplotlib
-import matplotlib.dates as mdates
-import matplotlib.pyplot as plt
-from matplotlib.axes import Axes
-from matplotlib.backend_bases import MouseEvent
-from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
-from matplotlib.collections import LineCollection, PatchCollection, PolyCollection
-from matplotlib.figure import Figure
-from matplotlib.lines import Line2D
-from matplotlib.patches import PathPatch, Polygon
-from matplotlib.text import Text
-from matplotlib.textpath import TextPath
-from matplotlib.ticker import FuncFormatter, ScalarFormatter
-from mpl_toolkits.mplot3d.art3d import Line3DCollection
-
-# Third-party imports - Geospatial
-from shapely import wkt
 from shapely.geometry import Point, Polygon
-from shapely.ops import unary_union
-
-# Third-party imports - Other
-import regex as re
-
 # Local application imports
 from WellVisualizerBoardMatters import BoardMattersVisualizer
 from WellVisualizationUI import Ui_Dialog
 from main_process_year import Year
 
+
+def convert_column(col):
+    # Insert underscore between lowercase and uppercase letters
+    col = re.sub(r'([a-z])([A-Z])', r'\1_\2', col)
+    # Replace spaces with underscores
+    col = col.replace(' ', '_')
+    # Remove parentheses
+    col = col.replace('(', '').replace(')', '')
+    return col.lower()
+
+
 class wellVisualizationProcess(QMainWindow):
     def __init__(self, flag=True):
         super().__init__()
@@ -155,9 +144,8 @@
     def do_this_when_year_combo_box_pressed(self, well_df):
         selected_year: str = self.ui.year_lst_combobox.currentText()
         df_year = well_df[well_df['board_year'] == selected_year]
-        year_obj = Year(ui=self.ui, year=selected_year, df_year=df_year, dx_df = self.dx_df)
+        year_obj = Year(ui=self.ui, year=selected_year, df_year=df_year, dx_df=self.dx_df)
 
-
     def load_data(self):
         # Load field and ownership base data
         df_field = read_sql('select * from Field', self.conn_db)
@@ -175,8 +163,8 @@
         self.df_adjacent_fields = df_adjacent_fields
         self.df_plat = df_plat
         self.df_adjacent_plats = df_adjacent_plats
-        self.well_data_unique_df = well_data_unique_df #dx_data_unique
-        self.well_df = well_df #dx_data
+        self.well_data_unique_df = well_data_unique_df  #dx_data_unique
+        self.well_df = well_df  #dx_data
         self.dx_df = dx_df
         self.df_shl = df_shl
         self.used_dockets = used_dockets
@@ -186,26 +174,24 @@
         self.df_field = df_field
         self.df_owner = df_owner
 
-
-
     def load_df_fields(self, df_field):
         # Initialize storage for adjacent field relationships
         adjacent_fields: List[Dict[str, str]] = []
         # Create point geometries for field locations
         df_field['geometry'] = df_field.apply(
-            lambda row: Point(row['easting'], row['northing']),
+            lambda row: Point(row['Easting'], row['Northing']),
             axis=1
         )
 
         # Extract relevant fields for polygon creation
-        used_fields = df_field[['field_name', 'easting', 'northing']]
+        used_fields = df_field[['Field_Name', 'Easting', 'Northing']]
 
         # Generate field polygons from coordinate groups
-        polygons = used_fields.groupby('field_name').apply(
-            lambda x: Polygon(zip(x['easting'], x['northing'])),
+        polygons = used_fields.groupby('Field_Name').apply(
+            lambda x: Polygon(zip(x['Easting'], x['Northing'])),
             include_groups=False
         ).reset_index()
-        polygons.columns = ['field_name', 'geometry']
+        polygons.columns = ['Field_Name', 'geometry']
 
         # Create GeoDataFrame with buffer zones
         gdf = gpd.GeoDataFrame(polygons, geometry='geometry')
@@ -214,16 +200,16 @@
         # Identify adjacent fields using spatial analysis
         for _, row in gdf.iterrows():
             # Find neighboring fields using buffer intersection
-            neighbors = gdf[gdf['buffer'].intersects(row['geometry'])]['field_name'].tolist()
-            neighbors.remove(row['field_name'])  # Remove self-reference
+            neighbors = gdf[gdf['buffer'].intersects(row['geometry'])]['Field_Name'].tolist()
+            neighbors.remove(row['Field_Name'])  # Remove self-reference
 
             # Create adjacency relationships
             adjacent_fields.extend([
-                {'field_name': row['field_name'], 'adjacent_Field_Name': neighbor}
+                {'Field_Name': row['Field_Name'], 'adjacent_Field_Name': neighbor}
                 for neighbor in neighbors
             ])
-        columns = [k for k,v in adjacent_fields[0].items()]
-        return pd.DataFrame(data = adjacent_fields, columns=columns)
+        columns = [k for k, v in adjacent_fields[0].items()]
+        return pd.DataFrame(data=adjacent_fields, columns=columns)
 
     def load_board_data(self):
         def translateNumberToDirection(variable, val):
@@ -234,13 +220,14 @@
                 'alignment': {'1': 'SE', '2': 'NE', '3': 'SW', '4': 'NW'}
             }
             return translations.get(variable, {}).get(val, val)
+
         def conc_code_maker(i):
             conc_code_merged = i[:6]
             conc_code_merged.iloc[2] = translateNumberToDirection('township',
-                                                                       str(conc_code_merged.iloc[2])).upper()
+                                                                  str(conc_code_merged.iloc[2])).upper()
             conc_code_merged.iloc[4] = translateNumberToDirection('rng', str(conc_code_merged.iloc[4])).upper()
             conc_code_merged.iloc[5] = translateNumberToDirection('baseline',
-                                                                       str(conc_code_merged.iloc[5])).upper()
+                                                                  str(conc_code_merged.iloc[5])).upper()
             conc_code_merged.iloc[0] = str(int(float(conc_code_merged.iloc[0]))).zfill(2)
             conc_code_merged.iloc[1] = str(int(float(conc_code_merged.iloc[1]))).zfill(2)
             conc_code_merged.iloc[3] = str(int(float(conc_code_merged.iloc[3]))).zfill(2)
@@ -250,11 +237,11 @@
         # Load board meeting records and associated links
         df_board_data = read_sql('select * from BoardData', self.conn_db)
         df_board_data_links = read_sql('select * from BoardDataLinks', self.conn_db)
-
+        df_board_data.columns = df_board_data.columns.str.lower()
         # Generate concatenated location codes using ModuleAgnostic translator
         df_board_data['conc'] = df_board_data[[
-            'sec', 'township', 'township_dir',
-            'range', 'range_dir', 'pm'
+            'sec', 'township', 'townshipdir',
+            'range', 'rangedir', 'pm'
         ]].apply(lambda x: conc_code_maker(x), axis=1)
         return df_board_data, df_board_data_links
 
@@ -262,6 +249,8 @@
         # Load raw plat data from database
         df_plat = read_sql('select * from PlatData', self.conn_db)
         df_adjacent_plats = read_sql('select * from Adjacent', self.conn_db)
+        df_plat.columns = df_plat.columns.str.lower()
+        df_adjacent_plats.columns = df_adjacent_plats.columns.str.lower()
 
         # Clean plat data by removing duplicates and invalid coordinates
         df_plat.drop_duplicates(keep='first', inplace=True)
@@ -276,7 +265,7 @@
             lambda row: Point(row['easting'], row['northing']),
             axis=1)
         return df_plat, df_adjacent_plats
-    
+
     def load_well_df_data(self):
         """
         Loads and processes directional well data from database, performing data cleanup
@@ -313,26 +302,167 @@
             - Sets well age to 0 for approved permits without spud dates
         """
         # Define field name translations for standardization
-        translated_fields: Dict[str, str] = {'AAGARD RANCH': 'AAGARD RANCH FIELD', 'ANDERSON JUNCTION': 'ANDERSON JUNCTION FIELD', 'ANSCHUTZ RANCH WEBER': 'ANSCHUTZ RANCH (WEBER) FIELD', 'BAR X': 'BAR X FIELD', 'BIG FLAT': 'BIG FLAT FIELD', 'BIG FLAT WEST': 'BIG FLAT WEST FIELD', 'BIG INDIAN SOUTH': 'BIG INDIAN (SOUTH) FIELD', 'BONANZA': 'BONANZA FIELD', 'BOUNDARY BUTTE': 'BOUNDARY BUTTE FIELD', 'BRADFORD CYN': 'BRADFORD CANYON FIELD', 'BUZZARD BENCH': 'BUZZARD BENCH FIELD', 'CABALLO': 'CABALLO FIELD',
-                             'CACTUS PARK': 'CACTUS PARK FIELD', 'CHOKECHERRY CYN': 'CHOKECHERRY CANYON FIELD', 'CLAY HILL': 'CLAY HILL FIELD', 'CLEAR CREEK': 'CLEAR CREEK FIELD', 'DARK CANYON': 'DARK CANYON FIELD', 'DESERT CREEK': 'DESERT CREEK FIELD', 'ELKHORN': 'ELKHORN FIELD', 'FARNHAM DOME': 'FARNHAM DOME FIELD', 'FENCE CANYON': 'FENCE CANYON FIELD', 'GREATER CISCO': 'GREATER CISCO FIELD', 'HALFWAY HOLLOW': 'HALFWAY HOLLOW FIELD', 'HATCH POINT': 'HATCH POINT FIELD', 'HOGAN': 'HOGAN FIELD',
-                             'HOGBACK RIDGE': 'HOGBACK RIDGE FIELD', 'HORSEHEAD POINT': 'HORSEHEAD POINT FIELD', 'HORSESHOE BEND': 'HORSESHOE BEND FIELD', 'ICE CANYON (DK-MR)': 'ICE CANYON FIELD', 'LAKE CANYON': 'LAKE CANYON FIELD', 'LAST CHANCE': 'LAST CHANCE FIELD', 'LODGEPOLE': 'LODGEPOLE FIELD', 'MAIN CANYON': 'MAIN CANYON FIELD', 'MANCOS FLAT': 'MANCOS FLAT FIELD', 'MCELMO MESA': 'MCELMO MESA FIELD', 'NAVAJO CANYON': 'NAVAJO CANYON FIELD', 'NORTH MYTON BENCH': 'NORTH MYTON BENCH',
-                             'PARIETTE BENCH': 'PARIETTE BENCH FIELD', 'PARK ROAD': 'PARK ROAD FIELD', 'PETERS POINT': 'PETERS POINT FIELD', 'PETES WASH': 'PETES WASH FIELD', 'RABBIT EARS': 'RABBIT EARS FIELD', 'RANDLETT': 'RANDLETT FIELD', 'ROBIDOUX': 'ROBIDOUX FIELD', 'ROCK HOUSE': 'ROCK HOUSE FIELD', 'RUNWAY': 'RUNWAY FIELD', 'SEGUNDO CANYON': 'SEGUNDO CANYON FIELD', 'SOUTH PINE RIDGE': 'SOUTH PINE RIDGE FIELD', 'STRAWBERRY': 'STRAWBERRY FIELD', 'SWEET WATER RIDGE': 'SWEETWATER RIDGE FIELD',
-                             'TOHONADLA': 'TOHONADLA FIELD', 'UCOLO': 'UCOLO FIELD', 'UTELAND BUTTE': 'UTELAND BUTTE FIELD', 'WHITE MESA': 'WHITE MESA FIELD', 'WILD STALLION': 'WILD STALLION FIELD', 'WINDY RIDGE': 'WINDY RIDGE FIELD', 'WONSITS VALLEY': 'WONSITS VALLEY FIELD', 'WOODSIDE': 'WOODSIDE FIELD', '8 MILE FLAT NORTH': 'EIGHT MILE FLAT NORTH FIELD', 'AGENCY DRAW': 'AGENCY DRAW FIELD', 'ALKALI CANYON': 'ALKALI CANYON FIELD', 'ALTAMONT': 'ALTAMONT FIELD', 'ANETH': 'ANETH FIELD',
-                             'ANTELOPE CREEK': 'ANTELOPE CREEK FIELD', 'BIG VALLEY': 'BIG VALLEY FIELD', 'BLUEBELL': 'BLUEBELL FIELD', 'BLUFF': 'BLUFF FIELD', 'BLUFF BENCH': 'BLUFF BENCH FIELD', 'BRIDGELAND': 'BRIDGELAND FIELD', 'BRIDGER LAKE': 'BRIDGER LAKE FIELD', 'BRUNDAGE CANYON': 'BRUNDAGE CANYON FIELD', 'BUCK CANYON': 'BUCK CANYON FIELD', 'BUSHY': 'BUSHY FIELD', 'CEDAR CAMP': 'CEDAR CAMP FIELD', 'CHEROKEE': 'CHEROKEE FIELD', 'CHINLE WASH': 'CHINLE WASH FIELD',
-                             'CISCO DOME': 'CISCO DOME FIELD', 'CLAY BASIN': 'CLAY BASIN FIELD', 'CLEFT': 'CLEFT FIELD', 'CONE ROCK': 'CONE ROCK FIELD', 'COVENANT': 'COVENANT FIELD', 'COWBOY': 'COWBOY FIELD', 'DAVIS CANYON': 'DAVIS CANYON FIELD', 'DEAD MAN CANYON': 'DEADMAN CANYON FIELD', 'DEADMAN-ISMY': 'DEADMAN (ISMAY) FIELD', 'DELTA SALT CAVERN STORAGE': 'DELTA SALT CAVERN STORAGE FIELD', 'DEVILS PLAYGROUND': "DEVIL'S PLAYGROUND FIELD", 'DRY BURN': 'DRY BURN FIELD',
-                             'EAST CANYON': 'EAST CANYON FIELD', 'EVACUATION CREEK': 'EVACUATION CREEK FIELD', 'FARMINGTON': 'FARMINGTON FIELD', 'GRASSY TRAIL': 'GRASSY TRAIL FIELD', 'GRAYSON': 'GRAYSON FIELD', 'GUSHER': 'GUSHER FIELD', 'HATCH': 'HATCH FIELD', "HELL'S HOLE": "HELL'S HOLE FIELD", 'HELPER': 'HELPER FIELD', 'HORSE CANYON': 'HORSE CANYON FIELD', 'INDEPENDENCE': 'INDEPENDENCE FIELD', 'KACHINA': 'KACHINA FIELD', 'KICKER': 'KICKER FIELD', 'LIGHTNING DRAW': 'LIGHTNING DRAW FIELD',
-                             'LION MESA': 'LION MESA FIELD', 'LISBON': 'LISBON FIELD', 'MC CRACKEN SPRING': 'MCCRACKEN SPRING FIELD', 'MOAB GAS STORAGE': 'MOAB GAS STORAGE', 'MONUMENT': 'MONUMENT FIELD', 'MONUMENT BUTTE': 'MONUMENT BUTTE FIELD', 'MUSTANG FLAT': 'MUSTANG FLAT FIELD', 'NATURAL BUTTES': 'NATURAL BUTTES FIELD', 'NINE MILE CANYON': 'NINE MILE CANYON FIELD', 'NORTH BONANZA': 'NORTH BONANZA FIELD', 'PAIUTE KNOLL': 'PAIUTE KNOLL FIELD', 'PEAR PARK': 'PEAR PARK FIELD',
-                             'POWDER SPRINGS': 'POWDER SPRINGS FIELD', 'RAT HOLE CANYON': 'RAT HOLE CANYON FIELD', 'RECAPTURE CREEK': 'RECAPTURE CREEK FIELD', 'ROCKWELL FLAT': 'ROCKWELL FLAT FIELD', 'SAN ARROYO': 'SAN ARROYO FIELD', 'SEEP RIDGE': 'SEEP RIDGE FIELD', 'SHUMWAY POINT': 'SHUMWAY POINT FIELD', 'SODA SPRING': 'SODA SPRING FIELD', 'SOLDIER CREEK': 'SOLDIER CREEK FIELD', 'SOUTH ISMAY': 'SOUTH ISMAY FIELD', 'SOWERS CANYON': 'SOWER CANYON FIELD', 'STONE CABIN': 'STONE CABIN FIELD',
-                             'SWEETWATER CYN': 'SWEETWATER CANYON FIELD', 'TIN CUP MESA': 'TIN CUP MESA FIELD', 'TOWER': 'TOWER FIELD', 'TURNER BLUFF': 'TURNER BLUFF FIELD', 'VIRGIN': 'VIRGIN FIELD', 'WHITE RIVER': 'WHITE RIVER FIELD', 'WINTER CAMP': 'WINTER CAMP FIELD', 'ALGER PASS': 'ALGER PASS FIELD', 'ALKALI POINT': 'ALKALI POINT FIELD', 'ANIDO CREEK': 'ANIDO CREEK FIELD', 'ASPHALT WASH': 'ASPHALT WASH FIELD', 'ATCHEE RIDGE': 'ATCHEE RIDGE FIELD', 'BANNOCK': 'BANNOCK FIELD',
-                             'BIG SPRING': 'BIG SPRING FIELD', 'BITTER CREEK': 'BITTER CREEK FIELD', 'BLACK BULL': 'BLACK BULL FIELD', 'BLACK HORSE CYN': 'BLACK HORSE CANYON FIELD', 'BOOK CLIFFS': 'BOOK CLIFFS FIELD', 'BRENNAN BOTTOM': 'BRENNAN BOTTOM FIELD', 'BROKEN HILLS': 'BROKEN HILLS FIELD', 'BRONCO': 'BRONCO FIELD', 'BRYSON CANYON': 'BRYSON CANYON FIELD', 'CAJON LAKE': 'CAJON LAKE FIELD', 'CANE CREEK': 'KANE CREEK FIELD', 'CASA MESA': 'CASA MESA FIELD',
-                             'CHALK CREEK GAS STORAGE': 'CHALK CREEK GAS STORAGE', 'COTTONWOOD WASH': 'COTTONWOOD WASH FIELD', 'CROOKED CANYON': 'CROOKED CANYON FIELD', 'DUCHESNE': 'DUCHESNE FIELD', 'FLAT CANYON': 'FLAT CANYON FIELD', 'GATE CANYON': 'GATE CANYON FIELD', 'GORDON CREEK': 'GORDON CREEK FIELD', 'GOTHIC MESA': 'GOTHIC MESA FIELD', 'GYPSUM HILLS': 'GYPSUM HILLS FIELD', 'HELL ROARING': 'HELL ROARING FIELD', 'HERON': 'HERON FIELD', 'HILL CREEK': 'HILL CREEK FIELD',
-                             'HORSE POINT': 'HORSE POINT FIELD', "JOE'S VALLEY": "JOE'S VALLEY FIELD", 'KENNEDY WASH': 'KENNEDY WASH FIELD', 'LIGHTNING DRAW SE': 'LIGHTNING DRAW FIELD', 'LITTLE NANCY': 'LITTLE NANCY FIELD', 'LITTLE VALLEY': 'LITTLE VALLEY FIELD', 'LONE SPRING': 'LONE SPRING FIELD', 'LONG CANYON': 'LONG CANYON FIELD', 'MIDDLE BENCH': 'MIDDLE BENCH FIELD', 'MOON RIDGE': 'MOON RIDGE FIELD', 'NAVAL RESERVE': 'NAVAL RESERVE FIELD', 'PETERSON SPRING': 'PETERSON SPRINGS FIELD',
-                             'PLEASANT VALLEY': 'PLEASANT VALLEY FIELD', 'RED WASH': 'RED WASH FIELD', 'SALT WASH': 'SALT WASH FIELD', 'SCOFIELD': 'UCOLO FIELD', 'SHAFER CANYON': 'SHAFER CANYON FIELD', 'SOUTH CANYON': 'SOUTH CANYON FIELD', 'SOUTH MYTON BENCH': 'NORTH MYTON BENCH', 'SQUAW POINT': 'SQUAW POINT FIELD', 'WALKER HOLLOW': 'WALKER HOLLOW FIELD', 'WESTWATER': 'WESTWATER FIELD', 'WHITEBELLY WASH': 'WHITEBELLY WASH FIELD', 'YELLOW ROCK': 'YELLOW ROCK FIELD',
-                             'AGENCY DRAW WEST': 'AGENCY DRAW WEST FIELD', 'ANSCHUTZ RANCH': 'ANSCHUTZ RANCH FIELD', 'ANSCHUTZ RANCH EAST': 'ANSCHUTZ RANCH EAST FIELD', 'ASHLEY VALLEY': 'ASHLEY VALLEY FIELD', 'BIG INDIAN NORTH': 'BIG INDIAN (NORTH) FIELD', 'BLAZE CANYON': 'BLAZE CANYON FIELD', 'CAJON MESA': 'CAJON MESA FIELD', 'CASTLEGATE': 'CASTLEGATE FIELD', 'CAVE CANYON': 'CAVE CANYON FIELD', 'CAVE CREEK': 'CAVE CREEK FIELD', 'CEDAR RIM': 'CEDAR RIM FIELD',
-                             'COALVILLE GAS STORAGE': 'COALVILLE GAS STORAGE', 'COYOTE BASIN': 'COYOTE BASIN FIELD', 'DIAMOND RIDGE': 'DIAMOND RIDGE FIELD', 'DRUNKARDS WASH': 'DRUNKARDS WASH FIELD', 'EIGHT MILE FLAT': 'EIGHT MILE FLAT FIELD', 'FERRON': 'FERRON FIELD', 'FIRTH': 'FIRTH FIELD', 'FLAT ROCK': 'FLAT ROCK FIELD', 'GREATER ANETH': 'GREATER ANETH FIELD', 'GREENTOWN': 'GREENTOWN FIELD', 'INDIAN CANYON': 'INDIAN CANYON FIELD', 'ISMAY': 'ISMAY FIELD',
-                             'LEFT HAND CYN': 'LEFT HAND CANYON FIELD', 'LELAND BENCH': 'LELAND BENCH FIELD', 'MATHEWS': 'MATHEWS FIELD', 'MEXICAN HAT': 'MEXICAN HAT FIELD', 'MIDDLE CANYON (DKTA)': 'MIDDLE CANYON FIELD', 'MILLER CREEK': 'MILLER CREEK FIELD', 'MOFFAT CANAL': 'MOFFAT CANAL FIELD', 'NORTH PINEVIEW': 'NORTH PINEVIEW FIELD', 'OIL SPRINGS': 'OIL SPRINGS FIELD', 'PATTERSON CANYON': 'PATTERSON CANYON FIELD', 'PINE SPRINGS': 'PINE SPRINGS FIELD', 'PINEVIEW': 'PINEVIEW FIELD',
-                             'PROVIDENCE': 'PROVIDENCE FIELD', 'RECAPTURE POCKET': 'RECAPTURE POCKET FIELD', 'RIVER BANK': 'RIVER BANK FIELD', 'ROAD CANYON': 'ROAD CANYON FIELD', 'ROZEL POINT': 'ROZEL POINT FIELD', 'SEEP RIDGE B (DKTA)': 'SEEP RIDGE B FIELD', 'SQUAW CANYON': 'SQUAW CANYON FIELD', 'STARR FLAT': 'STARR FLAT FIELD', 'STATELINE': 'STATE LINE FIELD', 'TEN MILE': 'TEN MILE FIELD', 'THREE RIVERS': 'THREE RIVERS FIELD', 'UPPER VALLEY': 'UPPER VALLEY FIELD',
-                             'WEST WILLOW CREEK': 'WEST WILLOW CREEK FIELD', 'WHISKEY CREEK': 'WHISKEY CREEK FIELD', 'WILSON CANYON': 'WILSON CANYON FIELD', 'WOLF POINT': 'WOLF POINT FIELD', 'TABYAGO': 'TABYAGO CANYON FIELD', 'KIVA': 'KIVA FIELD', 'AKAH': 'AKAH FIELD', 'BUG': 'BUG FIELD', 'LOVE': 'LOVE FIELD', '12 MILE WASH': 'TWELVE MILE WASH FIELD'}
+        translated_fields: Dict[str, str] = {'AAGARD RANCH': 'AAGARD RANCH FIELD',
+                                             'ANDERSON JUNCTION': 'ANDERSON JUNCTION FIELD',
+                                             'ANSCHUTZ RANCH WEBER': 'ANSCHUTZ RANCH (WEBER) FIELD',
+                                             'BAR X': 'BAR X FIELD', 'BIG FLAT': 'BIG FLAT FIELD',
+                                             'BIG FLAT WEST': 'BIG FLAT WEST FIELD',
+                                             'BIG INDIAN SOUTH': 'BIG INDIAN (SOUTH) FIELD', 'BONANZA': 'BONANZA FIELD',
+                                             'BOUNDARY BUTTE': 'BOUNDARY BUTTE FIELD',
+                                             'BRADFORD CYN': 'BRADFORD CANYON FIELD',
+                                             'BUZZARD BENCH': 'BUZZARD BENCH FIELD', 'CABALLO': 'CABALLO FIELD',
+                                             'CACTUS PARK': 'CACTUS PARK FIELD',
+                                             'CHOKECHERRY CYN': 'CHOKECHERRY CANYON FIELD',
+                                             'CLAY HILL': 'CLAY HILL FIELD', 'CLEAR CREEK': 'CLEAR CREEK FIELD',
+                                             'DARK CANYON': 'DARK CANYON FIELD', 'DESERT CREEK': 'DESERT CREEK FIELD',
+                                             'ELKHORN': 'ELKHORN FIELD', 'FARNHAM DOME': 'FARNHAM DOME FIELD',
+                                             'FENCE CANYON': 'FENCE CANYON FIELD',
+                                             'GREATER CISCO': 'GREATER CISCO FIELD',
+                                             'HALFWAY HOLLOW': 'HALFWAY HOLLOW FIELD',
+                                             'HATCH POINT': 'HATCH POINT FIELD', 'HOGAN': 'HOGAN FIELD',
+                                             'HOGBACK RIDGE': 'HOGBACK RIDGE FIELD',
+                                             'HORSEHEAD POINT': 'HORSEHEAD POINT FIELD',
+                                             'HORSESHOE BEND': 'HORSESHOE BEND FIELD',
+                                             'ICE CANYON (DK-MR)': 'ICE CANYON FIELD',
+                                             'LAKE CANYON': 'LAKE CANYON FIELD', 'LAST CHANCE': 'LAST CHANCE FIELD',
+                                             'LODGEPOLE': 'LODGEPOLE FIELD', 'MAIN CANYON': 'MAIN CANYON FIELD',
+                                             'MANCOS FLAT': 'MANCOS FLAT FIELD', 'MCELMO MESA': 'MCELMO MESA FIELD',
+                                             'NAVAJO CANYON': 'NAVAJO CANYON FIELD',
+                                             'NORTH MYTON BENCH': 'NORTH MYTON BENCH',
+                                             'PARIETTE BENCH': 'PARIETTE BENCH FIELD', 'PARK ROAD': 'PARK ROAD FIELD',
+                                             'PETERS POINT': 'PETERS POINT FIELD', 'PETES WASH': 'PETES WASH FIELD',
+                                             'RABBIT EARS': 'RABBIT EARS FIELD', 'RANDLETT': 'RANDLETT FIELD',
+                                             'ROBIDOUX': 'ROBIDOUX FIELD', 'ROCK HOUSE': 'ROCK HOUSE FIELD',
+                                             'RUNWAY': 'RUNWAY FIELD', 'SEGUNDO CANYON': 'SEGUNDO CANYON FIELD',
+                                             'SOUTH PINE RIDGE': 'SOUTH PINE RIDGE FIELD',
+                                             'STRAWBERRY': 'STRAWBERRY FIELD',
+                                             'SWEET WATER RIDGE': 'SWEETWATER RIDGE FIELD',
+                                             'TOHONADLA': 'TOHONADLA FIELD', 'UCOLO': 'UCOLO FIELD',
+                                             'UTELAND BUTTE': 'UTELAND BUTTE FIELD', 'WHITE MESA': 'WHITE MESA FIELD',
+                                             'WILD STALLION': 'WILD STALLION FIELD', 'WINDY RIDGE': 'WINDY RIDGE FIELD',
+                                             'WONSITS VALLEY': 'WONSITS VALLEY FIELD', 'WOODSIDE': 'WOODSIDE FIELD',
+                                             '8 MILE FLAT NORTH': 'EIGHT MILE FLAT NORTH FIELD',
+                                             'AGENCY DRAW': 'AGENCY DRAW FIELD', 'ALKALI CANYON': 'ALKALI CANYON FIELD',
+                                             'ALTAMONT': 'ALTAMONT FIELD', 'ANETH': 'ANETH FIELD',
+                                             'ANTELOPE CREEK': 'ANTELOPE CREEK FIELD', 'BIG VALLEY': 'BIG VALLEY FIELD',
+                                             'BLUEBELL': 'BLUEBELL FIELD', 'BLUFF': 'BLUFF FIELD',
+                                             'BLUFF BENCH': 'BLUFF BENCH FIELD', 'BRIDGELAND': 'BRIDGELAND FIELD',
+                                             'BRIDGER LAKE': 'BRIDGER LAKE FIELD',
+                                             'BRUNDAGE CANYON': 'BRUNDAGE CANYON FIELD',
+                                             'BUCK CANYON': 'BUCK CANYON FIELD', 'BUSHY': 'BUSHY FIELD',
+                                             'CEDAR CAMP': 'CEDAR CAMP FIELD', 'CHEROKEE': 'CHEROKEE FIELD',
+                                             'CHINLE WASH': 'CHINLE WASH FIELD',
+                                             'CISCO DOME': 'CISCO DOME FIELD', 'CLAY BASIN': 'CLAY BASIN FIELD',
+                                             'CLEFT': 'CLEFT FIELD', 'CONE ROCK': 'CONE ROCK FIELD',
+                                             'COVENANT': 'COVENANT FIELD', 'COWBOY': 'COWBOY FIELD',
+                                             'DAVIS CANYON': 'DAVIS CANYON FIELD',
+                                             'DEAD MAN CANYON': 'DEADMAN CANYON FIELD',
+                                             'DEADMAN-ISMY': 'DEADMAN (ISMAY) FIELD',
+                                             'DELTA SALT CAVERN STORAGE': 'DELTA SALT CAVERN STORAGE FIELD',
+                                             'DEVILS PLAYGROUND': "DEVIL'S PLAYGROUND FIELD",
+                                             'DRY BURN': 'DRY BURN FIELD',
+                                             'EAST CANYON': 'EAST CANYON FIELD',
+                                             'EVACUATION CREEK': 'EVACUATION CREEK FIELD',
+                                             'FARMINGTON': 'FARMINGTON FIELD', 'GRASSY TRAIL': 'GRASSY TRAIL FIELD',
+                                             'GRAYSON': 'GRAYSON FIELD', 'GUSHER': 'GUSHER FIELD',
+                                             'HATCH': 'HATCH FIELD', "HELL'S HOLE": "HELL'S HOLE FIELD",
+                                             'HELPER': 'HELPER FIELD', 'HORSE CANYON': 'HORSE CANYON FIELD',
+                                             'INDEPENDENCE': 'INDEPENDENCE FIELD', 'KACHINA': 'KACHINA FIELD',
+                                             'KICKER': 'KICKER FIELD', 'LIGHTNING DRAW': 'LIGHTNING DRAW FIELD',
+                                             'LION MESA': 'LION MESA FIELD', 'LISBON': 'LISBON FIELD',
+                                             'MC CRACKEN SPRING': 'MCCRACKEN SPRING FIELD',
+                                             'MOAB GAS STORAGE': 'MOAB GAS STORAGE', 'MONUMENT': 'MONUMENT FIELD',
+                                             'MONUMENT BUTTE': 'MONUMENT BUTTE FIELD',
+                                             'MUSTANG FLAT': 'MUSTANG FLAT FIELD',
+                                             'NATURAL BUTTES': 'NATURAL BUTTES FIELD',
+                                             'NINE MILE CANYON': 'NINE MILE CANYON FIELD',
+                                             'NORTH BONANZA': 'NORTH BONANZA FIELD',
+                                             'PAIUTE KNOLL': 'PAIUTE KNOLL FIELD', 'PEAR PARK': 'PEAR PARK FIELD',
+                                             'POWDER SPRINGS': 'POWDER SPRINGS FIELD',
+                                             'RAT HOLE CANYON': 'RAT HOLE CANYON FIELD',
+                                             'RECAPTURE CREEK': 'RECAPTURE CREEK FIELD',
+                                             'ROCKWELL FLAT': 'ROCKWELL FLAT FIELD', 'SAN ARROYO': 'SAN ARROYO FIELD',
+                                             'SEEP RIDGE': 'SEEP RIDGE FIELD', 'SHUMWAY POINT': 'SHUMWAY POINT FIELD',
+                                             'SODA SPRING': 'SODA SPRING FIELD', 'SOLDIER CREEK': 'SOLDIER CREEK FIELD',
+                                             'SOUTH ISMAY': 'SOUTH ISMAY FIELD', 'SOWERS CANYON': 'SOWER CANYON FIELD',
+                                             'STONE CABIN': 'STONE CABIN FIELD',
+                                             'SWEETWATER CYN': 'SWEETWATER CANYON FIELD',
+                                             'TIN CUP MESA': 'TIN CUP MESA FIELD', 'TOWER': 'TOWER FIELD',
+                                             'TURNER BLUFF': 'TURNER BLUFF FIELD', 'VIRGIN': 'VIRGIN FIELD',
+                                             'WHITE RIVER': 'WHITE RIVER FIELD', 'WINTER CAMP': 'WINTER CAMP FIELD',
+                                             'ALGER PASS': 'ALGER PASS FIELD', 'ALKALI POINT': 'ALKALI POINT FIELD',
+                                             'ANIDO CREEK': 'ANIDO CREEK FIELD', 'ASPHALT WASH': 'ASPHALT WASH FIELD',
+                                             'ATCHEE RIDGE': 'ATCHEE RIDGE FIELD', 'BANNOCK': 'BANNOCK FIELD',
+                                             'BIG SPRING': 'BIG SPRING FIELD', 'BITTER CREEK': 'BITTER CREEK FIELD',
+                                             'BLACK BULL': 'BLACK BULL FIELD',
+                                             'BLACK HORSE CYN': 'BLACK HORSE CANYON FIELD',
+                                             'BOOK CLIFFS': 'BOOK CLIFFS FIELD',
+                                             'BRENNAN BOTTOM': 'BRENNAN BOTTOM FIELD',
+                                             'BROKEN HILLS': 'BROKEN HILLS FIELD', 'BRONCO': 'BRONCO FIELD',
+                                             'BRYSON CANYON': 'BRYSON CANYON FIELD', 'CAJON LAKE': 'CAJON LAKE FIELD',
+                                             'CANE CREEK': 'KANE CREEK FIELD', 'CASA MESA': 'CASA MESA FIELD',
+                                             'CHALK CREEK GAS STORAGE': 'CHALK CREEK GAS STORAGE',
+                                             'COTTONWOOD WASH': 'COTTONWOOD WASH FIELD',
+                                             'CROOKED CANYON': 'CROOKED CANYON FIELD', 'DUCHESNE': 'DUCHESNE FIELD',
+                                             'FLAT CANYON': 'FLAT CANYON FIELD', 'GATE CANYON': 'GATE CANYON FIELD',
+                                             'GORDON CREEK': 'GORDON CREEK FIELD', 'GOTHIC MESA': 'GOTHIC MESA FIELD',
+                                             'GYPSUM HILLS': 'GYPSUM HILLS FIELD', 'HELL ROARING': 'HELL ROARING FIELD',
+                                             'HERON': 'HERON FIELD', 'HILL CREEK': 'HILL CREEK FIELD',
+                                             'HORSE POINT': 'HORSE POINT FIELD', "JOE'S VALLEY": "JOE'S VALLEY FIELD",
+                                             'KENNEDY WASH': 'KENNEDY WASH FIELD',
+                                             'LIGHTNING DRAW SE': 'LIGHTNING DRAW FIELD',
+                                             'LITTLE NANCY': 'LITTLE NANCY FIELD',
+                                             'LITTLE VALLEY': 'LITTLE VALLEY FIELD', 'LONE SPRING': 'LONE SPRING FIELD',
+                                             'LONG CANYON': 'LONG CANYON FIELD', 'MIDDLE BENCH': 'MIDDLE BENCH FIELD',
+                                             'MOON RIDGE': 'MOON RIDGE FIELD', 'NAVAL RESERVE': 'NAVAL RESERVE FIELD',
+                                             'PETERSON SPRING': 'PETERSON SPRINGS FIELD',
+                                             'PLEASANT VALLEY': 'PLEASANT VALLEY FIELD', 'RED WASH': 'RED WASH FIELD',
+                                             'SALT WASH': 'SALT WASH FIELD', 'SCOFIELD': 'UCOLO FIELD',
+                                             'SHAFER CANYON': 'SHAFER CANYON FIELD',
+                                             'SOUTH CANYON': 'SOUTH CANYON FIELD',
+                                             'SOUTH MYTON BENCH': 'NORTH MYTON BENCH',
+                                             'SQUAW POINT': 'SQUAW POINT FIELD', 'WALKER HOLLOW': 'WALKER HOLLOW FIELD',
+                                             'WESTWATER': 'WESTWATER FIELD', 'WHITEBELLY WASH': 'WHITEBELLY WASH FIELD',
+                                             'YELLOW ROCK': 'YELLOW ROCK FIELD',
+                                             'AGENCY DRAW WEST': 'AGENCY DRAW WEST FIELD',
+                                             'ANSCHUTZ RANCH': 'ANSCHUTZ RANCH FIELD',
+                                             'ANSCHUTZ RANCH EAST': 'ANSCHUTZ RANCH EAST FIELD',
+                                             'ASHLEY VALLEY': 'ASHLEY VALLEY FIELD',
+                                             'BIG INDIAN NORTH': 'BIG INDIAN (NORTH) FIELD',
+                                             'BLAZE CANYON': 'BLAZE CANYON FIELD', 'CAJON MESA': 'CAJON MESA FIELD',
+                                             'CASTLEGATE': 'CASTLEGATE FIELD', 'CAVE CANYON': 'CAVE CANYON FIELD',
+                                             'CAVE CREEK': 'CAVE CREEK FIELD', 'CEDAR RIM': 'CEDAR RIM FIELD',
+                                             'COALVILLE GAS STORAGE': 'COALVILLE GAS STORAGE',
+                                             'COYOTE BASIN': 'COYOTE BASIN FIELD',
+                                             'DIAMOND RIDGE': 'DIAMOND RIDGE FIELD',
+                                             'DRUNKARDS WASH': 'DRUNKARDS WASH FIELD',
+                                             'EIGHT MILE FLAT': 'EIGHT MILE FLAT FIELD', 'FERRON': 'FERRON FIELD',
+                                             'FIRTH': 'FIRTH FIELD', 'FLAT ROCK': 'FLAT ROCK FIELD',
+                                             'GREATER ANETH': 'GREATER ANETH FIELD', 'GREENTOWN': 'GREENTOWN FIELD',
+                                             'INDIAN CANYON': 'INDIAN CANYON FIELD', 'ISMAY': 'ISMAY FIELD',
+                                             'LEFT HAND CYN': 'LEFT HAND CANYON FIELD',
+                                             'LELAND BENCH': 'LELAND BENCH FIELD', 'MATHEWS': 'MATHEWS FIELD',
+                                             'MEXICAN HAT': 'MEXICAN HAT FIELD',
+                                             'MIDDLE CANYON (DKTA)': 'MIDDLE CANYON FIELD',
+                                             'MILLER CREEK': 'MILLER CREEK FIELD', 'MOFFAT CANAL': 'MOFFAT CANAL FIELD',
+                                             'NORTH PINEVIEW': 'NORTH PINEVIEW FIELD',
+                                             'OIL SPRINGS': 'OIL SPRINGS FIELD',
+                                             'PATTERSON CANYON': 'PATTERSON CANYON FIELD',
+                                             'PINE SPRINGS': 'PINE SPRINGS FIELD', 'PINEVIEW': 'PINEVIEW FIELD',
+                                             'PROVIDENCE': 'PROVIDENCE FIELD',
+                                             'RECAPTURE POCKET': 'RECAPTURE POCKET FIELD',
+                                             'RIVER BANK': 'RIVER BANK FIELD', 'ROAD CANYON': 'ROAD CANYON FIELD',
+                                             'ROZEL POINT': 'ROZEL POINT FIELD',
+                                             'SEEP RIDGE B (DKTA)': 'SEEP RIDGE B FIELD',
+                                             'SQUAW CANYON': 'SQUAW CANYON FIELD', 'STARR FLAT': 'STARR FLAT FIELD',
+                                             'STATELINE': 'STATE LINE FIELD', 'TEN MILE': 'TEN MILE FIELD',
+                                             'THREE RIVERS': 'THREE RIVERS FIELD', 'UPPER VALLEY': 'UPPER VALLEY FIELD',
+                                             'WEST WILLOW CREEK': 'WEST WILLOW CREEK FIELD',
+                                             'WHISKEY CREEK': 'WHISKEY CREEK FIELD',
+                                             'WILSON CANYON': 'WILSON CANYON FIELD', 'WOLF POINT': 'WOLF POINT FIELD',
+                                             'TABYAGO': 'TABYAGO CANYON FIELD', 'KIVA': 'KIVA FIELD',
+                                             'AKAH': 'AKAH FIELD', 'BUG': 'BUG FIELD', 'LOVE': 'LOVE FIELD',
+                                             '12 MILE WASH': 'TWELVE MILE WASH FIELD'}
 
         # Define month name to number mapping
         month_dict: Dict[str, int] = {
@@ -344,17 +474,16 @@
         # Load and initial processing of well data
         well_df = read_sql('select * from WellInfo', self.conn_db)
         well_df = well_df.rename(columns={'entityname': 'Operator'})
-
+        well_df.columns = [convert_column(c) for c in well_df.columns]
         # Remove plugged wells and duplicates
         well_df = well_df[well_df['work_type'] != 'PLUG']
         well_df.drop_duplicates(keep='first', inplace=True)
-
         # Create display names for wells
-        well_df['display_name'] = well_df['well_id'].astype(str) + ' - ' + well_df['well_name'].astype(str)
+        well_df['display_name'] = well_df['api_number'].astype(str) + ' - ' + well_df['well_name'].astype(str)
         # Process dates and calculate well age
         well_df['dry_spud'] = to_datetime(well_df['dry_spud'])
         well_df['well_age'] = (datetime.now().year - well_df['dry_spud'].dt.year) * 12 + datetime.now().month - \
-                                  well_df['dry_spud'].dt.month
+                              well_df['dry_spud'].dt.month
         well_df['dry_spud'] = well_df['dry_spud'].dt.strftime('%Y-%m-%d')
 
         # Set well age to 0 for approved permits without spud dates
@@ -370,7 +499,7 @@
         well_df['field_name'] = well_df['field_name'].map(translated_fields)
 
         # Return unique wells only
-        well_data_unique_df = well_df.drop_duplicates(subset=['well_id'])
+        well_data_unique_df = well_df.drop_duplicates(subset=['api_number'])
         return well_data_unique_df, well_df
 
     def load_well_data(self, well_data_unique_df: DataFrame):
@@ -400,14 +529,26 @@
         """
         # Load directional survey data and remove duplicates
         dx_df = read_sql('select * from DX', self.conn_db)
+
+        dx_df['citing_type'] = dx_df['citing_type'].fillna(dx_df['citing_type'])
+        # dx_df = dx_df.drop(['api_number','citing_type'], axis=1)
+
+
         dx_df.drop_duplicates(keep='first', inplace=True)
+
+        dx_df.columns = [convert_column(c) for c in dx_df.columns]
+        # print(dx_df)
+        # print(dx_df.columns)
+        # print(dx_df[dx_df['api_number'] == '4301353494'])
+        # print(well_data_unique_df[well_data_unique_df['api_number'] == '4301353494'])
+
         # Merge directional survey data with well-specific information
         dx_df = pd.merge(
             dx_df,
-            well_data_unique_df[['well_id', 'elevation', 'field_name', 'mineral_lease', 'conc_code']],
+            well_data_unique_df[['api_number', 'elevation', 'field_name', 'mineral_lease', 'conc_code']],
             how='left',
-            left_on='apinumber',
-            right_on='well_id'
+            left_on='api_number',
+            right_on='api_number'
         )
 
         # Convert coordinate columns to float type
@@ -416,25 +557,28 @@
 
         # Calculate true elevation relative to well head elevation
         dx_df['true_elevation'] = dx_df['elevation'] - to_numeric(dx_df['true_vertical_depth'],
-                                                                           errors='coerce')
+                                                                  errors='coerce')
         dx_df['measured_depth'] = to_numeric(dx_df['measured_depth'], errors='coerce')
-
         # Standardize citing type to lowercase
-        dx_df['citing_type'] = dx_df['citing_type'].str.lower()
+        # dx_df['citing_type'] = dx_df['citing_type'].str.lower()
 
         # Adjust Y coordinates for vertical wells to create valid linestrings
         # Adds small incremental offset (0.001) to Y coordinate for each point
-        dx_df.loc[dx_df['citing_type'] == 'vertical', 'y'] += dx_df.groupby(['x', 'y']).cumcount() * 1e-3
+        # dx_df.loc[dx_df['citing_type'] == 'vertical', 'y'] += dx_df.groupby(['x', 'y']).cumcount() * 1e-3
+        mask = dx_df['citing_type'] == 'vertical'
 
+        cum_counts = dx_df.groupby(['x', 'y']).cumcount() * 1e-3
+        dx_df.loc[mask, 'y'] = dx_df.loc[mask, 'y'] + cum_counts[mask]
         # Convert coordinates to state plane (meters to feet)
         dx_df['spx'] = dx_df['x'].astype(float) / 0.3048  # Convert meters to feet
-        dx_df['spx'] = dx_df['y'].astype(float) / 0.3048  # Convert meters to feet
+        dx_df['spy'] = dx_df['y'].astype(float) / 0.3048  # Convert meters to feet
 
         # Sort data by well ID and measured depth
-        dx_df = dx_df.sort_values(by=['well_id', 'measured_depth'])
+        dx_df = dx_df.sort_values(by=['api_number', 'measured_depth'])
 
         # Create surface hole location DataFrame from first point of each well
-        df_shl = dx_df.groupby('well_id').first().reset_index()
+        df_shl = dx_df.groupby('api_number').first().reset_index()
+
         return dx_df, df_shl
 
     def setup_tables(self) -> None:
@@ -484,14 +628,16 @@
             empty_item = QTableWidgetItem()  # Create empty cell
             self.ui.board_data_table.setItem(row, 0, empty_item)  # Set cell in first column
 
+
 def except_hook(cls, exception, traceback):
     sys.__excepthook__(cls, exception, traceback)
 
 
 if __name__ == "__main__":
     import sys
+
     app = QApplication(sys.argv)
     w = wellVisualizationProcess()
     w.show()
     sys.excepthook = except_hook
-    sys.exit(app.exec_())
\ No newline at end of file
+    sys.exit(app.exec_())
Index: ../main_process_well.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nWellVisualizerMain.py\r\nAuthor: Colton Goodrich\r\nDate: 11/10/2024\r\nPython Version: 3.12\r\nThis module is a PyQt5 application that provides a graphical user interface (GUI) for\r\nvisualizing and analyzing well data, board matters, and related information from the\r\nState of Utah, Division of Oil, Gas, and Mining.\r\n\r\nThe application features various functionalities, including:\r\n\r\n- Interactive visualization of well trajectories in both 2D and 3D views, including\r\n  planned, currently drilling, and completed wells\r\n- Real-time well path visualization with different line styles for different well states\r\n  (planned: dashed, drilling: solid, completed: solid)\r\n- Advanced filtering system for wells based on type (oil, gas, water disposal, dry hole,\r\n  injection) and status (shut-in, PA, producing, drilling)\r\n- Mineral ownership visualization with section-level detail and agency tracking\r\n- Dynamic operator filtering system with color-coded checkboxes and scrollable interfaces\r\n- Production data visualization with cumulative and time-series analysis\r\n- Field boundary and plat code visualization with centroid labeling\r\n- Interactive well selection system with detailed data display\r\n- Customizable visualization features including zoom, pan, and scale adjustment\r\n\r\nClasses:\r\n- MultiBoldRowDelegate: A custom delegate for applying bold formatting to specific rows\r\n  in Qt views, particularly useful for emphasizing important wells\r\n- BoldDelegate: A custom delegate for applying bold formatting to specific values in\r\n  Qt views\r\n- wellVisualizationProcess: The main application class that inherits from QMainWindow\r\n  and BoardMattersVisualizer, handling all core functionality\r\n\r\nKey Components:\r\n- Data Management: Utilizes Pandas, GeoPandas, and SQLite for efficient data handling\r\n- Visualization: Combines Matplotlib with PyQt5 for interactive plotting\r\n- Geospatial Processing: Integrates UTM and Shapely for coordinate transformations\r\n  and geometric operations\r\n- User Interface: Custom-designed PyQt5 interface with scrollable areas and\r\n  dynamic updates\r\n\r\nThe module serves as a comprehensive tool for analyzing and visualizing well data,\r\nproviding detailed insights into well operations, ownership, and regulatory matters\r\nfor the State of Utah's Division of Oil, Gas, and Mining operations.\r\n\r\nDependencies:\r\n- Core Scientific: numpy, pandas, geopandas\r\n- GUI Framework: PyQt5\r\n- Visualization: matplotlib\r\n- Geospatial: shapely, utm\r\n- Database: sqlite3, sqlalchemy\r\n- Utility: regex\r\n\r\nNote: This application requires specific data structures and database connectivity\r\nto function properly. See accompanying documentation for setup requirements.\r\n\"\"\"\r\n\r\n# Python standard library imports\r\nimport itertools\r\nimport os\r\nimport sqlite3\r\nfrom datetime import datetime\r\nfrom typing import Callable, Dict, List, Literal, NoReturn, Optional, Set, Tuple, Union\r\n\r\n# Third-party imports - Core Data/Scientific\r\nimport numpy as np\r\nfrom numpy import array, std\r\nimport pandas as pd\r\nfrom pandas import DataFrame, concat, options, read_sql, set_option, to_datetime, to_numeric\r\nimport geopandas as gpd\r\nimport utm\r\nfrom sqlalchemy import create_engine\r\n\r\n# Third-party imports - PyQt5\r\nimport PyQt5\r\nfrom PyQt5.QtCore import QAbstractItemModel, QModelIndex, Qt\r\nfrom PyQt5.QtGui import QColor, QStandardItem, QStandardItemModel\r\nfrom PyQt5.QtWidgets import (\r\n    QApplication, QCheckBox, QGraphicsDropShadowEffect, QHeaderView,\r\n    QHBoxLayout, QLabel, QLayout, QMainWindow, QScrollArea,\r\n    QStyledItemDelegate, QTableWidget, QTableWidgetItem,\r\n    QVBoxLayout, QWidget\r\n)\r\n\r\n# Third-party imports - Matplotlib\r\nimport matplotlib.dates as mdates\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.axes import Axes\r\nfrom matplotlib.backend_bases import MouseEvent\r\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\r\nfrom matplotlib.collections import LineCollection, PatchCollection, PolyCollection\r\nfrom matplotlib.figure import Figure\r\nfrom matplotlib.lines import Line2D\r\nfrom matplotlib.patches import PathPatch, Polygon\r\nfrom matplotlib.text import Text\r\nfrom matplotlib.textpath import TextPath\r\nfrom matplotlib.ticker import FuncFormatter, ScalarFormatter\r\nfrom mpl_toolkits.mplot3d.art3d import Line3DCollection\r\n\r\n# Third-party imports - Geospatial\r\nfrom shapely import wkt\r\nfrom shapely.geometry import Point, Polygon\r\nfrom shapely.ops import unary_union\r\n\r\n# Third-party imports - Other\r\nimport regex as re\r\n\r\n# Local application imports\r\nfrom WellVisualizerBoardMatters import BoardMattersVisualizer\r\nfrom WellVisualizationUI import Ui_Dialog\r\nfrom PyQt5.QtWidgets import QMainWindow, QApplication, QStyledItemDelegate, QHeaderView, QAbstractItemView, QWidget, QApplication, QMainWindow, QVBoxLayout, QWidget, QSizePolicy\r\n\r\nclass MultiBoldRowDelegate(QStyledItemDelegate):\r\n    \"\"\"\r\n    A custom delegate class that applies bold formatting to specific rows in a Qt view.\r\n\r\n    This delegate allows you to specify certain rows that should be displayed in bold.\r\n    It's particularly useful when you want to emphasize specific rows in a QTableView\r\n    or QListView.\r\n\r\n    Attributes:\r\n        bold_rows (set): A set containing the row indices that should be bold.\r\n\r\n    Args:\r\n        bold_rows (list or set): The row indices that should be displayed in bold.\r\n        parent (QObject, optional): The parent object. Defaults to None.\r\n    \"\"\"\r\n\r\n    def __init__(self, bold_rows, parent=None):\r\n        \"\"\"\r\n        Initialize the MultiBoldRowDelegate.\r\n\r\n        Args:\r\n            bold_rows (list or set): The row indices that should be displayed in bold.\r\n            parent (QObject, optional): The parent object. Defaults to None.\r\n        \"\"\"\r\n        # Step 1: Initialize the parent class\r\n        super().__init__(parent)\r\n\r\n        # Step 2: Convert bold_rows to a set for faster lookup and store it\r\n        self.bold_rows = set(bold_rows)\r\n\r\n    def initStyleOption(self, option, index):\r\n        \"\"\"\r\n        Initialize the style options for the delegate.\r\n\r\n        This method is called by the view when it needs to paint an item. It sets\r\n        the font to bold if the current row is in the bold_rows set.\r\n\r\n        Args:\r\n            option (QStyleOptionViewItem): The style options for the item.\r\n            index (QModelIndex): The model index of the item.\r\n        \"\"\"\r\n        # Step 1: Call the parent class's initStyleOption method\r\n        super().initStyleOption(option, index)\r\n\r\n        # Step 2: Check if the current row should be bold\r\n        if index.row() in self.bold_rows:\r\n            # Step 3: If it should be bold, set the font to bold\r\n            option.font.setBold(True)\r\n\r\n\r\nclass Well:\r\n    def __init__(self, ui, well_name, df, df_dx):\r\n        super().__init__()\r\n        self.ui = ui\r\n        well_df = df[df['display_name']==well_name]\r\n        self.df_dx = df_dx\r\n        self.specific_well_data_model = QStandardItemModel()\r\n        self.ui.well_data_table_view.setModel(self.specific_well_data_model)\r\n        self.ui.well_data_table_view.setEditTriggers(QAbstractItemView.NoEditTriggers)\r\n        self.update_data_on_well_change(well_df)\r\n\r\n    def update_data_on_well_change(self, df):\r\n        # Handle multiple records by selecting most recent\r\n        if len(df) > 1:\r\n            current_data_row = df.sort_values(by='apdapproved_date', ascending=False).head(1)\r\n\r\n        # Define data fields for each table\r\n        row_1_data: List[str] = ['well_id', 'well_name', 'side_track', 'current_well_status', 'current_well_type',\r\n                                 'apdreceived_date', 'apdreturn_date', 'apdapproved_date', 'apdext_date',\r\n                                 'apdrescind_date', 'dry_spud', 'rotary_spud']\r\n\r\n        row_2_data: List[str] = ['well_status_report', 'well_type_report', 'first_prod_date', 'wcrcompletion_date',\r\n                                 'test_date', 'production_method', 'oil_rate', 'gas_rate', 'water_rate', 'dst',\r\n                                 'dir_survey_run', 'completion_type']\r\n\r\n        row_3_data: List[str] = ['gas_volume', 'oil_volume', 'well_age', 'last_production_if_shut_in',\r\n                                 'months_shut_in', 'operator', 'md', 'tvd', 'perforation_md',\r\n                                 'perforation_tvd', 'work_type', 'slant']\r\n        # Setup table structure\r\n        self.setup_table_data([row_1_data, row_2_data, row_3_data], df)\r\n\r\n        # Populate each table with corresponding data\r\n        for i, value in enumerate(row_1_data):\r\n            print(df[value])\r\n            self.ui.well_data_table_1.item(0, i).setText(str(df[value].item()))\r\n\r\n        for i, value in enumerate(row_2_data):\r\n            self.ui.well_data_table_2.item(0, i).setText(str(df[value].iloc[0]))\r\n\r\n        for i, value in enumerate(row_3_data):\r\n            self.ui.well_data_table_3.item(0, i).setText(str(df[value].iloc[0]))\r\n\r\n\r\n    def setup_table_data(self, row_data: List[List[str]], df: pd.DataFrame):\r\n        self.specific_well_data_model.setRowCount(0)  # Clear existing rows efficiently\r\n        self.ui.well_data_table_view.setModel(self.specific_well_data_model)\r\n        self.ui.well_data_table_view.setUpdatesEnabled(False)\r\n\r\n        # Clear existing table data\r\n        # Define modified headers for the third row\r\n        row_3_data_edited: List[str] = ['gas_volume', 'oil_volume', 'well_age', 'last_production_if_shut_in',\r\n            'months_shut_in', 'operator', 'md', 'tvd',\r\n            'perforation_md', 'perforation_tvd', 'work_type', 'slant']\r\n\r\n        # Initialize data structure for table population\r\n        data_used_lst: List[List[str]] = [row_data[0], [], row_data[1], [], row_3_data_edited, []]\r\n        # Populate data rows from DataFrame\r\n        for i, value in enumerate(row_data[0]):\r\n            data_used_lst[1].append(str(df[value].values[0]))\r\n        for i, value in enumerate(row_data[1]):\r\n            data_used_lst[3].append(str(df[value].values[0]))\r\n        for i, value in enumerate(row_data[2]):\r\n            data_used_lst[5].append(str(df[value].values[0]))\r\n\r\n        # Create and append items to model\r\n        for row in data_used_lst:\r\n            items = [QStandardItem(str(item)) for item in row]\r\n            self.specific_well_data_model.appendRow(items)\r\n\r\n        self.ui.well_data_table_view.verticalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)\r\n        self.ui.well_data_table_view.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)\r\n        self.ui.well_data_table_view.verticalHeader().setVisible(False)\r\n        self.ui.well_data_table_view.setShowGrid(True)\r\n        self.ui.well_data_table_view.setUpdatesEnabled(True)\r\n        self.ui.well_data_table_view.show()\r\n\r\n        bold_rows: List[int] = [0, 2, 4]\r\n        delegate = MultiBoldRowDelegate(bold_rows)\r\n        self.ui.well_data_table_view.setItemDelegate(delegate)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../main_process_well.py b/../main_process_well.py
--- a/../main_process_well.py	(revision 11c8d433909f415072d1821b99a7cb0108153144)
+++ b/../main_process_well.py	(date 1743018811529)
@@ -176,7 +176,7 @@
             current_data_row = df.sort_values(by='apdapproved_date', ascending=False).head(1)
 
         # Define data fields for each table
-        row_1_data: List[str] = ['well_id', 'well_name', 'side_track', 'current_well_status', 'current_well_type',
+        row_1_data: List[str] = ['api_number', 'well_name', 'side_track', 'current_well_status', 'current_well_type',
                                  'apdreceived_date', 'apdreturn_date', 'apdapproved_date', 'apdext_date',
                                  'apdrescind_date', 'dry_spud', 'rotary_spud']
 
Index: ../main_process_drawer.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import tempfile\r\n\r\nfrom PyQt5.QtGui import QGuiApplication\r\nfrom shapely.geometry import Point, LineString\r\nfrom matplotlib.collections import PatchCollection\r\n\r\nfrom PyQt5.QtCore import Qt\r\nfrom matplotlib.textpath import TextPath\r\nfrom matplotlib.patches import PathPatch\r\nimport utm\r\nfrom PyQt5.QtWidgets import QCheckBox\r\nfrom PyQt5.QtGui import QStandardItemModel, QStandardItem\r\nfrom matplotlib.collections import LineCollection, PolyCollection\r\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\r\nimport matplotlib.pyplot as plt\r\nimport pandas as pd\r\nfrom PyQt5.QtCore import QUrl\r\nimport plotly.graph_objects as go\r\nimport numpy as np\r\nfrom PyQt5.QtWidgets import QAbstractItemView, QSizePolicy\r\nimport itertools\r\nimport os\r\nimport sqlite3\r\nfrom datetime import datetime\r\nfrom typing import Callable, Dict, List, Literal, NoReturn, Optional, Set, Tuple, Union\r\n\r\n# Third-party imports - Core Data/Scientific\r\nimport numpy as np\r\nfrom numpy import array, std\r\nimport pandas as pd\r\nfrom pandas import DataFrame, concat, options, read_sql, set_option, to_datetime, to_numeric\r\nimport geopandas as gpd\r\nimport utm\r\nfrom sqlalchemy import create_engine\r\n\r\n# Third-party imports - PyQt5\r\nimport PyQt5\r\nfrom PyQt5.QtCore import QAbstractItemModel, QModelIndex, Qt\r\nfrom PyQt5.QtGui import QColor, QStandardItem, QStandardItemModel\r\nfrom PyQt5.QtWidgets import (\r\n    QApplication, QCheckBox, QGraphicsDropShadowEffect, QHeaderView,\r\n    QHBoxLayout, QLabel, QLayout, QMainWindow, QScrollArea,\r\n    QStyledItemDelegate, QTableWidget, QTableWidgetItem,\r\n    QVBoxLayout, QWidget\r\n)\r\n\r\n# Third-party imports - Matplotlib\r\nimport matplotlib.dates as mdates\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.axes import Axes\r\nfrom matplotlib.backend_bases import MouseEvent\r\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\r\nfrom matplotlib.collections import LineCollection, PatchCollection, PolyCollection\r\nfrom matplotlib.figure import Figure\r\nfrom matplotlib.lines import Line2D\r\nfrom matplotlib.patches import PathPatch, Polygon\r\nfrom matplotlib.text import Text\r\nfrom matplotlib.textpath import TextPath\r\nfrom matplotlib.ticker import FuncFormatter, ScalarFormatter\r\nfrom mpl_toolkits.mplot3d.art3d import Line3DCollection\r\nfrom typing import *\r\nclass Drawer:\r\n    def __init__(self, ui, used_df_dx, well_info_df):\r\n        self.ui = ui\r\n        self.df_docket_data = well_info_df\r\n        self.dx_df = used_df_dx\r\n        print(well_info_df.columns)\r\n        print(used_df_dx.columns)\r\n\r\n        # self.df_docket_data = self.df_tsr.merge(\r\n        #     self.df_BoardData,\r\n        #     left_on=['Section', 'Township', 'Township Direction',\r\n        #              'Range', 'Range Direction', 'Baseline'],\r\n        #     right_on=['Sec', 'Township', 'TownshipDir',\r\n        #               'Range', 'RangeDir', 'PM']\r\n        # )\r\n        \"\"\"Toggle between displaying asDrilled wells\"\"\"\r\n        self.ui.asdrilled_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying planned wells\"\"\"\r\n        self.ui.planned_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying currently drilling wells\"\"\"\r\n        self.ui.currently_drilling_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying oil wells\"\"\"\r\n        self.ui.oil_well_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying gas wells\"\"\"\r\n        self.ui.gas_well_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying water disposal wells\"\"\"\r\n        self.ui.water_disposal_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying injection wells\"\"\"\r\n        self.ui.injection_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying all other wells\"\"\"\r\n        self.ui.other_well_status_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying shut-in wells\"\"\"\r\n        self.ui.dry_hole_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying producing wells\"\"\"\r\n        self.ui.producing_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying shut in wells\"\"\"\r\n        self.ui.shut_in_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying plugged and abandoned wells\"\"\"\r\n        self.ui.pa_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying drilling wells\"\"\"\r\n        self.ui.drilling_status_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying all other status wells\"\"\"\r\n        self.ui.misc_well_type_check.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        \"\"\"Toggle between displaying field names\"\"\"\r\n        self.ui.field_names_checkbox.stateChanged.connect(self.manipulateTheDfDocketDataDependingOnCheckboxes)\r\n\r\n        self.setupDataForBoardDrillingInformation()\r\n\r\n    def preprocessData(self, df: pd.DataFrame) -> pd.DataFrame:\r\n        \"\"\"\r\n        Preprocesses well data by removing duplicates, sorting, and handling missing ages.\r\n\r\n        Performs the following operations in sequence:\r\n        1. Removes duplicate rows keeping first occurrence\r\n        2. Sorts data by API number\r\n        3. Resets DataFrame index\r\n        4. Fills missing well ages with 0\r\n\r\n        Args:\r\n            self: Parent class instance\r\n            df (pd.DataFrame): Input DataFrame containing well data.\r\n                Required columns:\r\n                - apinumber: Well identification number\r\n                - well_age: Age of the well (can contain NaN values)\r\n\r\n        Returns:\r\n            pd.DataFrame: Processed DataFrame with:\r\n                - No duplicates\r\n                - Sorted by apinumber\r\n                - Reset index\r\n                - well_age filled with 0 for missing values\r\n\r\n        Notes:\r\n            - Preserves all original columns except duplicates\r\n            - Assumes apinumber is a valid sorting key\r\n            - Treatment of NaN well ages as 0 typically indicates planned/permitted wells\r\n            - Original index is dropped during reset\r\n\r\n        Example:\r\n            >>> df = pd.DataFrame({\r\n            ...     'well_id': [2, 1, 2, 3],\r\n            ...     'well_age': [5.0, None, 5.0, 3.0]\r\n            ... })\r\n            >>> processed_df = preprocessData(self, df)\r\n            >>> processed_df['well_id'].tolist()\r\n            [1, 2, 3]\r\n        \"\"\"\r\n        # Remove duplicates and sort\r\n        print(df)\r\n        df = df.drop_duplicates(keep='first')\r\n        df = df.sort_values(by='well_id')\r\n\r\n        # Reset index and handle missing ages\r\n        df = df.reset_index(drop=True)\r\n        df['well_age'] = df['well_age'].fillna(0)\r\n\r\n        return df\r\n    def generateMasks(self) -> Tuple[pd.Series, pd.Series, pd.Series]:\r\n        \"\"\"\r\n        Generates boolean masks for filtering well data based on drilling status and type.\r\n\r\n        Creates three separate boolean masks for categorizing wells:\r\n        1. Drilled wells (completed or vertical)\r\n        2. Planned wells (permitted or planned vertical)\r\n        3. Currently drilling wells\r\n\r\n        Args:\r\n            self: Parent class instance containing:\r\n                - df_docket_data (pd.DataFrame): DataFrame with well information\r\n                    Required columns:\r\n                    - citing_type: Type of well citation\r\n                    - current_well_status: Current status of the well\r\n\r\n        Returns:\r\n            Tuple[pd.Series, pd.Series, pd.Series]: Three boolean masks:\r\n                - mask_drilled: True for already drilled/completed wells\r\n                - mask_planned: True for planned/permitted wells\r\n                - mask_drilling: True for currently drilling wells\r\n\r\n        Notes:\r\n            - citing_type values considered as drilled: ['asdrilled', 'vertical']\r\n            - citing_type values considered as planned: ['planned', 'vertical']\r\n            - current_well_status value for drilling: ['Drilling']\r\n            - Masks can be used directly for DataFrame filtering\r\n\r\n        Example:\r\n            >>> drilled, planned, drilling = self.generateMasks()\r\n            >>> drilled_wells = self.df_docket_data[drilled]\r\n            >>> planned_wells = self.df_docket_data[planned]\r\n            >>> drilling_wells = self.df_docket_data[drilling]\r\n        \"\"\"\r\n        # Generate mask for drilled/completed wells\r\n        mask_drilled = self.dx_df['citing_type'].isin(['asdrilled', 'vertical'])\r\n\r\n        # Generate mask for planned/permitted wells\r\n        mask_planned = self.dx_df['citing_type'].isin(['planned', 'vertical'])\r\n\r\n        # Generate mask for currently drilling wells\r\n        mask_drilling = self.dx_df['current_well_status'].isin(['Drilling'])\r\n\r\n        return mask_drilled, mask_planned, mask_drilling\r\n\r\n    def createAgeMasks(self) -> List[pd.Series]:\r\n        \"\"\"\r\n        Creates boolean masks for filtering wells based on age thresholds.\r\n\r\n        Generates four boolean masks representing different well age ranges:\r\n        1. Wells up to 1 year old (â‰¤12 months)\r\n        2. Wells up to 5 years old (â‰¤60 months)\r\n        3. Wells up to 10 years old (â‰¤120 months)\r\n        4. All wells regardless of age (â‰¤9999 months)\r\n\r\n        Args:\r\n            self: Parent class instance containing:\r\n                - df_docket_data (pd.DataFrame): DataFrame with well information\r\n                    Required columns:\r\n                    - well_age: Age of wells in months\r\n\r\n        Returns:\r\n            List[pd.Series]: List of four boolean masks where True indicates\r\n            wells within the respective age thresholds:\r\n            - mask[0]: Age â‰¤ 12 months\r\n            - mask[1]: Age â‰¤ 60 months\r\n            - mask[2]: Age â‰¤ 120 months\r\n            - mask[3]: Age â‰¤ 9999 months (effectively all wells)\r\n\r\n        Notes:\r\n            - well_age is expected to be in months\r\n            - Missing/NaN ages should be handled before calling this function\r\n            - Masks can be used directly for DataFrame filtering\r\n            - The 9999 threshold effectively includes all wells\r\n\r\n        Example:\r\n            >>> age_masks = self.createAgeMasks()\r\n            >>> new_wells = self.df_docket_data[age_masks[0]]  # Wells â‰¤ 1 year\r\n            >>> mature_wells = self.df_docket_data[age_masks[2]]  # Wells â‰¤ 10 years\r\n        \"\"\"\r\n        # Create list of boolean masks for different age thresholds\r\n        return [\r\n            (self.df_docket_data['well_age'] <= 12),  # 1 year threshold\r\n            (self.df_docket_data['well_age'] <= 60),  # 5 year threshold\r\n            (self.df_docket_data['well_age'] <= 120),  # 10 year threshold\r\n            (self.df_docket_data['well_age'] <= 9999)  # All wells threshold\r\n        ]\r\n\r\n    def cleanData(self, df: pd.DataFrame) -> pd.DataFrame:\r\n        \"\"\"\r\n        Cleans the input DataFrame by removing rows with missing targeted elevation values.\r\n\r\n        Performs basic data cleaning by dropping any rows where the 'Targeted Elevation'\r\n        column contains null/NaN values. This ensures downstream calculations have valid\r\n        elevation data to work with.\r\n\r\n        Args:\r\n            self: Parent class instance\r\n            df (pd.DataFrame): Input DataFrame containing well data.\r\n                Required columns:\r\n                - Targeted Elevation: Well target elevation values (can contain NaN)\r\n\r\n        Returns:\r\n            pd.DataFrame: Cleaned DataFrame with:\r\n                - All rows containing null targeted elevations removed\r\n                - Original column structure preserved\r\n                - Original index structure preserved\r\n\r\n        Notes:\r\n            - Rows with NaN values in other columns are preserved\r\n            - No modifications are made to non-null values\r\n            - Does not reset the index after dropping rows\r\n            - Operation is not performed in-place; returns new DataFrame\r\n\r\n        Example:\r\n            >>> df = pd.DataFrame({\r\n            ...     'Targeted Elevation': [100.0, None, 200.0],\r\n            ...     'Other Data': [1, 2, 3]\r\n            ... })\r\n            >>> cleaned_df = cleanData(self, df)\r\n            >>> len(cleaned_df)\r\n            2\r\n        \"\"\"\r\n        # Remove rows with missing targeted elevation values\r\n        return df.dropna(subset=['Targeted Elevation'])\r\n\r\n    def generateDataframes(\r\n            self,\r\n            mask_type: Literal['drilled', 'planned', 'drilling'],\r\n            mask: pd.Series,\r\n            age_masks: list[pd.Series]\r\n    ) -> Dict[str, pd.DataFrame]:\r\n        \"\"\"\r\n        Generates filtered DataFrames based on well type and age ranges.\r\n\r\n        Creates a dictionary of DataFrames filtered by the specified mask type\r\n        (drilled/planned/drilling) and four different age ranges. Each DataFrame\r\n        is sorted and index-reset for consistency.\r\n\r\n        Args:\r\n            self: Parent class instance containing:\r\n                - df_docket_data (pd.DataFrame): Source DataFrame with well information\r\n                    Required columns:\r\n                    - apinumber: Well identification number\r\n                    - measured_depth: Well depth measurement\r\n            mask_type (Literal['drilled', 'planned', 'drilling']): Type of wells to filter\r\n            mask (pd.Series): Boolean mask identifying well type\r\n            age_masks (list[pd.Series]): List of 4 boolean masks for age filtering:\r\n                - age_masks[0]: â‰¤ 12 months\r\n                - age_masks[1]: â‰¤ 60 months\r\n                - age_masks[2]: â‰¤ 120 months\r\n                - age_masks[3]: All wells\r\n\r\n        Returns:\r\n            Dict[str, pd.DataFrame]: Dictionary containing filtered DataFrames:\r\n                - {mask_type}_year: Wells within 1 year\r\n                - {mask_type}_5years: Wells within 5 years\r\n                - {mask_type}_10years: Wells within 10 years\r\n                - {mask_type}_all: All wells of specified type\r\n\r\n        Notes:\r\n            - All DataFrames are sorted by apinumber and measured_depth\r\n            - Indexes are reset for all DataFrames\r\n            - Empty DataFrames may be returned if no wells match criteria\r\n            - Original data is not modified\r\n\r\n        Example:\r\n            >>> drilled_dfs = generateDataframes(self, 'drilled', mask_drilled, age_masks)\r\n            >>> print(f\"New drilled wells: {len(drilled_dfs['drilled_year'])}\")\r\n            >>> print(f\"All drilled wells: {len(drilled_dfs['drilled_all'])}\")\r\n        \"\"\"\r\n        # Initialize dictionary for storing filtered DataFrames\r\n        dataframes = {}\r\n\r\n        # Generate DataFrames for each age range\r\n        for i, age_range in enumerate(['year', '5years', '10years', 'all']):\r\n            # Create dictionary key combining mask type and age range\r\n            key = f\"{mask_type}_{age_range}\"\r\n\r\n            # Filter data using combined masks and sort\r\n            dataframes[key] = self.df_docket_data.loc[mask & age_masks[i]]\r\n            dataframes[key] = dataframes[key].reset_index(drop=True).sort_values(\r\n                by=['apinumber', 'measured_depth']\r\n            )\r\n\r\n        return dataframes\r\n    def returnWellsWithParameters(self, info_df, dx_df) -> DataFrame:\r\n        \"\"\"\r\n        Processes and returns well data with color-coded parameters for visualization.\r\n\r\n        Creates a filtered and enriched DataFrame containing well information with\r\n        standardized color mappings for well types and operational status. Merges\r\n        directional survey data with docket information for comprehensive visualization.\r\n\r\n        Color Schemes:\r\n            Well Types:\r\n                - Oil Wells: Red (#c34c00)\r\n                - Gas Wells: Orange (#f1aa00)\r\n                - Water Disposal Wells: Blue (#0032b0)\r\n                - Injection Wells: Cyan (#93ebff)\r\n                - Dry Holes: Dark Gray (#4f494b)\r\n                - Unknown/Test Wells: Magenta (#985bee)\r\n\r\n            Well Status:\r\n                - Producing: Green (#a2e361)\r\n                - Plugged & Abandoned: Purple (#4c2d77)\r\n                - Shut In: Tan (#D2B48C)\r\n                - Drilling: Navy (#001958)\r\n                - Other: Teal (#4a7583)\r\n\r\n        Returns:\r\n            DataFrame with columns:\r\n                - APINumber: Well identifier\r\n                - X, Y: Well coordinates\r\n                - Targeted Elevation\r\n                - CitingType\r\n                - SPX, SPY: Surface point coordinates\r\n                - CurrentWellType\r\n                - CurrentWellStatus\r\n                - WellAge\r\n                - MeasuredDepth\r\n                - ConcCode_y\r\n                - WellTypeColor: Hex color based on well type\r\n                - WellStatusColor: Hex color based on well status\r\n\r\n        Side Effects:\r\n            None - Pure data processing function\r\n\r\n        Notes:\r\n            - Merges directional survey data with docket information\r\n            - Removes duplicate entries\r\n            - Sorts by APINumber and MeasuredDepth\r\n            - Maps colors based on standardized industry visualization schemes\r\n            - Handles unknown status values with default teal color\r\n        \"\"\"\r\n        # Define color mappings for well types\r\n        colors_type = {\r\n            'Oil Well': '#c34c00',  # Red\r\n            'Gas Well': '#f1aa00',  # Orange\r\n            'Water Disposal Well': '#0032b0',  # Blue\r\n            'Oil Well/Water Disposal Well': '#0032b0',  # Blue\r\n            'Water Injection Well': '#93ebff',  # Cyan\r\n            'Gas Injection Well': '#93ebff',  # Cyan\r\n            'Dry Hole': '#4f494b',  # Dark Gray\r\n            'Unknown': '#985bee',  # Magenta\r\n            'Test Well': '#985bee',  # Magenta\r\n            'Water Source Well': '#985bee'  # Magenta\r\n        }\r\n\r\n        # Define color mappings for well status\r\n        colors_status = {\r\n            'Producing': '#a2e361',  # Green\r\n            'Plugged & Abandoned': '#4c2d77',  # Purple\r\n            'Shut In': '#D2B48C',  # tan\r\n            'Drilling': '#001958',  # Navy\r\n            'Other': '#4a7583'  # Teal\r\n        }\r\n\r\n        # Define required columns for final dataset\r\n        necessary_columns = [\r\n            'apinumber', 'x', 'y', 'targeted_elevation', 'citing_type',\r\n            'spx', 'spy', 'current_well_type', 'current_well_status',\r\n            'well_age', 'measured_depth', 'conc_code_y'\r\n        ]\r\n\r\n        # Process and filter data\r\n        apis = info_df['well_id'].unique()\r\n        # operators = self.df_docket['Operator'].unique()\r\n        dx_filtered = dx_df[dx_df['apinumber'].isin(apis)]\r\n        docket_filtered = info_df[info_df['well_id'].isin(apis)]\r\n\r\n        # Merge and clean data\r\n        merged_df = pd.merge(dx_filtered, docket_filtered,\r\n                             left_on='apinumber', right_on='well_id')\r\n        merged_df = merged_df.drop_duplicates(keep='first')\r\n        merged_df = merged_df.sort_values(by=['apinumber', 'measured_depth'])\r\n\r\n        # Create final dataset with necessary columns\r\n        print(merged_df)\r\n        final_df = merged_df[necessary_columns]\r\n        final_df.reset_index(drop=True, inplace=True)\r\n\r\n        # Add color coding\r\n        final_df['well_type_color'] = final_df['current_well_type'].map(colors_type)\r\n        final_df['well_status_color'] = final_df['current_well_status'].apply(\r\n            lambda x: colors_status.get(x, '#4a7583')\r\n        )\r\n\r\n        return final_df.sort_values(by=['apinumber', 'measured_depth'])\r\n\r\n\r\n    def setupDataForBoardDrillingInformation(self):\r\n        self.df_docket_data = self.returnWellsWithParameters(self.df_docket_data, self.dx_df)\r\n        print(self.df_docket_data)\r\n        # Clear and prep the data\r\n        self.df_docket_data = self.preprocessData(self.df_docket_data)\r\n        print(self.df_docket_data)\r\n        print(foo)\r\n        # Initialize data containers\r\n        self.planned_xy_2d, self.planned_xy_3d, self.drilled_xy_2d, self.drilled_xy_3d, self.currently_drilling_xy_2d, self.currently_drilling_xy_3d = [], [], [], [], [], []\r\n\r\n        # Generate masks for data filtering\r\n        mask_drilled, mask_planned, mask_drilling = self.generateMasks()\r\n\r\n        # Generate age-based masks\r\n        age_masks = self.createAgeMasks()\r\n\r\n        # Clean data\r\n        self.df_docket_data = self.cleanData(self.df_docket_data)\r\n\r\n        # Generate dataframes based on conditions\r\n\r\n        # For drilled\r\n        drilled_dfs = self.generateDataframes('drilled', mask_drilled, age_masks)\r\n        # For planned\r\n        planned_dfs = self.generateDataframes('planned', mask_planned, age_masks)\r\n        # For currently drilling\r\n        currently_drilling_dfs = self.generateDataframes('currently_drilling', mask_drilling, age_masks)\r\n\r\n\r\n        drilled_dataframes = [drilled_dfs['drilled_year'], drilled_dfs['drilled_5years'], drilled_dfs['drilled_10years'], drilled_dfs['drilled_all']]\r\n        planned_dataframes = [planned_dfs['planned_year'], planned_dfs['planned_5years'], planned_dfs['planned_10years'], planned_dfs['planned_all']]\r\n        currently_drilling_dataframes = [currently_drilling_dfs['currently_drilling_year'], currently_drilling_dfs['currently_drilling_5years'], currently_drilling_dfs['currently_drilling_10years'], currently_drilling_dfs['currently_drilling_all']]\r\n\r\n        # Filter out planned data based on drilled data\r\n        planned_dataframes = self.filterPlannedData(drilled_dataframes, planned_dataframes)\r\n\r\n        # Prepare final data structures\r\n        self.prepareFinalData(drilled_dataframes, planned_dataframes, currently_drilling_dataframes)\r\n\r\n    def filterPlannedData(\r\n            self,\r\n            drilled_dataframes: List[pd.DataFrame],\r\n            planned_dataframes: List[pd.DataFrame]\r\n    ) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame, pd.DataFrame]:\r\n        \"\"\"\r\n        Filters planned well data by comparing against drilled wells for different time periods.\r\n\r\n        For each time period (1 year, 5 years, 10 years, and all time), removes planned wells\r\n        that have already been drilled from the planned wells dataset.\r\n\r\n        Args:\r\n            self: Parent class instance containing filterPlannedDataForYear method\r\n            drilled_dataframes (List[pd.DataFrame]): List of 4 DataFrames containing drilled well data:\r\n                - drilled_dataframes[0]: Wells drilled within 1 year\r\n                - drilled_dataframes[1]: Wells drilled within 5 years\r\n                - drilled_dataframes[2]: Wells drilled within 10 years\r\n                - drilled_dataframes[3]: All drilled wells\r\n            planned_dataframes (List[pd.DataFrame]): List of 4 DataFrames containing planned well data:\r\n                - planned_dataframes[0]: Wells planned within 1 year\r\n                - planned_dataframes[1]: Wells planned within 5 years\r\n                - planned_dataframes[2]: Wells planned within 10 years\r\n                - planned_dataframes[3]: All planned wells\r\n\r\n        Returns:\r\n            Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame, pd.DataFrame]:\r\n                - planned_year: Filtered planned wells for 1 year\r\n                - planned_5years: Filtered planned wells for 5 years\r\n                - planned_10years: Filtered planned wells for 10 years\r\n                - planned_all: Filtered planned wells for all time\r\n\r\n        Notes:\r\n            - Uses filterPlannedDataForYear helper method for each time period\r\n            - Maintains original DataFrame structure and column organization\r\n            - Does not modify input DataFrames\r\n            - Returns empty DataFrames if all planned wells have been drilled\r\n\r\n        Example:\r\n            >>> filtered_planned = filterPlannedData(self, drilled_dfs, planned_dfs)\r\n            >>> print(f\"Remaining planned wells (1yr): {len(filtered_planned[0])}\")\r\n        \"\"\"\r\n        # Filter planned wells for each time period using helper method\r\n        planned_year = self.filterPlannedDataForYear(\r\n            drilled_dataframes[0], planned_dataframes[0])  # 1 year filter\r\n\r\n        planned_5years = self.filterPlannedDataForYear(\r\n            drilled_dataframes[1], planned_dataframes[1])  # 5 year filter\r\n\r\n        planned_10years = self.filterPlannedDataForYear(\r\n            drilled_dataframes[2], planned_dataframes[2])  # 10 year filter\r\n\r\n        planned_all = self.filterPlannedDataForYear(\r\n            drilled_dataframes[3], planned_dataframes[3])  # All time filter\r\n\r\n        return planned_year, planned_5years, planned_10years, planned_all\r\n    def filterPlannedDataForYear(\r\n            self,\r\n            drilled_df: pd.DataFrame,\r\n            planned_df: pd.DataFrame\r\n    ) -> pd.DataFrame:\r\n        \"\"\"\r\n        Filters planned wells by removing those that have been drilled or are currently drilling.\r\n\r\n        Takes a DataFrame of planned wells and removes any wells that:\r\n        1. Already exist in the drilled wells dataset (based on apinumber)\r\n        2. Have a current status of \"Drilling\"\r\n\r\n        Args:\r\n            self: Parent class instance\r\n            drilled_df (pd.DataFrame): DataFrame containing drilled well data\r\n                Required columns:\r\n                - apinumber: Unique well identifier\r\n            planned_df (pd.DataFrame): DataFrame containing planned well data\r\n                Required columns:\r\n                - apinumber: Unique well identifier\r\n                - current_well_status: Current status of the well\r\n\r\n        Returns:\r\n            pd.DataFrame: Filtered planned wells DataFrame with:\r\n                - Wells that exist in drilled_df removed\r\n                - Wells with 'Drilling' status removed\r\n                - All other columns and data preserved\r\n                - Original index structure maintained\r\n\r\n        Notes:\r\n            - Uses apinumber for well identification and matching\r\n            - Case-sensitive matching for 'Drilling' status\r\n            - Does not modify input DataFrames\r\n            - Returns empty DataFrame if all planned wells are filtered out\r\n\r\n        Example:\r\n            >>> filtered_planned = filterPlannedDataForYear(\r\n            ...     drilled_df=drilled_wells,\r\n            ...     planned_df=planned_wells\r\n            ... )\r\n            >>> print(f\"Remaining planned wells: {len(filtered_planned)}\")\r\n        \"\"\"\r\n        # Filter out wells that are either drilled or currently drilling\r\n        planned_year = planned_df[\r\n            ~planned_df['apinumber'].isin(drilled_df['apinumber']) &\r\n            (planned_df['current_well_status'] != 'Drilling')\r\n            ]\r\n\r\n        return planned_year\r\n\r\n    def prepareFinalData(\r\n            self,\r\n            drilled_dataframes: Dict[str, pd.DataFrame],\r\n            planned_dataframes: Dict[str, pd.DataFrame],\r\n            currently_drilling_dataframes: Dict[str, pd.DataFrame]\r\n    ) -> None:\r\n        \"\"\"\r\n        Prepares and processes the final well data for all well categories.\r\n\r\n        Stores well data by category (drilled, planned, currently drilling) and processes\r\n        spatial (XY) coordinates for each category. Updates instance attributes with\r\n        processed data.\r\n\r\n        Args:\r\n            drilled_dataframes (Dict[str, pd.DataFrame]): Dictionary of drilled well DataFrames\r\n                Keys: 'drilled_year', 'drilled_5years', 'drilled_10years', 'drilled_all'\r\n            planned_dataframes (Dict[str, pd.DataFrame]): Dictionary of planned well DataFrames\r\n                Keys: 'planned_year', 'planned_5years', 'planned_10years', 'planned_all'\r\n            currently_drilling_dataframes (Dict[str, pd.DataFrame]): Dictionary of currently drilling well DataFrames\r\n                Keys: 'drilling_year', 'drilling_5years', 'drilling_10years', 'drilling_all'\r\n\r\n        Notes:\r\n            - Updates instance attributes:\r\n                self.drilled: Stores drilled well data\r\n                self.planned: Stores planned well data\r\n                self.currently_drilling: Stores currently drilling well data\r\n            - Processes XY coordinates for each well category using processXYData method\r\n            - Original DataFrames are not modified\r\n            - Empty DataFrames are handled gracefully\r\n\r\n        Side Effects:\r\n            - Modifies instance attributes (self.drilled, self.planned, self.currently_drilling)\r\n            - Calls processXYData which may modify additional instance attributes\r\n        \"\"\"\r\n        # Store DataFrames as instance attributes\r\n        self.drilled = drilled_dataframes\r\n        self.planned = planned_dataframes\r\n        self.currently_drilling = currently_drilling_dataframes\r\n\r\n        # Process spatial coordinates for each well category\r\n        self.processXYData(drilled_dataframes, 'drilled')  # Process drilled wells XY data\r\n        self.processXYData(planned_dataframes, 'planned')  # Process planned wells XY data\r\n        self.processXYData(currently_drilling_dataframes, 'currently_drilling')  # Process drilling wells XY data\r\n\r\n    def processXYData(self, dataframes: Dict[str, pd.DataFrame], data_type: Literal['drilled', 'planned', 'currently_drilling']) -> None:\r\n        \"\"\"\r\n        Processes spatial (XY) coordinate data for each well dataframe in a category.\r\n\r\n        Iterates through dataframes of a specific well type and processes their spatial\r\n        coordinates using the processSingleDataframe helper method. Handles different\r\n        time periods (1 year, 5 years, 10 years, all) for each well category.\r\n\r\n        Args:\r\n            self: Parent class instance containing:\r\n                - processSingleDataframe method for individual DataFrame processing\r\n            dataframes (Dict[str, pd.DataFrame]): Dictionary of well DataFrames\r\n                Keys expected in format: f\"{data_type}_{time_period}\"\r\n                where time_period is one of: year, 5years, 10years, all\r\n            data_type (Literal['drilled', 'planned', 'currently_drilling']):\r\n                Category of wells being processed\r\n\r\n        Notes:\r\n            - Processes spatial coordinates for visualization purposes\r\n            - Each DataFrame is processed sequentially\r\n            - Order of processing matches time period sequence:\r\n                1. year (â‰¤12 months)\r\n                2. 5years (â‰¤60 months)\r\n                3. 10years (â‰¤120 months)\r\n                4. all\r\n            - Relies on processSingleDataframe method for actual coordinate processing\r\n\r\n        Side Effects:\r\n            - Calls processSingleDataframe which may modify visualization attributes\r\n            - May update plot data or other visualization components\r\n\r\n        Example:\r\n            >>> processXYData(self, drilled_dataframes, 'drilled')\r\n        \"\"\"\r\n        # Process each DataFrame in the dictionary\r\n        for i, df in enumerate(dataframes):\r\n        # Call helper method to process individual DataFrame\r\n            self.processSingleDataframe(df, data_type, i)\r\n\r\n    # def processXYData(self, dataframes, data_type):\r\n    def processSingleDataframe(\r\n            self,\r\n            df: pd.DataFrame,\r\n            data_type: Literal['drilled', 'planned', 'currently_drilling'],\r\n            index: int\r\n    ) -> None:\r\n        \"\"\"\r\n        Processes a single well DataFrame to extract and store 2D and 3D spatial coordinates.\r\n\r\n        Extracts XY coordinates and organizes them for both 2D and 3D visualization purposes.\r\n        The processed data is stored in instance attributes for later plotting.\r\n\r\n        Args:\r\n            self: Parent class instance containing:\r\n                - createXYPointsDict method for coordinate extraction\r\n                - {data_type}_xy_2d attribute lists for 2D plotting\r\n                - {data_type}_xy_3d attribute lists for 3D plotting\r\n            df (pd.DataFrame): Well data DataFrame containing:\r\n                Required columns:\r\n                - apinumber: Unique well identifier\r\n                - X: X coordinate in state plane\r\n                - Y: Y coordinate in state plane\r\n            data_type (Literal['drilled', 'planned', 'currently_drilling']):\r\n                Category of wells being processed\r\n            index (int): Index for the time period being processed (0=1yr, 1=5yr, 2=10yr, 3=all)\r\n\r\n        Notes:\r\n            - Creates separate point collections for 2D and 3D visualization\r\n            - Points are organized by API number for consistent well identification\r\n            - Handles missing or invalid coordinates gracefully\r\n            - Data is appended to existing visualization lists\r\n\r\n        Side Effects:\r\n            - Modifies instance attributes:\r\n                - self.{data_type}_xy_2d: List of 2D coordinate sets\r\n                - self.{data_type}_xy_3d: List of 3D coordinate sets\r\n\r\n        Example:\r\n            >>> processSingleDataframe(df_wells, 'drilled', 0)\r\n            # Updates self.drilled_xy_2d[0] and self.drilled_xy_3d[0] with new coordinates\r\n        \"\"\"\r\n        # Generate dictionary of XY points for each well\r\n        xy_points_dict = self.createXYPointsDict(df)\r\n\r\n        # Get unique API numbers from the DataFrame\r\n        apinums: Set[str] = set(df['apinumber'])\r\n\r\n        # Create attribute keys for storing coordinates\r\n        xy_2d_key = f\"{data_type}_xy_2d\"\r\n        xy_3d_key = f\"{data_type}_xy_3d\"\r\n\r\n        # Extract 2D coordinates (X,Y) for visualization\r\n        xy_2d_data = [[r[:2] for r in v] for k, v in xy_points_dict.items()\r\n                      if k in apinums]\r\n\r\n        # Extract 3D coordinates (Z coordinates) for visualization\r\n        xy_3d_data = [[r[2:] for r in v] for k, v in xy_points_dict.items()\r\n                      if k in apinums]\r\n\r\n        # Store processed coordinate data in instance attributes\r\n        getattr(self, xy_2d_key).append(xy_2d_data)\r\n        getattr(self, xy_3d_key).append(xy_3d_data)\r\n\r\n    def createXYPointsDict(\r\n            self,\r\n            df: pd.DataFrame\r\n    ) -> Dict[str, List[List[float]]]:\r\n        \"\"\"\r\n        Creates a dictionary mapping API numbers to their coordinate points and elevation data.\r\n\r\n        Groups well data by API number and creates coordinate lists containing surface\r\n        coordinates (X,Y), state plane coordinates (SPX,SPY) and targeted elevation for\r\n        each well.\r\n\r\n        Args:\r\n            self: Parent class instance\r\n            df (pd.DataFrame): Well data DataFrame containing:\r\n                Required columns:\r\n                - apinumber: Unique well identifier\r\n                - X: Surface X coordinate\r\n                - Y: Surface Y coordinate\r\n                - SPX: State plane X coordinate\r\n                - SPY: State plane Y coordinate\r\n                - Targeted Elevation: Well's target elevation\r\n\r\n        Returns:\r\n            Dict[str, List[List[float]]]: Dictionary where:\r\n                - Keys: API numbers (str)\r\n                - Values: List of coordinate lists, each containing:\r\n                    [x, y, spx, spy, z] where:\r\n                    - x,y: Surface coordinates\r\n                    - spx,spy: State plane coordinates\r\n                    - z: Targeted elevation\r\n\r\n        Notes:\r\n            - All coordinate values are converted to float type\r\n            - Handles missing values by converting to float (may result in NaN)\r\n            - Groups data by apinumber to maintain well identity\r\n            - Coordinates are organized for both 2D and 3D visualization use\r\n\r\n        Example:\r\n            >>> xy_dict = createXYPointsDict(well_df)\r\n            >>> first_well = next(iter(xy_dict.values()))\r\n            >>> print(f\"First well coordinates: {first_well[0]}\")\r\n            First well coordinates: [1234.5, 5678.9, 1000.0, 2000.0, 3500.0]\r\n        \"\"\"\r\n        return {k: [[x, y, spx, spy, z] for x, y, spx, spy, z in\r\n                zip(g['X'].astype(float),\r\n                    g['Y'].astype(float),\r\n                    g['SPX'].astype(float),\r\n                    g['SPY'].astype(float),\r\n                    g['Targeted Elevation'].astype(float))]\r\n            for k, g in df.groupby('apinumber')}\r\n\r\n\r\n\r\n    def returnWellDataDependingOnParametersTest(self) -> None:\r\n        \"\"\"\r\n        Updates instance attributes with well data based on selected time period radio button.\r\n\r\n        Retrieves the currently selected time period from the UI radio button group and\r\n        updates relevant instance attributes with corresponding well data and spatial\r\n        coordinates for visualization.\r\n\r\n        Args:\r\n            self: Parent class instance containing:\r\n                Required UI elements:\r\n                - ui.drilling_within_button_group: QButtonGroup for time period selection\r\n                Required data attributes:\r\n                - drilled, planned, currently_drilling: DataFrames by time period\r\n                - *_xy_2d, *_xy_3d: Spatial coordinate lists by time period\r\n\r\n        Side Effects:\r\n            Updates the following instance attributes based on selected time period:\r\n            DataFrames:\r\n            - self.drilled_df: Drilled wells data\r\n            - self.planned_df: Planned wells data\r\n            - self.currently_drilling_df: Currently drilling wells data\r\n\r\n            2D Visualization Data:\r\n            - self.drilled_segments: Drilled wells 2D coordinates\r\n            - self.planned_segments: Planned wells 2D coordinates\r\n            - self.currently_drilling_segments: Drilling wells 2D coordinates\r\n\r\n            3D Visualization Data:\r\n            - self.drilled_segments_3d: Drilled wells 3D coordinates\r\n            - self.planned_segments_3d: Planned wells 3D coordinates\r\n            - self.currently_drilling_segments_3d: Drilling wells 3D coordinates\r\n\r\n        Notes:\r\n            - Time period index (id_1) corresponds to:\r\n              0: 1 year\r\n              1: 5 years\r\n              2: 10 years\r\n              3: All time\r\n            - All data structures must be pre-populated with corresponding time period data\r\n            - No validation is performed on the button group checked state\r\n        \"\"\"\r\n        # Get selected time period from UI radio button group\r\n        id_1 = self.ui.drilling_within_button_group.checkedId()\r\n\r\n        # Update DataFrame attributes for each well category\r\n        self.drilled_df = self.drilled[id_1]\r\n        self.planned_df = self.planned[id_1]\r\n        self.currently_drilling_df = self.currently_drilling[id_1]\r\n\r\n        # Update 2D visualization coordinates\r\n        self.drilled_segments = self.drilled_xy_2d[id_1]\r\n        self.planned_segments = self.planned_xy_2d[id_1]\r\n        self.currently_drilling_segments = self.currently_drilling_xy_2d[id_1]\r\n\r\n        # Update 3D visualization coordinates\r\n        self.drilled_segments_3d = self.drilled_xy_3d[id_1]\r\n        self.planned_segments_3d = self.planned_xy_3d[id_1]\r\n        self.currently_drilling_segments_3d = self.currently_drilling_xy_3d[id_1]\r\n\r\n    def manipulateTheDfDocketDataDependingOnCheckboxes(self):\r\n        \"\"\"\r\n           Main function for managing well visualization based on UI checkbox states.\r\n\r\n           Controls the display of different well types (drilled, planned, currently drilling)\r\n           and their properties in both 2D and 3D views. Handles well filtering, visibility,\r\n           styling, and related UI elements like field names.\r\n\r\n           Attributes Modified:\r\n               currently_used_lines (DataFrame): Tracks which well lines are currently displayed\r\n               field_sections (Artist): Visual elements for field sections\r\n               labels_field (Artist): Text labels for fields\r\n               Various matplotlib artists for well visualization\r\n\r\n           Side Effects:\r\n               - Updates 2D and 3D matplotlib canvases\r\n               - Modifies well line visibility and styling\r\n               - Updates field name labels\r\n               - Adjusts 3D view limits based on well positions\r\n               - Triggers well type/status filtering\r\n\r\n           Processing Steps:\r\n               1. Initializes local data references\r\n               2. Sets up data parameters for each well category\r\n               3. Applies type/status filtering\r\n               4. Handles field name visibility\r\n               5. Processes well display parameters\r\n               6. Toggles visibility for different well categories\r\n               7. Adjusts 3D view boundaries\r\n               8. Updates visualization canvases\r\n\r\n           Notes:\r\n               - Central function for well visualization control\r\n               - Connected to multiple UI checkbox events\r\n               - Manages both 2D and 3D visualizations\r\n               - Handles three main well categories:\r\n                   * As-drilled wells\r\n                   * Planned wells\r\n                   * Currently drilling wells\r\n               - Maintains visualization consistency across views\r\n               - Uses helper functions for data setup and display\r\n\r\n           Dependencies:\r\n               - setupData(): Prepares well data parameters\r\n               - statusAndTypesEnabler(): Manages well filtering\r\n               - toggleWellDisplay(): Controls well visibility\r\n               - calculateCentroidNP(): Computes 3D view center\r\n           \"\"\"\r\n\r\n        def platBounded(\r\n                df: pd.DataFrame,\r\n                segments: List[List[List[float]]],\r\n                segments_3d: List[List[List[float]]]\r\n        ) -> Tuple[pd.DataFrame, List[List[List[float]]], List[List[List[float]]]]:\r\n\r\n            # Sort DataFrame by API number and measured depth\r\n            df = df.sort_values(by=['apinumber', 'measured_depth'])\r\n\r\n            # Create index mapping for API numbers\r\n            api = df[['apinumber']].drop_duplicates().reset_index(drop=True)\r\n            api['index'] = api.index\r\n\r\n            # Merge to maintain relationships\r\n            merged = pd.merge(api, df, left_on='apinumber', right_on='apinumber')\r\n\r\n            # Filter segments to match DataFrame wells\r\n            segments = [segments[i] for i in range(len(segments)) if i in merged['index'].unique()]\r\n            segments_3d = [segments_3d[i] for i in range(len(segments_3d)) if i in merged['index'].unique()]\r\n\r\n            return df, segments, segments_3d\r\n\r\n        def setupData(\r\n                df: pd.DataFrame,\r\n                segments: List[List[List[float]]],\r\n                segments_3d: List[List[List[float]]]\r\n        ) -> Tuple[pd.DataFrame, List[List[List[float]]], List[List[List[float]]], Dict, pd.DataFrame]:\r\n\r\n            # Filter and align data using platBounded\r\n            df, segments, segments_3d = platBounded(df, segments, segments_3d)\r\n\r\n            # Create default styling parameters\r\n            data = {'color': ['black'] * len(segments), 'width': [0.5] * len(segments)}\r\n\r\n            # Convert styling parameters to DataFrame\r\n            df_parameters = pd.DataFrame(data)\r\n\r\n            return df, segments, segments_3d, data, df_parameters\r\n\r\n        def wellChecked(\r\n                type: str,\r\n                column: Literal['CurrentWellType', 'current_well_status']\r\n        ) -> None:\r\n            \"\"\"\r\n            Updates well visualization parameters based on specified well type or status filter.\r\n\r\n            Modifies the styling (color and line width) of well segments in the visualization\r\n            based on either well type (e.g., Oil, Gas) or well status (e.g., Producing,\r\n            Shut-in). Wells matching the filter criteria are highlighted with specific colors\r\n            and increased line width.\r\n\r\n            Args:\r\n                type (str): Well type or status to filter by. Valid values depend on column:\r\n                    For CurrentWellType:\r\n                        - 'Oil Well'\r\n                        - 'Gas Well'\r\n                        - 'Water Disposal Well'\r\n                        - 'Water Injection Well'\r\n                        - 'Gas Injection Well'\r\n                        - 'Dry Hole'\r\n                        - 'Test Well'\r\n                        - 'Water Source Well'\r\n                        - 'Unknown'\r\n                    For current_well_status:\r\n                        - Status values from well database\r\n                column (Literal['CurrentWellType', 'current_well_status']):\r\n                    Column to filter on, determines color mapping used\r\n\r\n            Side Effects:\r\n                Updates these visualization parameter DataFrames:\r\n                - df_drilled_parameters\r\n                - df_planned_parameters\r\n                - df_drilling_parameters\r\n\r\n                Modifies:\r\n                - 'color': Changed from default black to type-specific color\r\n                - 'width': Increased from 0.5 to 1.5 for matching wells\r\n\r\n            Notes:\r\n                - Only processes first row per API number since color/type is constant per well\r\n                - Handles three well categories: drilled, planned, and currently drilling\r\n                - Uses predefined color mappings stored in WellTypeColor or WellStatusColor\r\n                - Non-matching wells retain default black color and 0.5 width\r\n                - Changes are reflected immediately in visualization\r\n\r\n            Example:\r\n                >>> wellChecked('Oil Well', 'CurrentWellType')\r\n                # Updates visualization to highlight all oil wells in red\r\n            \"\"\"\r\n            # Determine color mapping column based on filter type\r\n            colors_lst = 'WellTypeColor' if column == 'CurrentWellType' else 'WellStatusColor'\r\n\r\n            # Get first row for each API number to determine well properties\r\n            drilled_df_restricted = drilled_df.groupby('apinumber').first().reset_index()\r\n            planned_df_restricted = planned_df.groupby('apinumber').first().reset_index()\r\n            currently_drilling_df_restricted = currently_drilling_df.groupby('apinumber').first().reset_index()\r\n\r\n            # Create masks for wells matching specified type/status\r\n            drilled_well_mask = drilled_df_restricted[column] == type\r\n            planned_well_mask = planned_df_restricted[column] == type\r\n            currently_drilling_well_mask = currently_drilling_df_restricted[column] == type\r\n\r\n            # Update styling for drilled wells\r\n            df_drilled_parameters.loc[drilled_well_mask, 'color'] = drilled_df_restricted.loc[\r\n                drilled_well_mask, colors_lst]\r\n            df_drilled_parameters.loc[drilled_well_mask, 'width'] = 1.5\r\n\r\n            # Update styling for planned wells\r\n            df_planned_parameters.loc[planned_well_mask, 'color'] = planned_df_restricted.loc[\r\n                planned_well_mask, colors_lst]\r\n            df_planned_parameters.loc[planned_well_mask, 'width'] = 1.5\r\n\r\n            # Update styling for currently drilling wells\r\n            df_drilling_parameters.loc[currently_drilling_well_mask, 'color'] = currently_drilling_df_restricted.loc[\r\n                currently_drilling_well_mask, colors_lst]\r\n            df_drilling_parameters.loc[currently_drilling_well_mask, 'width'] = 1.5\r\n\r\n        def wellCheckedMultiple(\r\n                types: List[str],\r\n                column: Literal['CurrentWellType', 'current_well_status']\r\n        ) -> None:\r\n            \"\"\"\r\n            Updates well visualization parameters for multiple well types or statuses simultaneously.\r\n\r\n            Similar to wellChecked() but handles multiple types/statuses at once. Modifies the styling\r\n            (color and line width) of well segments in the visualization based on a list of well\r\n            types or statuses. Wells matching any of the filter criteria are highlighted.\r\n\r\n            Args:\r\n                types (List[str]): List of well types or statuses to filter by. Valid values depend on column:\r\n                    For CurrentWellType:\r\n                        - 'Oil Well'\r\n                        - 'Gas Well'\r\n                        - 'Water Disposal Well'\r\n                        - 'Oil Well/Water Disposal Well'\r\n                        - 'Water Injection Well'\r\n                        - 'Gas Injection Well'\r\n                        - 'Dry Hole'\r\n                        - etc.\r\n                    For current_well_status:\r\n                        - 'Location Abandoned - APD rescinded'\r\n                        - 'Returned APD (Unapproved)'\r\n                        - 'Approved Permit'\r\n                        - 'Active'\r\n                        - 'Drilling Operations Suspended'\r\n                        - 'New Permit'\r\n                        - 'Inactive'\r\n                        - 'Temporarily-abandoned'\r\n                        - 'Test Well or Monitor Well'\r\n                        - etc.\r\n                column (Literal['CurrentWellType', 'current_well_status']):\r\n                    Column to filter on, determines color mapping used\r\n\r\n            Side Effects:\r\n                Updates these visualization parameter DataFrames:\r\n                - df_drilled_parameters\r\n                - df_planned_parameters\r\n                - df_drilling_parameters\r\n\r\n                Modifies:\r\n                - 'color': Changed from default black to type-specific color\r\n                - 'width': Increased from 0.5 to 1.5 for matching wells\r\n\r\n            Notes:\r\n                - Only processes first row per API number since color/type is constant per well\r\n                - Handles three well categories: drilled, planned, and currently drilling\r\n                - Uses predefined color mappings stored in WellTypeColor or WellStatusColor\r\n                - Non-matching wells retain default black color and 0.5 width\r\n                - Changes are reflected immediately in visualization\r\n                - Commonly used for grouping related well types (e.g., all injection wells)\r\n                - Used by the GUI checkbox handlers to update multiple well types at once\r\n\r\n            Example:\r\n                >>> wellCheckedMultiple(['Water Injection Well', 'Gas Injection Well'], 'CurrentWellType')\r\n                # Updates visualization to highlight all injection wells\r\n            \"\"\"\r\n            # Determine color mapping column based on filter type\r\n            colors_lst = 'WellTypeColor' if column == 'CurrentWellType' else 'WellStatusColor'\r\n\r\n            # Get first row for each API number to determine well properties\r\n            drilled_df_restricted = drilled_df.groupby('apinumber').first().reset_index()\r\n            planned_df_restricted = planned_df.groupby('apinumber').first().reset_index()\r\n            currently_drilling_df_restricted = currently_drilling_df.groupby('apinumber').first().reset_index()\r\n\r\n            # Create masks for wells matching any specified type/status\r\n            drilled_well_mask = drilled_df_restricted[column].isin(types)\r\n            planned_well_mask = planned_df_restricted[column].isin(types)\r\n            currently_drilling_well_mask = currently_drilling_df_restricted[column].isin(types)\r\n\r\n            # Update styling for drilled wells\r\n            df_drilled_parameters.loc[drilled_well_mask, 'color'] = drilled_df_restricted.loc[\r\n                drilled_well_mask, colors_lst]\r\n            df_drilled_parameters.loc[drilled_well_mask, 'width'] = 1.5\r\n\r\n            # Update styling for planned wells\r\n            df_planned_parameters.loc[planned_well_mask, 'color'] = planned_df_restricted.loc[\r\n                planned_well_mask, colors_lst]\r\n            df_planned_parameters.loc[planned_well_mask, 'width'] = 1.5\r\n\r\n            # Update styling for currently drilling wells\r\n            df_drilling_parameters.loc[currently_drilling_well_mask, 'color'] = currently_drilling_df_restricted.loc[\r\n                currently_drilling_well_mask, colors_lst]\r\n            df_drilling_parameters.loc[currently_drilling_well_mask, 'width'] = 1.5\r\n\r\n        def toggleWellDisplay(\r\n                condition: bool,\r\n                data_frame: pd.DataFrame,\r\n                segments_2d: List[List[float]],\r\n                colors_init: Union[str, List[str]],\r\n                line_width: Union[float, List[float]],\r\n                well_2d: Line2D,\r\n                well_3d: Line2D,\r\n                vertical_well: Line2D,\r\n                segments_3d: List[List[float]]\r\n        ) -> None:\r\n            \"\"\"\r\n            Toggles the visibility and updates data for well visualization elements based on a boolean condition.\r\n\r\n            Controls the display state and data updates for 2D, 3D and vertical well representations in the\r\n            visualization. When enabled, updates the data and makes wells visible. When disabled, hides the wells\r\n            without removing the underlying data.\r\n\r\n            Args:\r\n                condition (bool): Toggle state - True to show and update wells, False to hide them\r\n                data_frame (pd.DataFrame): Well data to incorporate into currently displayed wells\r\n                    Required columns:\r\n                    - Well identifiers\r\n                    - Coordinate data\r\n                    - Well properties\r\n                segments_2d (List[List[float]]): 2D coordinate segments for well paths\r\n                    Format: [[x1,y1], [x2,y2], ...]\r\n                colors_init (Union[str, List[str]]): Color specification for well lines\r\n                    Either single color string or list of colors per segment\r\n                line_width (Union[float, List[float]]): Width specification for well lines\r\n                    Either single width value or list of widths per segment\r\n                well_2d (Line2D): Matplotlib line object for 2D well representation\r\n                well_3d (Line2D): Matplotlib line object for 3D well representation\r\n                vertical_well (Line2D): Matplotlib line object for vertical well projection\r\n                segments_3d (List[List[float]]): 3D coordinate segments for well paths\r\n                    Format: [[x1,y1,z1], [x2,y2,z2], ...]\r\n\r\n            Side Effects:\r\n                - Updates self.currently_used_lines with new well data when enabled\r\n                - Modifies visibility of well_2d, well_3d and vertical_well line objects\r\n                - Triggers redraw of well visualizations when enabled\r\n                - Changes persist until next toggle operation\r\n\r\n            Notes:\r\n                - Uses drawModelBasedOnParameters2d() for 2D visualization updates\r\n                - Uses drawModelBasedOnParameters() for 3D visualization updates\r\n                - Maintains data state even when wells are hidden\r\n                - Deduplicates data when adding new wells\r\n                - Preserves existing well properties when toggling visibility\r\n\r\n            Example:\r\n                >>> toggleWellDisplay(True, new_wells_df, segs_2d, 'blue', 1.0,\r\n                                      well2d, well3d, vert_well, segs_3d)\r\n                # Shows wells and updates with new data\r\n                >>> toggleWellDisplay(False, new_wells_df, segs_2d, 'blue', 1.0,\r\n                                      well2d, well3d, vert_well, segs_3d)\r\n                # Hides wells without removing data\r\n            \"\"\"\r\n            if condition:\r\n                # Update data and show wells\r\n                self.currently_used_lines = concat([self.currently_used_lines, data_frame]).drop_duplicates(\r\n                    keep='first').reset_index(drop=True)\r\n\r\n                # Redraw 2D and 3D visualizations with updated parameters\r\n                self.drawModelBasedOnParameters2d(well_2d, segments_2d, colors_init, line_width, self.ax2d,\r\n                                                  vertical_well)\r\n                self.drawModelBasedOnParameters(well_3d, segments_3d, colors_init, line_width, self.ax3d)\r\n\r\n                # Make all well representations visible\r\n                well_2d.set_visible(True)\r\n                well_3d.set_visible(True)\r\n                vertical_well.set_visible(True)\r\n            else:\r\n                # Hide all well representations\r\n                well_2d.set_visible(False)\r\n                well_3d.set_visible(False)\r\n                vertical_well.set_visible(False)\r\n\r\n        def statusAndTypesEnabler() -> NoReturn:\r\n            \"\"\"\r\n            Manages well visualization filters and field label visibility based on UI state.\r\n\r\n            Coordinates the mutual exclusivity between well type and status filters while\r\n            maintaining independent control of field label visibility. Handles three main\r\n            aspects of visualization:\r\n            1. Well type filtering (for Oil, Gas, Injection, Disposal wells etc.)\r\n            2. Well status filtering (Producing, Shut-in, P&A, Drilling etc.)\r\n            3. Field name label visibility\r\n\r\n            Radio Button IDs:\r\n                -2: Well Type filtering mode (Oil, Gas, Injection, etc.)\r\n                -3: Well Status filtering mode (Producing, Shut-in, etc.)\r\n\r\n            Field Labels:\r\n                - Displayed as red text at field centroids when enabled\r\n                - Size: 75 units\r\n                - Visibility tied to field_names_checkbox state\r\n\r\n            Side Effects:\r\n                - Updates well visibility based on selected filter mode\r\n                - Modifies field label and section visibility\r\n                - Changes currently_used_lines DataFrame content\r\n                - Triggers field label rendering when enabled\r\n                - Maintains field visibility state independent of filter changes\r\n\r\n            Notes:\r\n                - Part of the well visualization control system\r\n                - Connected to radio button and checkbox state changes\r\n                - Preserves field label state across filter changes\r\n                - Ensures proper layering of visual elements\r\n                - Manages memory by creating field labels only when visible\r\n                - Coordinates with wellTypesEnable() and wellStatusEnable()\r\n\r\n            Example:\r\n                Called when switching between well type/status or toggling field names:\r\n                >>> self.ui.well_type_or_status_button_group.buttonClicked.connect(\r\n                        self.statusAndTypesEnabler)\r\n                >>> self.ui.field_names_checkbox.stateChanged.connect(\r\n                        self.statusAndTypesEnabler)\r\n            \"\"\"\r\n            # Store field checkbox state to preserve across filter changes\r\n            field_checkbox_state = self.ui.field_names_checkbox.isChecked()\r\n\r\n            # Get the ID of currently selected radio button\r\n            active_button_id_type_status = self.ui.well_type_or_status_button_group.checkedId()\r\n\r\n            # Enable well type filtering mode\r\n            if active_button_id_type_status == -2:\r\n                wellTypesEnable()\r\n            # Enable well status filtering mode\r\n            elif active_button_id_type_status == -3:\r\n                wellStatusEnable()\r\n\r\n            # Handle field label visibility independent of filter state\r\n            if field_checkbox_state:\r\n                self.field_sections.set_visible(True)\r\n                # Create field label paths with consistent styling\r\n                paths = [\r\n                    PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\")\r\n                    for coord, text in zip(self.field_centroids_lst, self.field_labels)\r\n                ]\r\n                self.labels_field.set_paths(paths)\r\n                self.labels_field.set_visible(True)\r\n            else:\r\n                self.field_sections.set_visible(False)\r\n                self.labels_field.set_visible(False)\r\n\r\n        def wellTypesEnable() -> NoReturn:\r\n            \"\"\"\r\n            Enables well type filtering while temporarily disabling well status filters.\r\n\r\n            Updates the visualization based on selected well type checkboxes in the UI.\r\n            Temporarily blocks signals from status checkboxes to prevent interference\r\n            between type and status filters.\r\n\r\n            Well Types Handled:\r\n                - Oil Wells\r\n                - Gas Wells\r\n                - Water Disposal Wells (including dual-purpose Oil/Disposal wells)\r\n                - Dry Holes\r\n                - Injection Wells (Water and Gas)\r\n                - Other Wells (Unknown, Test Wells, Water Source Wells)\r\n\r\n            Side Effects:\r\n                # - Temporarily blocks signals from status checkboxes\r\n                - Unchecks all status checkboxes\r\n                - Updates well visualization based on checked type filters\r\n                # - Restores signal handling for status checkboxes\r\n                - Modifies well colors and visibility in the visualization\r\n                - Updates currently_used_lines DataFrame\r\n\r\n            Notes:\r\n                - Uses wellChecked() for single well types\r\n                - Uses wellCheckedMultiple() for grouped well types\r\n                - Ensures mutual exclusivity between type and status filters\r\n                - Part of the well visualization control system\r\n                - Connected to UI checkbox state changes\r\n                - Maintains separation between well type and status filtering\r\n\r\n            Example:\r\n                Called when user interacts with well type checkboxes:\r\n                >>> self.ui.oil_well_check.stateChanged.connect(self.wellTypesEnable)\r\n            \"\"\"\r\n            # Temporarily disable status checkbox signals\r\n            # for q in self.status_checks:\r\n            #     q.blockSignals(True)\r\n            #     q.setChecked(False)\r\n\r\n            # Handle Oil Well selection\r\n            if self.ui.oil_well_check.isChecked():\r\n                wellChecked('Oil Well', 'CurrentWellType')\r\n\r\n            # Handle Gas Well selection\r\n            if self.ui.gas_well_check.isChecked():\r\n                wellChecked('Gas Well', 'CurrentWellType')\r\n\r\n            # Handle Water Disposal Well selection (including combination wells)\r\n            if self.ui.water_disposal_check.isChecked():\r\n                wellCheckedMultiple(['Water Disposal Well', 'Oil Well/Water Disposal Well'], 'CurrentWellType')\r\n\r\n            # Handle Dry Hole selection\r\n            if self.ui.dry_hole_check.isChecked():\r\n                wellChecked('Dry Hole', 'CurrentWellType')\r\n\r\n            # Handle Injection Well selection (both water and gas)\r\n            if self.ui.injection_check.isChecked():\r\n                wellCheckedMultiple(['Water Injection Well', 'Gas Injection Well'], 'CurrentWellType')\r\n\r\n            # Handle Other Well Types selection\r\n            if self.ui.other_well_status_check.isChecked():\r\n                wellCheckedMultiple(['Unknown', 'Test Well', 'Water Source Well'], 'CurrentWellType')\r\n\r\n            # Re-enable status checkbox signals\r\n            # for q in self.status_checks:\r\n            # q.blockSignals(False)\r\n\r\n        def wellStatusEnable() -> NoReturn:\r\n            \"\"\"\r\n            Enables well status filtering while temporarily disabling well type filters.\r\n\r\n            Updates the visualization based on selected well status checkboxes in the UI.\r\n            Temporarily blocks signals from type checkboxes to prevent interference\r\n            between status and type filters.\r\n\r\n            Well Statuses Handled:\r\n                - Shut-in wells\r\n                - Plugged & Abandoned wells\r\n                - Producing wells\r\n                - Currently drilling wells\r\n                - Miscellaneous statuses:\r\n                    - Location Abandoned (APD rescinded)\r\n                    - Returned APD (Unapproved)\r\n                    - Approved Permit\r\n                    - Active\r\n                    - Drilling Operations Suspended\r\n                    - New Permit\r\n                    - Inactive\r\n                    - Temporarily-abandoned\r\n                    - Test/Monitor Wells\r\n\r\n            Side Effects:\r\n                - Temporarily blocks signals from type checkboxes\r\n                - Unchecks all type checkboxes\r\n                - Updates well visualization based on checked status filters\r\n                - Restores signal handling for type checkboxes\r\n                - Modifies well colors and visibility in visualization\r\n                - Updates currently_used_lines DataFrame\r\n\r\n            Notes:\r\n                - Uses wellChecked() for single well statuses\r\n                - Uses wellCheckedMultiple() for grouped miscellaneous statuses\r\n                - Ensures mutual exclusivity between status and type filters\r\n                - Part of the well visualization control system\r\n                - Connected to UI checkbox state changes\r\n                - Maintains separation between well status and type filtering\r\n\r\n            Example:\r\n                Called when user interacts with well status checkboxes:\r\n                >>> self.ui.shut_in_check.stateChanged.connect(self.wellStatusEnable)\r\n            \"\"\"\r\n            # Temporarily disable type checkbox signals\r\n            # for q in self.type_checks:\r\n            #     q.blockSignals(True)\r\n            #     q.setChecked(False)\r\n\r\n            # Handle Shut-in wells\r\n            if self.ui.shut_in_check.isChecked():\r\n                wellChecked('Shut-in', 'current_well_status')\r\n\r\n            # Handle Plugged & Abandoned wells\r\n            if self.ui.pa_check.isChecked():\r\n                wellChecked('Plugged & Abandoned', 'current_well_status')\r\n\r\n            # Handle Producing wells\r\n            if self.ui.producing_check.isChecked():\r\n                wellChecked('Producing', 'current_well_status')\r\n\r\n            # Handle Currently Drilling wells\r\n            if self.ui.drilling_status_check.isChecked():\r\n                wellChecked('Drilling', 'current_well_status')\r\n\r\n            # Handle Miscellaneous well statuses\r\n            if self.ui.misc_well_type_check.isChecked():\r\n                wellCheckedMultiple(['Location Abandoned - APD rescinded',\r\n                                     'Returned APD (Unapproved)', 'Approved Permit',\r\n                                     'Active', 'Drilling Operations Suspended', 'New Permit', 'Inactive',\r\n                                     'Temporarily-abandoned', 'Test Well or Monitor Well'], 'current_well_status')\r\n\r\n            # Re-enable type checkbox signals\r\n            # for q in self.type_checks:\r\n            #     q.blockSignals(False)\r\n\r\n        # Reset current line tracking\r\n        self.currently_used_lines = None\r\n\r\n        # Store segment and DataFrame references locally\r\n        drilled_segments = self.drilled_segments\r\n        planned_segments = self.planned_segments\r\n        currently_drilling_segments = self.currently_drilling_segments\r\n\r\n        drilled_segments_3d = self.drilled_segments_3d\r\n        planned_segments_3d = self.planned_segments_3d\r\n        currently_drilling_segments_3d = self.currently_drilling_segments_3d\r\n\r\n        drilled_df = self.drilled_df\r\n        planned_df = self.planned_df\r\n        currently_drilling_df = self.currently_drilling_df\r\n\r\n        # Process each well category data\r\n        drilled_df, drilled_segments, drilled_segments_3d, data_drilled, df_drilled_parameters = setupData(\r\n            drilled_df, drilled_segments, drilled_segments_3d)\r\n        planned_df, planned_segments, planned_segments_3d, data_planned, df_planned_parameters = setupData(\r\n            planned_df, planned_segments, planned_segments_3d)\r\n        currently_drilling_df, currently_drilling_segments, currently_drilling_segments_3d, data_drilling, df_drilling_parameters = setupData(\r\n            currently_drilling_df, currently_drilling_segments, currently_drilling_segments_3d)\r\n\r\n        # Update well type/status filters\r\n        statusAndTypesEnabler()\r\n        # Handle field name visibility\r\n        if self.ui.field_names_checkbox.isChecked():\r\n            self.field_sections.set_visible(True)\r\n            paths = [PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\")\r\n                     for coord, text in zip(self.field_centroids_lst, self.field_labels)]\r\n            self.labels_field.set_paths(paths)\r\n            self.labels_field.set_visible(True)\r\n        else:\r\n            self.field_sections.set_visible(False)\r\n            self.labels_field.set_visible(False)\r\n\r\n        # Extract visualization parameters\r\n        drilled_colors_init, drilled_line_width = df_drilled_parameters['color'].tolist(), df_drilled_parameters[\r\n            'width'].tolist()\r\n        planned_colors_init, planned_line_width = df_planned_parameters['color'].tolist(), df_planned_parameters[\r\n            'width'].tolist()\r\n        currently_drilling_colors_init, currently_drilling_width = df_drilling_parameters['color'].tolist(), \\\r\n            df_drilling_parameters['width'].tolist()\r\n\r\n        # Toggle visibility for each well category\r\n        toggleWellDisplay(\r\n            self.ui.asdrilled_check.isChecked(), drilled_df,\r\n            drilled_segments, drilled_colors_init, drilled_line_width,\r\n            self.all_wells_2d_asdrilled, self.all_wells_3d_asdrilled,\r\n            self.all_wells_2d_vertical_asdrilled, drilled_segments_3d)\r\n\r\n        toggleWellDisplay(\r\n            self.ui.planned_check.isChecked(), planned_df,\r\n            planned_segments, planned_colors_init, planned_line_width,\r\n            self.all_wells_2d_planned, self.all_wells_3d_planned,\r\n            self.all_wells_2d_vertical_planned, planned_segments_3d)\r\n\r\n        toggleWellDisplay(\r\n            self.ui.currently_drilling_check.isChecked(), currently_drilling_df,\r\n            currently_drilling_segments, currently_drilling_colors_init, currently_drilling_width,\r\n            self.all_wells_2d_current, self.all_wells_3d_current,\r\n            self.all_wells_2d_vertical_current, currently_drilling_segments_3d)\r\n\r\n        # Update 3D plot boundaries if drilled segments exist\r\n        if drilled_segments_3d:\r\n            self.centroid, std_vals = self.calculateCentroidNP(drilled_segments_3d)\r\n            new_xlim = [self.centroid[0] - 10000, self.centroid[0] + 10000]\r\n            new_ylim = [self.centroid[1] - 10000, self.centroid[1] + 10000]\r\n            new_zlim = [self.centroid[2] - 10000, self.centroid[2] + 10000]\r\n            self.ax3d.set_xlim3d(new_xlim)\r\n            self.ax3d.set_ylim3d(new_ylim)\r\n            self.ax3d.set_zlim3d(new_zlim)\r\n\r\n        # Refresh all canvases\r\n        self.canvas2d.blit(self.ax2d.bbox)\r\n        self.canvas2d.draw()\r\n        self.canvas3d.blit(self.ax3d.bbox)\r\n        self.canvas3d.draw()\r\n\r\n\r\nclass Drawer2:\r\n    def __init__(self, ui, used_df_dx, well_info_df):\r\n        self.segment_properties = None\r\n        self.df_wells = None\r\n        self.segments_per_drilling_status = None\r\n        self.field_sections = None\r\n\r\n        def clear_widget(widget):\r\n            for i in reversed(range(widget.layout().count())):\r\n                widget.layout().itemAt(i).widget().setParent(None)\r\n\r\n        def clear_layout(layout):\r\n            while layout.count():\r\n                child = layout.takeAt(0)\r\n                if child.widget():\r\n                    child.widget().deleteLater()\r\n        self.ui = ui\r\n        self.well_info_df = well_info_df\r\n        self.surveys = used_df_dx\r\n        self.type_color_map = {\r\n            'Oil Well': '#c34c00',  # Red\r\n            'Gas Well': '#f1aa00',  # Orange\r\n            'Water Disposal Well': '#0032b0',  # Blue\r\n            'Oil Well/Water Disposal Well': '#0032b0',  # Blue\r\n            'Water Injection Well': '#93ebff',  # Cyan\r\n            'Gas Injection Well': '#93ebff',  # Cyan\r\n            'Dry Hole': '#4f494b',  # Dark Gray\r\n            'Unknown': '#985bee',  # Magenta\r\n            'Test Well': '#985bee',  # Magenta\r\n            'Water Source Well': '#985bee'  # Magenta\r\n        }\r\n\r\n        # Define color mappings for well status\r\n        self.status_color_map = {\r\n            'Producing': '#a2e361',  # Green\r\n            'Plugged & Abandoned': '#4c2d77',  # Purple\r\n            'Shut In': '#D2B48C',  # tan\r\n            'Drilling': '#001958',  # Navy\r\n            'Other': '#4a7583'  # Teal\r\n        }\r\n        self.drilling_styles = {\r\n            'drilled': {'linestyle': '-'},\r\n            'planned': {'linestyle': '--'},\r\n            'currently_drilling': {'linestyle': ':'}\r\n        }\r\n\r\n        self.figure2d = plt.figure()\r\n        self.canvas2d = FigureCanvas(self.figure2d)\r\n        self.ax2d = self.figure2d.subplots()\r\n        self.ui.well_graphic_mp_2d_model.addWidget(self.canvas2d)\r\n        self.all_wells_2d_planned = LineCollection([], colors='black', linewidths=0.5, linestyles='--', zorder=1)\r\n        self.ax2d.add_collection(self.all_wells_2d_planned)\r\n\r\n        self.draw_2d_data_all(well_info_df, used_df_dx)\r\n\r\n    # def manipulateTheDfDocketDataDependingOnCheckboxes(self):\r\n    #     \"\"\"\r\n    #        Main function for managing well visualization based on UI checkbox states.\r\n    #\r\n    #        Controls the display of different well types (drilled, planned, currently drilling)\r\n    #        and their properties in both 2D and 3D views. Handles well filtering, visibility,\r\n    #        styling, and related UI elements like field names.\r\n    #\r\n    #        Attributes Modified:\r\n    #            currently_used_lines (DataFrame): Tracks which well lines are currently displayed\r\n    #            field_sections (Artist): Visual elements for field sections\r\n    #            labels_field (Artist): Text labels for fields\r\n    #            Various matplotlib artists for well visualization\r\n    #\r\n    #        Side Effects:\r\n    #            - Updates 2D and 3D matplotlib canvases\r\n    #            - Modifies well line visibility and styling\r\n    #            - Updates field name labels\r\n    #            - Adjusts 3D view limits based on well positions\r\n    #            - Triggers well type/status filtering\r\n    #\r\n    #        Processing Steps:\r\n    #            1. Initializes local data references\r\n    #            2. Sets up data parameters for each well category\r\n    #            3. Applies type/status filtering\r\n    #            4. Handles field name visibility\r\n    #            5. Processes well display parameters\r\n    #            6. Toggles visibility for different well categories\r\n    #            7. Adjusts 3D view boundaries\r\n    #            8. Updates visualization canvases\r\n    #\r\n    #        Notes:\r\n    #            - Central function for well visualization control\r\n    #            - Connected to multiple UI checkbox events\r\n    #            - Manages both 2D and 3D visualizations\r\n    #            - Handles three main well categories:\r\n    #                * As-drilled wells\r\n    #                * Planned wells\r\n    #                * Currently drilling wells\r\n    #            - Maintains visualization consistency across views\r\n    #            - Uses helper functions for data setup and display\r\n    #\r\n    #        Dependencies:\r\n    #            - setupData(): Prepares well data parameters\r\n    #            - statusAndTypesEnabler(): Manages well filtering\r\n    #            - toggleWellDisplay(): Controls well visibility\r\n    #            - calculateCentroidNP(): Computes 3D view center\r\n    #        \"\"\"\r\n    #\r\n    #     def platBounded(\r\n    #             df: pd.DataFrame,\r\n    #             segments: List[List[List[float]]],\r\n    #             segments_3d: List[List[List[float]]]\r\n    #     ) -> Tuple[pd.DataFrame, List[List[List[float]]], List[List[List[float]]]]:\r\n    #         \"\"\"\r\n    #         Filters and reorders well data and segments based on API numbers and measured depth.\r\n    #\r\n    #         Sorts well data by API number and measured depth, then filters the 2D and 3D\r\n    #         segment data to match only the wells present in the DataFrame. Maintains data\r\n    #         consistency across different representations of the same wells.\r\n    #\r\n    #         Args:\r\n    #             df (pd.DataFrame): Well data containing:\r\n    #                 Required columns:\r\n    #                 - apinumber: Unique well identifier\r\n    #                 - measured_depth: Depth measurement along wellbore\r\n    #             segments (List[List[List[float]]]): 2D coordinate segments for visualization\r\n    #                 Format: [well][segment][x,y coordinates]\r\n    #             segments_3d (List[List[List[float]]]): 3D coordinate segments for visualization\r\n    #                 Format: [well][segment][z coordinates]\r\n    #\r\n    #         Returns:\r\n    #             Tuple containing:\r\n    #             - pd.DataFrame: Sorted and filtered well data\r\n    #             - List[List[List[float]]]: Filtered 2D segments matching DataFrame wells\r\n    #             - List[List[List[float]]]: Filtered 3D segments matching DataFrame wells\r\n    #\r\n    #         Notes:\r\n    #             - Maintains data consistency by filtering segments to match DataFrame wells\r\n    #             - Preserves original data structure and relationships\r\n    #             - Handles potential mismatches between DataFrame and segment data\r\n    #             - Returns empty lists for segments if no matches found\r\n    #\r\n    #         Example:\r\n    #             >>> df_filtered, seg_2d, seg_3d = platBounded(well_df, segments_2d, segments_3d)\r\n    #             >>> print(f\"Filtered to {len(seg_2d)} wells\")\r\n    #         \"\"\"\r\n    #         # Sort DataFrame by API number and measured depth\r\n    #         df = df.sort_values(by=['apinumber', 'measured_depth'])\r\n    #\r\n    #         # Create index mapping for API numbers\r\n    #         api = df[['apinumber']].drop_duplicates().reset_index(drop=True)\r\n    #         api['index'] = api.index\r\n    #\r\n    #         # Merge to maintain relationships\r\n    #         merged = pd.merge(api, df, left_on='apinumber', right_on='apinumber')\r\n    #\r\n    #         # Filter segments to match DataFrame wells\r\n    #         segments = [segments[i] for i in range(len(segments)) if i in merged['index'].unique()]\r\n    #         segments_3d = [segments_3d[i] for i in range(len(segments_3d)) if i in merged['index'].unique()]\r\n    #\r\n    #         return df, segments, segments_3d\r\n    #\r\n    #     def setupData(\r\n    #             df: pd.DataFrame,\r\n    #             segments: List[List[List[float]]],\r\n    #             segments_3d: List[List[List[float]]]\r\n    #     ) -> Tuple[pd.DataFrame, List[List[List[float]]], List[List[List[float]]], Dict, pd.DataFrame]:\r\n    #         \"\"\"\r\n    #         Prepares well data and visualization parameters by filtering data and setting up default styling.\r\n    #\r\n    #         Processes well data through platBounded filter and creates default visualization\r\n    #         parameters for well segments including color and width attributes.\r\n    #\r\n    #         Args:\r\n    #             df (pd.DataFrame): Well data containing:\r\n    #                 Required columns:\r\n    #                 - apinumber: Unique well identifier\r\n    #                 - measured_depth: Depth measurement along wellbore\r\n    #             segments (List[List[List[float]]]): 2D coordinate segments for visualization\r\n    #                 Format: [well][segment][x,y coordinates]\r\n    #             segments_3d (List[List[List[float]]]): 3D coordinate segments for visualization\r\n    #                 Format: [well][segment][z coordinates]\r\n    #\r\n    #         Returns:\r\n    #             Tuple containing:\r\n    #             - pd.DataFrame: Filtered and sorted well data\r\n    #             - List[List[List[float]]]: Filtered 2D segments\r\n    #             - List[List[List[float]]]: Filtered 3D segments\r\n    #             - Dict: Default styling parameters dictionary with:\r\n    #                 - color: List of colors (default 'black')\r\n    #                 - width: List of line widths (default 0.5)\r\n    #             - pd.DataFrame: Styling parameters as DataFrame\r\n    #\r\n    #         Notes:\r\n    #             - Uses platBounded to filter and align data\r\n    #             - Creates consistent default styling for all well segments\r\n    #             - Styling can be modified later by other functions\r\n    #             - Returns both dict and DataFrame versions of styling parameters\r\n    #             - All segments receive identical initial styling\r\n    #\r\n    #         Example:\r\n    #             >>> df, segs_2d, segs_3d, style_dict, style_df = setupData(wells_df, segments_2d, segments_3d)\r\n    #             >>> print(f\"Styled {len(style_df)} well segments\")\r\n    #         \"\"\"\r\n    #         # Filter and align data using platBounded\r\n    #         df, segments, segments_3d = platBounded(df, segments, segments_3d)\r\n    #\r\n    #         # Create default styling parameters\r\n    #         data = {'color': ['black'] * len(segments), 'width': [0.5] * len(segments)}\r\n    #\r\n    #         # Convert styling parameters to DataFrame\r\n    #         df_parameters = pd.DataFrame(data)\r\n    #\r\n    #         return df, segments, segments_3d, data, df_parameters\r\n    #\r\n    #     def wellChecked(\r\n    #             type: str,\r\n    #             column: Literal['CurrentWellType', 'current_well_status']\r\n    #     ) -> None:\r\n    #         \"\"\"\r\n    #         Updates well visualization parameters based on specified well type or status filter.\r\n    #\r\n    #         Modifies the styling (color and line width) of well segments in the visualization\r\n    #         based on either well type (e.g., Oil, Gas) or well status (e.g., Producing,\r\n    #         Shut-in). Wells matching the filter criteria are highlighted with specific colors\r\n    #         and increased line width.\r\n    #\r\n    #         Args:\r\n    #             type (str): Well type or status to filter by. Valid values depend on column:\r\n    #                 For CurrentWellType:\r\n    #                     - 'Oil Well'\r\n    #                     - 'Gas Well'\r\n    #                     - 'Water Disposal Well'\r\n    #                     - 'Water Injection Well'\r\n    #                     - 'Gas Injection Well'\r\n    #                     - 'Dry Hole'\r\n    #                     - 'Test Well'\r\n    #                     - 'Water Source Well'\r\n    #                     - 'Unknown'\r\n    #                 For current_well_status:\r\n    #                     - Status values from well database\r\n    #             column (Literal['CurrentWellType', 'current_well_status']):\r\n    #                 Column to filter on, determines color mapping used\r\n    #\r\n    #         Side Effects:\r\n    #             Updates these visualization parameter DataFrames:\r\n    #             - df_drilled_parameters\r\n    #             - df_planned_parameters\r\n    #             - df_drilling_parameters\r\n    #\r\n    #             Modifies:\r\n    #             - 'color': Changed from default black to type-specific color\r\n    #             - 'width': Increased from 0.5 to 1.5 for matching wells\r\n    #\r\n    #         Notes:\r\n    #             - Only processes first row per API number since color/type is constant per well\r\n    #             - Handles three well categories: drilled, planned, and currently drilling\r\n    #             - Uses predefined color mappings stored in WellTypeColor or WellStatusColor\r\n    #             - Non-matching wells retain default black color and 0.5 width\r\n    #             - Changes are reflected immediately in visualization\r\n    #\r\n    #         Example:\r\n    #             >>> wellChecked('Oil Well', 'CurrentWellType')\r\n    #             # Updates visualization to highlight all oil wells in red\r\n    #         \"\"\"\r\n    #         # Determine color mapping column based on filter type\r\n    #         colors_lst = 'WellTypeColor' if column == 'CurrentWellType' else 'WellStatusColor'\r\n    #\r\n    #         # Get first row for each API number to determine well properties\r\n    #         drilled_df_restricted = drilled_df.groupby('apinumber').first().reset_index()\r\n    #         planned_df_restricted = planned_df.groupby('apinumber').first().reset_index()\r\n    #         currently_drilling_df_restricted = currently_drilling_df.groupby('apinumber').first().reset_index()\r\n    #\r\n    #         # Create masks for wells matching specified type/status\r\n    #         drilled_well_mask = drilled_df_restricted[column] == type\r\n    #         planned_well_mask = planned_df_restricted[column] == type\r\n    #         currently_drilling_well_mask = currently_drilling_df_restricted[column] == type\r\n    #\r\n    #         # Update styling for drilled wells\r\n    #         df_drilled_parameters.loc[drilled_well_mask, 'color'] = drilled_df_restricted.loc[\r\n    #             drilled_well_mask, colors_lst]\r\n    #         df_drilled_parameters.loc[drilled_well_mask, 'width'] = 1.5\r\n    #\r\n    #         # Update styling for planned wells\r\n    #         df_planned_parameters.loc[planned_well_mask, 'color'] = planned_df_restricted.loc[\r\n    #             planned_well_mask, colors_lst]\r\n    #         df_planned_parameters.loc[planned_well_mask, 'width'] = 1.5\r\n    #\r\n    #         # Update styling for currently drilling wells\r\n    #         df_drilling_parameters.loc[currently_drilling_well_mask, 'color'] = currently_drilling_df_restricted.loc[\r\n    #             currently_drilling_well_mask, colors_lst]\r\n    #         df_drilling_parameters.loc[currently_drilling_well_mask, 'width'] = 1.5\r\n    #\r\n    #     def wellCheckedMultiple(\r\n    #             types: List[str],\r\n    #             column: Literal['CurrentWellType', 'current_well_status']\r\n    #     ) -> None:\r\n    #         \"\"\"\r\n    #         Updates well visualization parameters for multiple well types or statuses simultaneously.\r\n    #\r\n    #         Similar to wellChecked() but handles multiple types/statuses at once. Modifies the styling\r\n    #         (color and line width) of well segments in the visualization based on a list of well\r\n    #         types or statuses. Wells matching any of the filter criteria are highlighted.\r\n    #\r\n    #         Args:\r\n    #             types (List[str]): List of well types or statuses to filter by. Valid values depend on column:\r\n    #                 For CurrentWellType:\r\n    #                     - 'Oil Well'\r\n    #                     - 'Gas Well'\r\n    #                     - 'Water Disposal Well'\r\n    #                     - 'Oil Well/Water Disposal Well'\r\n    #                     - 'Water Injection Well'\r\n    #                     - 'Gas Injection Well'\r\n    #                     - 'Dry Hole'\r\n    #                     - etc.\r\n    #                 For current_well_status:\r\n    #                     - 'Location Abandoned - APD rescinded'\r\n    #                     - 'Returned APD (Unapproved)'\r\n    #                     - 'Approved Permit'\r\n    #                     - 'Active'\r\n    #                     - 'Drilling Operations Suspended'\r\n    #                     - 'New Permit'\r\n    #                     - 'Inactive'\r\n    #                     - 'Temporarily-abandoned'\r\n    #                     - 'Test Well or Monitor Well'\r\n    #                     - etc.\r\n    #             column (Literal['CurrentWellType', 'current_well_status']):\r\n    #                 Column to filter on, determines color mapping used\r\n    #\r\n    #         Side Effects:\r\n    #             Updates these visualization parameter DataFrames:\r\n    #             - df_drilled_parameters\r\n    #             - df_planned_parameters\r\n    #             - df_drilling_parameters\r\n    #\r\n    #             Modifies:\r\n    #             - 'color': Changed from default black to type-specific color\r\n    #             - 'width': Increased from 0.5 to 1.5 for matching wells\r\n    #\r\n    #         Notes:\r\n    #             - Only processes first row per API number since color/type is constant per well\r\n    #             - Handles three well categories: drilled, planned, and currently drilling\r\n    #             - Uses predefined color mappings stored in WellTypeColor or WellStatusColor\r\n    #             - Non-matching wells retain default black color and 0.5 width\r\n    #             - Changes are reflected immediately in visualization\r\n    #             - Commonly used for grouping related well types (e.g., all injection wells)\r\n    #             - Used by the GUI checkbox handlers to update multiple well types at once\r\n    #\r\n    #         Example:\r\n    #             >>> wellCheckedMultiple(['Water Injection Well', 'Gas Injection Well'], 'CurrentWellType')\r\n    #             # Updates visualization to highlight all injection wells\r\n    #         \"\"\"\r\n    #         # Determine color mapping column based on filter type\r\n    #         colors_lst = 'WellTypeColor' if column == 'CurrentWellType' else 'WellStatusColor'\r\n    #\r\n    #         # Get first row for each API number to determine well properties\r\n    #         drilled_df_restricted = drilled_df.groupby('apinumber').first().reset_index()\r\n    #         planned_df_restricted = planned_df.groupby('apinumber').first().reset_index()\r\n    #         currently_drilling_df_restricted = currently_drilling_df.groupby('apinumber').first().reset_index()\r\n    #\r\n    #         # Create masks for wells matching any specified type/status\r\n    #         drilled_well_mask = drilled_df_restricted[column].isin(types)\r\n    #         planned_well_mask = planned_df_restricted[column].isin(types)\r\n    #         currently_drilling_well_mask = currently_drilling_df_restricted[column].isin(types)\r\n    #\r\n    #         # Update styling for drilled wells\r\n    #         df_drilled_parameters.loc[drilled_well_mask, 'color'] = drilled_df_restricted.loc[\r\n    #             drilled_well_mask, colors_lst]\r\n    #         df_drilled_parameters.loc[drilled_well_mask, 'width'] = 1.5\r\n    #\r\n    #         # Update styling for planned wells\r\n    #         df_planned_parameters.loc[planned_well_mask, 'color'] = planned_df_restricted.loc[\r\n    #             planned_well_mask, colors_lst]\r\n    #         df_planned_parameters.loc[planned_well_mask, 'width'] = 1.5\r\n    #\r\n    #         # Update styling for currently drilling wells\r\n    #         df_drilling_parameters.loc[currently_drilling_well_mask, 'color'] = currently_drilling_df_restricted.loc[\r\n    #             currently_drilling_well_mask, colors_lst]\r\n    #         df_drilling_parameters.loc[currently_drilling_well_mask, 'width'] = 1.5\r\n    #\r\n    #     def toggleWellDisplay(\r\n    #             condition: bool,\r\n    #             data_frame: pd.DataFrame,\r\n    #             segments_2d: List[List[float]],\r\n    #             colors_init: Union[str, List[str]],\r\n    #             line_width: Union[float, List[float]],\r\n    #             well_2d: Line2D,\r\n    #             well_3d: Line2D,\r\n    #             vertical_well: Line2D,\r\n    #             segments_3d: List[List[float]]\r\n    #     ) -> None:\r\n    #         \"\"\"\r\n    #         Toggles the visibility and updates data for well visualization elements based on a boolean condition.\r\n    #\r\n    #         Controls the display state and data updates for 2D, 3D and vertical well representations in the\r\n    #         visualization. When enabled, updates the data and makes wells visible. When disabled, hides the wells\r\n    #         without removing the underlying data.\r\n    #\r\n    #         Args:\r\n    #             condition (bool): Toggle state - True to show and update wells, False to hide them\r\n    #             data_frame (pd.DataFrame): Well data to incorporate into currently displayed wells\r\n    #                 Required columns:\r\n    #                 - Well identifiers\r\n    #                 - Coordinate data\r\n    #                 - Well properties\r\n    #             segments_2d (List[List[float]]): 2D coordinate segments for well paths\r\n    #                 Format: [[x1,y1], [x2,y2], ...]\r\n    #             colors_init (Union[str, List[str]]): Color specification for well lines\r\n    #                 Either single color string or list of colors per segment\r\n    #             line_width (Union[float, List[float]]): Width specification for well lines\r\n    #                 Either single width value or list of widths per segment\r\n    #             well_2d (Line2D): Matplotlib line object for 2D well representation\r\n    #             well_3d (Line2D): Matplotlib line object for 3D well representation\r\n    #             vertical_well (Line2D): Matplotlib line object for vertical well projection\r\n    #             segments_3d (List[List[float]]): 3D coordinate segments for well paths\r\n    #                 Format: [[x1,y1,z1], [x2,y2,z2], ...]\r\n    #\r\n    #         Side Effects:\r\n    #             - Updates self.currently_used_lines with new well data when enabled\r\n    #             - Modifies visibility of well_2d, well_3d and vertical_well line objects\r\n    #             - Triggers redraw of well visualizations when enabled\r\n    #             - Changes persist until next toggle operation\r\n    #\r\n    #         Notes:\r\n    #             - Uses drawModelBasedOnParameters2d() for 2D visualization updates\r\n    #             - Uses drawModelBasedOnParameters() for 3D visualization updates\r\n    #             - Maintains data state even when wells are hidden\r\n    #             - Deduplicates data when adding new wells\r\n    #             - Preserves existing well properties when toggling visibility\r\n    #\r\n    #         Example:\r\n    #             >>> toggleWellDisplay(True, new_wells_df, segs_2d, 'blue', 1.0,\r\n    #                                   well2d, well3d, vert_well, segs_3d)\r\n    #             # Shows wells and updates with new data\r\n    #             >>> toggleWellDisplay(False, new_wells_df, segs_2d, 'blue', 1.0,\r\n    #                                   well2d, well3d, vert_well, segs_3d)\r\n    #             # Hides wells without removing data\r\n    #         \"\"\"\r\n    #         if condition:\r\n    #             # Update data and show wells\r\n    #             self.currently_used_lines = concat([self.currently_used_lines, data_frame]).drop_duplicates(\r\n    #                 keep='first').reset_index(drop=True)\r\n    #\r\n    #             # Redraw 2D and 3D visualizations with updated parameters\r\n    #             self.drawModelBasedOnParameters2d(well_2d, segments_2d, colors_init, line_width, self.ax2d,\r\n    #                                               vertical_well)\r\n    #             self.drawModelBasedOnParameters(well_3d, segments_3d, colors_init, line_width, self.ax3d)\r\n    #\r\n    #             # Make all well representations visible\r\n    #             well_2d.set_visible(True)\r\n    #             well_3d.set_visible(True)\r\n    #             vertical_well.set_visible(True)\r\n    #         else:\r\n    #             # Hide all well representations\r\n    #             well_2d.set_visible(False)\r\n    #             well_3d.set_visible(False)\r\n    #             vertical_well.set_visible(False)\r\n    #\r\n    #     def statusAndTypesEnabler() -> NoReturn:\r\n    #         \"\"\"\r\n    #         Manages well visualization filters and field label visibility based on UI state.\r\n    #\r\n    #         Coordinates the mutual exclusivity between well type and status filters while\r\n    #         maintaining independent control of field label visibility. Handles three main\r\n    #         aspects of visualization:\r\n    #         1. Well type filtering (for Oil, Gas, Injection, Disposal wells etc.)\r\n    #         2. Well status filtering (Producing, Shut-in, P&A, Drilling etc.)\r\n    #         3. Field name label visibility\r\n    #\r\n    #         Radio Button IDs:\r\n    #             -2: Well Type filtering mode (Oil, Gas, Injection, etc.)\r\n    #             -3: Well Status filtering mode (Producing, Shut-in, etc.)\r\n    #\r\n    #         Field Labels:\r\n    #             - Displayed as red text at field centroids when enabled\r\n    #             - Size: 75 units\r\n    #             - Visibility tied to field_names_checkbox state\r\n    #\r\n    #         Side Effects:\r\n    #             - Updates well visibility based on selected filter mode\r\n    #             - Modifies field label and section visibility\r\n    #             - Changes currently_used_lines DataFrame content\r\n    #             - Triggers field label rendering when enabled\r\n    #             - Maintains field visibility state independent of filter changes\r\n    #\r\n    #         Notes:\r\n    #             - Part of the well visualization control system\r\n    #             - Connected to radio button and checkbox state changes\r\n    #             - Preserves field label state across filter changes\r\n    #             - Ensures proper layering of visual elements\r\n    #             - Manages memory by creating field labels only when visible\r\n    #             - Coordinates with wellTypesEnable() and wellStatusEnable()\r\n    #\r\n    #         Example:\r\n    #             Called when switching between well type/status or toggling field names:\r\n    #             >>> self.ui.well_type_or_status_button_group.buttonClicked.connect(\r\n    #                     self.statusAndTypesEnabler)\r\n    #             >>> self.ui.field_names_checkbox.stateChanged.connect(\r\n    #                     self.statusAndTypesEnabler)\r\n    #         \"\"\"\r\n    #         # Store field checkbox state to preserve across filter changes\r\n    #         field_checkbox_state = self.ui.field_names_checkbox.isChecked()\r\n    #\r\n    #         # Get the ID of currently selected radio button\r\n    #         active_button_id_type_status = self.ui.well_type_or_status_button_group.checkedId()\r\n    #\r\n    #         # Enable well type filtering mode\r\n    #         if active_button_id_type_status == -2:\r\n    #             wellTypesEnable()\r\n    #         # Enable well status filtering mode\r\n    #         elif active_button_id_type_status == -3:\r\n    #             wellStatusEnable()\r\n    #\r\n    #         # Handle field label visibility independent of filter state\r\n    #         if field_checkbox_state:\r\n    #             self.field_sections.set_visible(True)\r\n    #             # Create field label paths with consistent styling\r\n    #             paths = [\r\n    #                 PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\")\r\n    #                 for coord, text in zip(self.field_centroids_lst, self.field_labels)\r\n    #             ]\r\n    #             self.labels_field.set_paths(paths)\r\n    #             self.labels_field.set_visible(True)\r\n    #         else:\r\n    #             self.field_sections.set_visible(False)\r\n    #             self.labels_field.set_visible(False)\r\n    #\r\n    #     def wellTypesEnable() -> NoReturn:\r\n    #         \"\"\"\r\n    #         Enables well type filtering while temporarily disabling well status filters.\r\n    #\r\n    #         Updates the visualization based on selected well type checkboxes in the UI.\r\n    #         Temporarily blocks signals from status checkboxes to prevent interference\r\n    #         between type and status filters.\r\n    #\r\n    #         Well Types Handled:\r\n    #             - Oil Wells\r\n    #             - Gas Wells\r\n    #             - Water Disposal Wells (including dual-purpose Oil/Disposal wells)\r\n    #             - Dry Holes\r\n    #             - Injection Wells (Water and Gas)\r\n    #             - Other Wells (Unknown, Test Wells, Water Source Wells)\r\n    #\r\n    #         Side Effects:\r\n    #             # - Temporarily blocks signals from status checkboxes\r\n    #             - Unchecks all status checkboxes\r\n    #             - Updates well visualization based on checked type filters\r\n    #             # - Restores signal handling for status checkboxes\r\n    #             - Modifies well colors and visibility in the visualization\r\n    #             - Updates currently_used_lines DataFrame\r\n    #\r\n    #         Notes:\r\n    #             - Uses wellChecked() for single well types\r\n    #             - Uses wellCheckedMultiple() for grouped well types\r\n    #             - Ensures mutual exclusivity between type and status filters\r\n    #             - Part of the well visualization control system\r\n    #             - Connected to UI checkbox state changes\r\n    #             - Maintains separation between well type and status filtering\r\n    #\r\n    #         Example:\r\n    #             Called when user interacts with well type checkboxes:\r\n    #             >>> self.ui.oil_well_check.stateChanged.connect(self.wellTypesEnable)\r\n    #         \"\"\"\r\n    #         # Temporarily disable status checkbox signals\r\n    #         # for q in self.status_checks:\r\n    #         #     q.blockSignals(True)\r\n    #         #     q.setChecked(False)\r\n    #\r\n    #         # Handle Oil Well selection\r\n    #         if self.ui.oil_well_check.isChecked():\r\n    #             wellChecked('Oil Well', 'CurrentWellType')\r\n    #\r\n    #         # Handle Gas Well selection\r\n    #         if self.ui.gas_well_check.isChecked():\r\n    #             wellChecked('Gas Well', 'CurrentWellType')\r\n    #\r\n    #         # Handle Water Disposal Well selection (including combination wells)\r\n    #         if self.ui.water_disposal_check.isChecked():\r\n    #             wellCheckedMultiple(['Water Disposal Well', 'Oil Well/Water Disposal Well'], 'CurrentWellType')\r\n    #\r\n    #         # Handle Dry Hole selection\r\n    #         if self.ui.dry_hole_check.isChecked():\r\n    #             wellChecked('Dry Hole', 'CurrentWellType')\r\n    #\r\n    #         # Handle Injection Well selection (both water and gas)\r\n    #         if self.ui.injection_check.isChecked():\r\n    #             wellCheckedMultiple(['Water Injection Well', 'Gas Injection Well'], 'CurrentWellType')\r\n    #\r\n    #         # Handle Other Well Types selection\r\n    #         if self.ui.other_well_status_check.isChecked():\r\n    #             wellCheckedMultiple(['Unknown', 'Test Well', 'Water Source Well'], 'CurrentWellType')\r\n    #\r\n    #         # Re-enable status checkbox signals\r\n    #         # for q in self.status_checks:\r\n    #         # q.blockSignals(False)\r\n    #\r\n    #     def wellStatusEnable() -> NoReturn:\r\n    #         \"\"\"\r\n    #         Enables well status filtering while temporarily disabling well type filters.\r\n    #\r\n    #         Updates the visualization based on selected well status checkboxes in the UI.\r\n    #         Temporarily blocks signals from type checkboxes to prevent interference\r\n    #         between status and type filters.\r\n    #\r\n    #         Well Statuses Handled:\r\n    #             - Shut-in wells\r\n    #             - Plugged & Abandoned wells\r\n    #             - Producing wells\r\n    #             - Currently drilling wells\r\n    #             - Miscellaneous statuses:\r\n    #                 - Location Abandoned (APD rescinded)\r\n    #                 - Returned APD (Unapproved)\r\n    #                 - Approved Permit\r\n    #                 - Active\r\n    #                 - Drilling Operations Suspended\r\n    #                 - New Permit\r\n    #                 - Inactive\r\n    #                 - Temporarily-abandoned\r\n    #                 - Test/Monitor Wells\r\n    #\r\n    #         Side Effects:\r\n    #             - Temporarily blocks signals from type checkboxes\r\n    #             - Unchecks all type checkboxes\r\n    #             - Updates well visualization based on checked status filters\r\n    #             - Restores signal handling for type checkboxes\r\n    #             - Modifies well colors and visibility in visualization\r\n    #             - Updates currently_used_lines DataFrame\r\n    #\r\n    #         Notes:\r\n    #             - Uses wellChecked() for single well statuses\r\n    #             - Uses wellCheckedMultiple() for grouped miscellaneous statuses\r\n    #             - Ensures mutual exclusivity between status and type filters\r\n    #             - Part of the well visualization control system\r\n    #             - Connected to UI checkbox state changes\r\n    #             - Maintains separation between well status and type filtering\r\n    #\r\n    #         Example:\r\n    #             Called when user interacts with well status checkboxes:\r\n    #             >>> self.ui.shut_in_check.stateChanged.connect(self.wellStatusEnable)\r\n    #         \"\"\"\r\n    #         # Temporarily disable type checkbox signals\r\n    #         # for q in self.type_checks:\r\n    #         #     q.blockSignals(True)\r\n    #         #     q.setChecked(False)\r\n    #\r\n    #         # Handle Shut-in wells\r\n    #         if self.ui.shut_in_check.isChecked():\r\n    #             wellChecked('Shut-in', 'current_well_status')\r\n    #\r\n    #         # Handle Plugged & Abandoned wells\r\n    #         if self.ui.pa_check.isChecked():\r\n    #             wellChecked('Plugged & Abandoned', 'current_well_status')\r\n    #\r\n    #         # Handle Producing wells\r\n    #         if self.ui.producing_check.isChecked():\r\n    #             wellChecked('Producing', 'current_well_status')\r\n    #\r\n    #         # Handle Currently Drilling wells\r\n    #         if self.ui.drilling_status_check.isChecked():\r\n    #             wellChecked('Drilling', 'current_well_status')\r\n    #\r\n    #         # Handle Miscellaneous well statuses\r\n    #         if self.ui.misc_well_type_check.isChecked():\r\n    #             wellCheckedMultiple(['Location Abandoned - APD rescinded',\r\n    #                                  'Returned APD (Unapproved)', 'Approved Permit',\r\n    #                                  'Active', 'Drilling Operations Suspended', 'New Permit', 'Inactive',\r\n    #                                  'Temporarily-abandoned', 'Test Well or Monitor Well'], 'current_well_status')\r\n    #\r\n    #         # Re-enable type checkbox signals\r\n    #         # for q in self.type_checks:\r\n    #         #     q.blockSignals(False)\r\n    #\r\n    #     # Reset current line tracking\r\n    #     self.currently_used_lines = None\r\n    #\r\n    #     # Store segment and DataFrame references locally\r\n    #     drilled_segments = self.drilled_segments\r\n    #     planned_segments = self.planned_segments\r\n    #     currently_drilling_segments = self.currently_drilling_segments\r\n    #\r\n    #     drilled_segments_3d = self.drilled_segments_3d\r\n    #     planned_segments_3d = self.planned_segments_3d\r\n    #     currently_drilling_segments_3d = self.currently_drilling_segments_3d\r\n    #\r\n    #     drilled_df = self.drilled_df\r\n    #     planned_df = self.planned_df\r\n    #     currently_drilling_df = self.currently_drilling_df\r\n    #\r\n    #     # Process each well category data\r\n    #     drilled_df, drilled_segments, drilled_segments_3d, data_drilled, df_drilled_parameters = setupData(\r\n    #         drilled_df, drilled_segments, drilled_segments_3d)\r\n    #     planned_df, planned_segments, planned_segments_3d, data_planned, df_planned_parameters = setupData(\r\n    #         planned_df, planned_segments, planned_segments_3d)\r\n    #     currently_drilling_df, currently_drilling_segments, currently_drilling_segments_3d, data_drilling, df_drilling_parameters = setupData(\r\n    #         currently_drilling_df, currently_drilling_segments, currently_drilling_segments_3d)\r\n    #\r\n    #     # Update well type/status filters\r\n    #     statusAndTypesEnabler()\r\n    #     # Handle field name visibility\r\n    #     if self.ui.field_names_checkbox.isChecked():\r\n    #         self.field_sections.set_visible(True)\r\n    #         paths = [PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\")\r\n    #                  for coord, text in zip(self.field_centroids_lst, self.field_labels)]\r\n    #         self.labels_field.set_paths(paths)\r\n    #         self.labels_field.set_visible(True)\r\n    #     else:\r\n    #         self.field_sections.set_visible(False)\r\n    #         self.labels_field.set_visible(False)\r\n    #\r\n    #     # Extract visualization parameters\r\n    #     drilled_colors_init, drilled_line_width = df_drilled_parameters['color'].tolist(), df_drilled_parameters[\r\n    #         'width'].tolist()\r\n    #     planned_colors_init, planned_line_width = df_planned_parameters['color'].tolist(), df_planned_parameters[\r\n    #         'width'].tolist()\r\n    #     currently_drilling_colors_init, currently_drilling_width = df_drilling_parameters['color'].tolist(), \\\r\n    #         df_drilling_parameters['width'].tolist()\r\n    #\r\n    #     # Toggle visibility for each well category\r\n    #     toggleWellDisplay(\r\n    #         self.ui.asdrilled_check.isChecked(), drilled_df,\r\n    #         drilled_segments, drilled_colors_init, drilled_line_width,\r\n    #         self.all_wells_2d_asdrilled, self.all_wells_3d_asdrilled,\r\n    #         self.all_wells_2d_vertical_asdrilled, drilled_segments_3d)\r\n    #\r\n    #     toggleWellDisplay(\r\n    #         self.ui.planned_check.isChecked(), planned_df,\r\n    #         planned_segments, planned_colors_init, planned_line_width,\r\n    #         self.all_wells_2d_planned, self.all_wells_3d_planned,\r\n    #         self.all_wells_2d_vertical_planned, planned_segments_3d)\r\n    #\r\n    #     toggleWellDisplay(\r\n    #         self.ui.currently_drilling_check.isChecked(), currently_drilling_df,\r\n    #         currently_drilling_segments, currently_drilling_colors_init, currently_drilling_width,\r\n    #         self.all_wells_2d_current, self.all_wells_3d_current,\r\n    #         self.all_wells_2d_vertical_current, currently_drilling_segments_3d)\r\n    #\r\n    #     # Update 3D plot boundaries if drilled segments exist\r\n    #     if drilled_segments_3d:\r\n    #         self.centroid, std_vals = self.calculateCentroidNP(drilled_segments_3d)\r\n    #         new_xlim = [self.centroid[0] - 10000, self.centroid[0] + 10000]\r\n    #         new_ylim = [self.centroid[1] - 10000, self.centroid[1] + 10000]\r\n    #         new_zlim = [self.centroid[2] - 10000, self.centroid[2] + 10000]\r\n    #         self.ax3d.set_xlim3d(new_xlim)\r\n    #         self.ax3d.set_ylim3d(new_ylim)\r\n    #         self.ax3d.set_zlim3d(new_zlim)\r\n    #\r\n    #     # Refresh all canvases\r\n    #     self.canvas2d.blit(self.ax2d.bbox)\r\n    #     self.canvas2d.draw()\r\n    #     self.canvas3d.blit(self.ax3d.bbox)\r\n    #     self.canvas3d.draw()\r\n\r\n    def init_plot(self):\r\n        for drilling_status, style in self.drilling_styles.items():\r\n            lc = LineCollection([], linestyles=style['linestyle'], linewidths=1.5, zorder=2)\r\n            self.drilling_collections[drilling_status] = lc\r\n            self.ax2d.add_collection(lc)\r\n\r\n            # Prepare segments and their properties\r\n        self.prepare_segments()\r\n\r\n        # Create Legend\r\n        # self.create_legend()\r\n\r\n        # Adjust plot limits\r\n        self.ax2d.autoscale()\r\n        self.ax2d.set_aspect('equal', 'datalim')\r\n\r\n        # Draw the initial canvas\r\n        self.canvas2d.draw()\r\n\r\n    def prepare_segments(self, used_df_dx, well_info_df):\r\n        # Group data by api, citing_type, measured_depth, and drilling_status to form LineStrings\r\n        grouped = used_df_dx.sort_values('measured_depth').groupby(\r\n            ['apinumber', 'citing_type'])\r\n\r\n        # Initialize a dictionary to hold segments and their properties per drilling status\r\n        self.segments_per_drilling_status = {status: [] for status in self.drilling_styles.keys()}\r\n        self.segment_properties = {status: [] for status in self.drilling_styles.keys()}\r\n\r\n        for (api, citing_type), group in grouped:\r\n            used_info = well_info_df[well_info_df['well_id']==api]\r\n            used_group = group.sort_values('measured_depth')\r\n            coords = list(zip(used_group['x'], used_group['y']))\r\n            if len(coords) < 2:\r\n                continue  # Need at least two points to form a line\r\n            line = LineString(coords)\r\n            segment = list(line.coords)\r\n            print(segment)\r\n            self.segments_per_drilling_status[citing_type].append(segment)\r\n            #\r\n            # # Assuming all points in a group have the same type and status\r\n            well_type = used_info['current_well_type'].iloc[0]\r\n            well_status = used_info['current_well_status'].iloc[0]\r\n            self.segment_properties[citing_type].append({\r\n                'api': api,\r\n                'citing_type': citing_type,\r\n                'type': well_type,\r\n                'status': well_status\r\n            })\r\n\r\n        # Assign segments and default colors to each LineCollection\r\n        # for drilling_status, lc in self.drilling_collections.items():\r\n        #     lc.set_segments(self.segments_per_drilling_status[drilling_status])\r\n        #     # Default color: based on well type or well status\r\n        #     # Initially, color by well type\r\n        #     colors = [\r\n        #         self.type_color_map.get(prop['type'], 'black')\r\n        #         for prop in self.segment_properties[drilling_status]\r\n        #     ]\r\n        #     lc.set_color(colors)\r\n        #     # Store all properties for later filtering\r\n        #     lc.segment_props = self.segment_properties[drilling_status]\r\n\r\n\r\n\r\n\r\n\r\n\r\n    def draw_2d_data_all(self, well_info_df, used_df_dx):\r\n            # Create a default LineCollection for all wells\r\n        main_statuses = ['Plugged & Abandoned',\r\n                                    'Producing',\r\n                                    'Shut-in',\r\n                                    'Drilling']\r\n        main_types = ['Unknown',\r\n                                 'Oil Well',\r\n                                 'Dry Hole',\r\n                                 'Gas Well',\r\n                                 'Test Well',\r\n                                 'Water Source Well']\r\n        other_statuses= ['Location Abandoned - APD rescinded',\r\n                                     'Returned APD (Unapproved)',\r\n                                     'Approved Permit',\r\n                                     'Active',\r\n                                     'Drilling Operations Suspended',\r\n                                     'New Permit',\r\n                                     'Inactive',\r\n                                     'Temporarily-abandoned',\r\n                                     'Test Well or Monitor Well']\r\n\r\n\r\n        self.drilling_collections = {}\r\n        for drilling_status, style in self.drilling_styles.items():\r\n            lc = LineCollection([], linestyles=style['linestyle'], linewidths=1.5, zorder=2)\r\n            self.drilling_collections[drilling_status] = lc\r\n            self.ax2d.add_collection(lc)\r\n\r\n        # Prepare segments and their properties\r\n        self.prepare_segments(used_df_dx, well_info_df)\r\n\r\n        # Adjust plot limits\r\n        self.ax2d.autoscale()\r\n        self.ax2d.set_aspect('equal', 'datalim')\r\n\r\n        # Create Legend\r\n        # self.create_legend()\r\n\r\n        self.canvas2d.draw()\r\n\r\n        # # Define color mapping based on well type and well status\r\n        # self.type_color_map = {\r\n        #     'oil': 'red',\r\n        #     'gas': 'green',\r\n        #     'water': 'blue',\r\n        #     'injection': 'purple'\r\n        #     # Add more types and colors as needed\r\n        # }\r\n\r\n        # self.status_color_map = {\r\n        #     'producing': 'cyan',\r\n        #     'shut in': 'magenta',\r\n        #     'injecting': 'orange'\r\n        #     # Add more statuses and colors as needed\r\n        # }\r\n\r\n        # self.status_collections = {}\r\n        # for status, style in status_styles.items():\r\n        #     lc = LineCollection([], linestyles=style['linestyle'], linewidths=1.0, zorder=2)\r\n        #     self.status_collections[status] = lc\r\n        #     self.ax2d.add_collection(lc)\r\n        # grouped = self.df_wells.sort_values('sequence').groupby(['well_id', 'status'])\r\n        #\r\n        #     # Dictionaries to hold LineCollections per type\r\n        # self.type_collections = {}\r\n        # # types = self.df_wells['type'].unique()\r\n        # for well_type in main_statuses:\r\n        #     # Initialize with empty LineCollections\r\n        #     lc = LineCollection([], linewidths=1.0, zorder=2)\r\n        #     self.type_collections[well_type] = lc\r\n        #     self.ax2d.add_collection(lc)\r\n        # all_wells = self.surveys.groupby('apinumber')\r\n        # # Populate the LineCollections\r\n        # for i, group in enumerate(all_wells):\r\n        #     citing_group = self.surveys.groupby('citing_type')\r\n        #     for j in group2 in\r\n        #     print(group)\r\n        # for idx, row in self.surveys.iterrows():\r\n        #     line = row['geometry']\r\n        #     coords = list(line.coords)\r\n        #     if row['type'] in self.type_collections:\r\n        #         self.type_collections[row['type']].get_segments = getattr(self.type_collections[row['type']],\r\n        #                                                                   'get_segments', [])\r\n        #         self.type_collections[row['type']].get_segments.append(coords)\r\n        #\r\n        # # After collecting all segments, set them\r\n        # for well_type, lc in self.type_collections.items():\r\n        #     segments = [list(line.coords) for line in self.df_wells[self.df_wells['type'] == well_type]['geometry']]\r\n        #     lc.set_segments(segments)\r\n        #     # Set default color (same as all_wells)\r\n        #     lc.set_color('black')\r\n        #     lc.set_linewidth(0.5)\r\n        #\r\n        # # Adjust plot limits\r\n        # self.ax.autoscale()\r\n        # self.canvas.draw()\r\n    def manipulateTheDfDocketDataDependingOnCheckboxes(self):\r\n        \"\"\"\r\n           Main function for managing well visualization based on UI checkbox states.\r\n\r\n           Controls the display of different well types (drilled, planned, currently drilling)\r\n           and their properties in both 2D and 3D views. Handles well filtering, visibility,\r\n           styling, and related UI elements like field names.\r\n\r\n           Attributes Modified:\r\n               currently_used_lines (DataFrame): Tracks which well lines are currently displayed\r\n               field_sections (Artist): Visual elements for field sections\r\n               labels_field (Artist): Text labels for fields\r\n               Various matplotlib artists for well visualization\r\n\r\n           Side Effects:\r\n               - Updates 2D and 3D matplotlib canvases\r\n               - Modifies well line visibility and styling\r\n               - Updates field name labels\r\n               - Adjusts 3D view limits based on well positions\r\n               - Triggers well type/status filtering\r\n\r\n           Processing Steps:\r\n               1. Initializes local data references\r\n               2. Sets up data parameters for each well category\r\n               3. Applies type/status filtering\r\n               4. Handles field name visibility\r\n               5. Processes well display parameters\r\n               6. Toggles visibility for different well categories\r\n               7. Adjusts 3D view boundaries\r\n               8. Updates visualization canvases\r\n\r\n           Notes:\r\n               - Central function for well visualization control\r\n               - Connected to multiple UI checkbox events\r\n               - Manages both 2D and 3D visualizations\r\n               - Handles three main well categories:\r\n                   * As-drilled wells\r\n                   * Planned wells\r\n                   * Currently drilling wells\r\n               - Maintains visualization consistency across views\r\n               - Uses helper functions for data setup and display\r\n\r\n           Dependencies:\r\n               - setupData(): Prepares well data parameters\r\n               - statusAndTypesEnabler(): Manages well filtering\r\n               - toggleWellDisplay(): Controls well visibility\r\n               - calculateCentroidNP(): Computes 3D view center\r\n           \"\"\"\r\n\r\n        def platBounded(\r\n                df: pd.DataFrame,\r\n                segments: List[List[List[float]]],\r\n                segments_3d: List[List[List[float]]]\r\n        ) -> Tuple[pd.DataFrame, List[List[List[float]]], List[List[List[float]]]]:\r\n            \"\"\"\r\n            Filters and reorders well data and segments based on API numbers and measured depth.\r\n\r\n            Sorts well data by API number and measured depth, then filters the 2D and 3D\r\n            segment data to match only the wells present in the DataFrame. Maintains data\r\n            consistency across different representations of the same wells.\r\n\r\n            Args:\r\n                df (pd.DataFrame): Well data containing:\r\n                    Required columns:\r\n                    - apinumber: Unique well identifier\r\n                    - measured_depth: Depth measurement along wellbore\r\n                segments (List[List[List[float]]]): 2D coordinate segments for visualization\r\n                    Format: [well][segment][x,y coordinates]\r\n                segments_3d (List[List[List[float]]]): 3D coordinate segments for visualization\r\n                    Format: [well][segment][z coordinates]\r\n\r\n            Returns:\r\n                Tuple containing:\r\n                - pd.DataFrame: Sorted and filtered well data\r\n                - List[List[List[float]]]: Filtered 2D segments matching DataFrame wells\r\n                - List[List[List[float]]]: Filtered 3D segments matching DataFrame wells\r\n\r\n            Notes:\r\n                - Maintains data consistency by filtering segments to match DataFrame wells\r\n                - Preserves original data structure and relationships\r\n                - Handles potential mismatches between DataFrame and segment data\r\n                - Returns empty lists for segments if no matches found\r\n\r\n            Example:\r\n                >>> df_filtered, seg_2d, seg_3d = platBounded(well_df, segments_2d, segments_3d)\r\n                >>> print(f\"Filtered to {len(seg_2d)} wells\")\r\n            \"\"\"\r\n            # Sort DataFrame by API number and measured depth\r\n            df = df.sort_values(by=['apinumber', 'measured_depth'])\r\n\r\n            # Create index mapping for API numbers\r\n            api = df[['apinumber']].drop_duplicates().reset_index(drop=True)\r\n            api['index'] = api.index\r\n\r\n            # Merge to maintain relationships\r\n            merged = pd.merge(api, df, left_on='apinumber', right_on='apinumber')\r\n\r\n            # Filter segments to match DataFrame wells\r\n            segments = [segments[i] for i in range(len(segments)) if i in merged['index'].unique()]\r\n            segments_3d = [segments_3d[i] for i in range(len(segments_3d)) if i in merged['index'].unique()]\r\n\r\n            return df, segments, segments_3d\r\n\r\n        def setupData(\r\n                df: pd.DataFrame,\r\n                segments: List[List[List[float]]],\r\n                segments_3d: List[List[List[float]]]\r\n        ) -> Tuple[pd.DataFrame, List[List[List[float]]], List[List[List[float]]], Dict, pd.DataFrame]:\r\n            \"\"\"\r\n            Prepares well data and visualization parameters by filtering data and setting up default styling.\r\n\r\n            Processes well data through platBounded filter and creates default visualization\r\n            parameters for well segments including color and width attributes.\r\n\r\n            Args:\r\n                df (pd.DataFrame): Well data containing:\r\n                    Required columns:\r\n                    - apinumber: Unique well identifier\r\n                    - measured_depth: Depth measurement along wellbore\r\n                segments (List[List[List[float]]]): 2D coordinate segments for visualization\r\n                    Format: [well][segment][x,y coordinates]\r\n                segments_3d (List[List[List[float]]]): 3D coordinate segments for visualization\r\n                    Format: [well][segment][z coordinates]\r\n\r\n            Returns:\r\n                Tuple containing:\r\n                - pd.DataFrame: Filtered and sorted well data\r\n                - List[List[List[float]]]: Filtered 2D segments\r\n                - List[List[List[float]]]: Filtered 3D segments\r\n                - Dict: Default styling parameters dictionary with:\r\n                    - color: List of colors (default 'black')\r\n                    - width: List of line widths (default 0.5)\r\n                - pd.DataFrame: Styling parameters as DataFrame\r\n\r\n            Notes:\r\n                - Uses platBounded to filter and align data\r\n                - Creates consistent default styling for all well segments\r\n                - Styling can be modified later by other functions\r\n                - Returns both dict and DataFrame versions of styling parameters\r\n                - All segments receive identical initial styling\r\n\r\n            Example:\r\n                >>> df, segs_2d, segs_3d, style_dict, style_df = setupData(wells_df, segments_2d, segments_3d)\r\n                >>> print(f\"Styled {len(style_df)} well segments\")\r\n            \"\"\"\r\n            # Filter and align data using platBounded\r\n            df, segments, segments_3d = platBounded(df, segments, segments_3d)\r\n\r\n            # Create default styling parameters\r\n            data = {'color': ['black'] * len(segments), 'width': [0.5] * len(segments)}\r\n\r\n            # Convert styling parameters to DataFrame\r\n            df_parameters = pd.DataFrame(data)\r\n\r\n            return df, segments, segments_3d, data, df_parameters\r\n\r\n        def wellChecked(\r\n                type: str,\r\n                column: Literal['CurrentWellType', 'current_well_status']\r\n        ) -> None:\r\n            \"\"\"\r\n            Updates well visualization parameters based on specified well type or status filter.\r\n\r\n            Modifies the styling (color and line width) of well segments in the visualization\r\n            based on either well type (e.g., Oil, Gas) or well status (e.g., Producing,\r\n            Shut-in). Wells matching the filter criteria are highlighted with specific colors\r\n            and increased line width.\r\n\r\n            Args:\r\n                type (str): Well type or status to filter by. Valid values depend on column:\r\n                    For CurrentWellType:\r\n                        - 'Oil Well'\r\n                        - 'Gas Well'\r\n                        - 'Water Disposal Well'\r\n                        - 'Water Injection Well'\r\n                        - 'Gas Injection Well'\r\n                        - 'Dry Hole'\r\n                        - 'Test Well'\r\n                        - 'Water Source Well'\r\n                        - 'Unknown'\r\n                    For current_well_status:\r\n                        - Status values from well database\r\n                column (Literal['CurrentWellType', 'current_well_status']):\r\n                    Column to filter on, determines color mapping used\r\n\r\n            Side Effects:\r\n                Updates these visualization parameter DataFrames:\r\n                - df_drilled_parameters\r\n                - df_planned_parameters\r\n                - df_drilling_parameters\r\n\r\n                Modifies:\r\n                - 'color': Changed from default black to type-specific color\r\n                - 'width': Increased from 0.5 to 1.5 for matching wells\r\n\r\n            Notes:\r\n                - Only processes first row per API number since color/type is constant per well\r\n                - Handles three well categories: drilled, planned, and currently drilling\r\n                - Uses predefined color mappings stored in WellTypeColor or WellStatusColor\r\n                - Non-matching wells retain default black color and 0.5 width\r\n                - Changes are reflected immediately in visualization\r\n\r\n            Example:\r\n                >>> wellChecked('Oil Well', 'CurrentWellType')\r\n                # Updates visualization to highlight all oil wells in red\r\n            \"\"\"\r\n            # Determine color mapping column based on filter type\r\n            colors_lst = 'WellTypeColor' if column == 'CurrentWellType' else 'WellStatusColor'\r\n\r\n            # Get first row for each API number to determine well properties\r\n            drilled_df_restricted = drilled_df.groupby('apinumber').first().reset_index()\r\n            planned_df_restricted = planned_df.groupby('apinumber').first().reset_index()\r\n            currently_drilling_df_restricted = currently_drilling_df.groupby('apinumber').first().reset_index()\r\n\r\n            # Create masks for wells matching specified type/status\r\n            drilled_well_mask = drilled_df_restricted[column] == type\r\n            planned_well_mask = planned_df_restricted[column] == type\r\n            currently_drilling_well_mask = currently_drilling_df_restricted[column] == type\r\n\r\n            # Update styling for drilled wells\r\n            df_drilled_parameters.loc[drilled_well_mask, 'color'] = drilled_df_restricted.loc[\r\n                drilled_well_mask, colors_lst]\r\n            df_drilled_parameters.loc[drilled_well_mask, 'width'] = 1.5\r\n\r\n            # Update styling for planned wells\r\n            df_planned_parameters.loc[planned_well_mask, 'color'] = planned_df_restricted.loc[\r\n                planned_well_mask, colors_lst]\r\n            df_planned_parameters.loc[planned_well_mask, 'width'] = 1.5\r\n\r\n            # Update styling for currently drilling wells\r\n            df_drilling_parameters.loc[currently_drilling_well_mask, 'color'] = currently_drilling_df_restricted.loc[\r\n                currently_drilling_well_mask, colors_lst]\r\n            df_drilling_parameters.loc[currently_drilling_well_mask, 'width'] = 1.5\r\n\r\n        def wellCheckedMultiple(\r\n                types: List[str],\r\n                column: Literal['CurrentWellType', 'current_well_status']\r\n        ) -> None:\r\n            \"\"\"\r\n            Updates well visualization parameters for multiple well types or statuses simultaneously.\r\n\r\n            Similar to wellChecked() but handles multiple types/statuses at once. Modifies the styling\r\n            (color and line width) of well segments in the visualization based on a list of well\r\n            types or statuses. Wells matching any of the filter criteria are highlighted.\r\n\r\n            Args:\r\n                types (List[str]): List of well types or statuses to filter by. Valid values depend on column:\r\n                    For CurrentWellType:\r\n                        - 'Oil Well'\r\n                        - 'Gas Well'\r\n                        - 'Water Disposal Well'\r\n                        - 'Oil Well/Water Disposal Well'\r\n                        - 'Water Injection Well'\r\n                        - 'Gas Injection Well'\r\n                        - 'Dry Hole'\r\n                        - etc.\r\n                    For current_well_status:\r\n                        - 'Location Abandoned - APD rescinded'\r\n                        - 'Returned APD (Unapproved)'\r\n                        - 'Approved Permit'\r\n                        - 'Active'\r\n                        - 'Drilling Operations Suspended'\r\n                        - 'New Permit'\r\n                        - 'Inactive'\r\n                        - 'Temporarily-abandoned'\r\n                        - 'Test Well or Monitor Well'\r\n                        - etc.\r\n                column (Literal['CurrentWellType', 'current_well_status']):\r\n                    Column to filter on, determines color mapping used\r\n\r\n            Side Effects:\r\n                Updates these visualization parameter DataFrames:\r\n                - df_drilled_parameters\r\n                - df_planned_parameters\r\n                - df_drilling_parameters\r\n\r\n                Modifies:\r\n                - 'color': Changed from default black to type-specific color\r\n                - 'width': Increased from 0.5 to 1.5 for matching wells\r\n\r\n            Notes:\r\n                - Only processes first row per API number since color/type is constant per well\r\n                - Handles three well categories: drilled, planned, and currently drilling\r\n                - Uses predefined color mappings stored in WellTypeColor or WellStatusColor\r\n                - Non-matching wells retain default black color and 0.5 width\r\n                - Changes are reflected immediately in visualization\r\n                - Commonly used for grouping related well types (e.g., all injection wells)\r\n                - Used by the GUI checkbox handlers to update multiple well types at once\r\n\r\n            Example:\r\n                >>> wellCheckedMultiple(['Water Injection Well', 'Gas Injection Well'], 'CurrentWellType')\r\n                # Updates visualization to highlight all injection wells\r\n            \"\"\"\r\n            # Determine color mapping column based on filter type\r\n            colors_lst = 'WellTypeColor' if column == 'CurrentWellType' else 'WellStatusColor'\r\n\r\n            # Get first row for each API number to determine well properties\r\n            drilled_df_restricted = drilled_df.groupby('apinumber').first().reset_index()\r\n            planned_df_restricted = planned_df.groupby('apinumber').first().reset_index()\r\n            currently_drilling_df_restricted = currently_drilling_df.groupby('apinumber').first().reset_index()\r\n\r\n            # Create masks for wells matching any specified type/status\r\n            drilled_well_mask = drilled_df_restricted[column].isin(types)\r\n            planned_well_mask = planned_df_restricted[column].isin(types)\r\n            currently_drilling_well_mask = currently_drilling_df_restricted[column].isin(types)\r\n\r\n            # Update styling for drilled wells\r\n            df_drilled_parameters.loc[drilled_well_mask, 'color'] = drilled_df_restricted.loc[\r\n                drilled_well_mask, colors_lst]\r\n            df_drilled_parameters.loc[drilled_well_mask, 'width'] = 1.5\r\n\r\n            # Update styling for planned wells\r\n            df_planned_parameters.loc[planned_well_mask, 'color'] = planned_df_restricted.loc[\r\n                planned_well_mask, colors_lst]\r\n            df_planned_parameters.loc[planned_well_mask, 'width'] = 1.5\r\n\r\n            # Update styling for currently drilling wells\r\n            df_drilling_parameters.loc[currently_drilling_well_mask, 'color'] = currently_drilling_df_restricted.loc[\r\n                currently_drilling_well_mask, colors_lst]\r\n            df_drilling_parameters.loc[currently_drilling_well_mask, 'width'] = 1.5\r\n\r\n        def toggleWellDisplay(\r\n                condition: bool,\r\n                data_frame: pd.DataFrame,\r\n                segments_2d: List[List[float]],\r\n                colors_init: Union[str, List[str]],\r\n                line_width: Union[float, List[float]],\r\n                well_2d: Line2D,\r\n                well_3d: Line2D,\r\n                vertical_well: Line2D,\r\n                segments_3d: List[List[float]]\r\n        ) -> None:\r\n            \"\"\"\r\n            Toggles the visibility and updates data for well visualization elements based on a boolean condition.\r\n\r\n            Controls the display state and data updates for 2D, 3D and vertical well representations in the\r\n            visualization. When enabled, updates the data and makes wells visible. When disabled, hides the wells\r\n            without removing the underlying data.\r\n\r\n            Args:\r\n                condition (bool): Toggle state - True to show and update wells, False to hide them\r\n                data_frame (pd.DataFrame): Well data to incorporate into currently displayed wells\r\n                    Required columns:\r\n                    - Well identifiers\r\n                    - Coordinate data\r\n                    - Well properties\r\n                segments_2d (List[List[float]]): 2D coordinate segments for well paths\r\n                    Format: [[x1,y1], [x2,y2], ...]\r\n                colors_init (Union[str, List[str]]): Color specification for well lines\r\n                    Either single color string or list of colors per segment\r\n                line_width (Union[float, List[float]]): Width specification for well lines\r\n                    Either single width value or list of widths per segment\r\n                well_2d (Line2D): Matplotlib line object for 2D well representation\r\n                well_3d (Line2D): Matplotlib line object for 3D well representation\r\n                vertical_well (Line2D): Matplotlib line object for vertical well projection\r\n                segments_3d (List[List[float]]): 3D coordinate segments for well paths\r\n                    Format: [[x1,y1,z1], [x2,y2,z2], ...]\r\n\r\n            Side Effects:\r\n                - Updates self.currently_used_lines with new well data when enabled\r\n                - Modifies visibility of well_2d, well_3d and vertical_well line objects\r\n                - Triggers redraw of well visualizations when enabled\r\n                - Changes persist until next toggle operation\r\n\r\n            Notes:\r\n                - Uses drawModelBasedOnParameters2d() for 2D visualization updates\r\n                - Uses drawModelBasedOnParameters() for 3D visualization updates\r\n                - Maintains data state even when wells are hidden\r\n                - Deduplicates data when adding new wells\r\n                - Preserves existing well properties when toggling visibility\r\n\r\n            Example:\r\n                >>> toggleWellDisplay(True, new_wells_df, segs_2d, 'blue', 1.0,\r\n                                      well2d, well3d, vert_well, segs_3d)\r\n                # Shows wells and updates with new data\r\n                >>> toggleWellDisplay(False, new_wells_df, segs_2d, 'blue', 1.0,\r\n                                      well2d, well3d, vert_well, segs_3d)\r\n                # Hides wells without removing data\r\n            \"\"\"\r\n            if condition:\r\n                # Update data and show wells\r\n                self.currently_used_lines = concat([self.currently_used_lines, data_frame]).drop_duplicates(\r\n                    keep='first').reset_index(drop=True)\r\n\r\n                # Redraw 2D and 3D visualizations with updated parameters\r\n                self.drawModelBasedOnParameters2d(well_2d, segments_2d, colors_init, line_width, self.ax2d,\r\n                                                  vertical_well)\r\n                self.drawModelBasedOnParameters(well_3d, segments_3d, colors_init, line_width, self.ax3d)\r\n\r\n                # Make all well representations visible\r\n                well_2d.set_visible(True)\r\n                well_3d.set_visible(True)\r\n                vertical_well.set_visible(True)\r\n            else:\r\n                # Hide all well representations\r\n                well_2d.set_visible(False)\r\n                well_3d.set_visible(False)\r\n                vertical_well.set_visible(False)\r\n\r\n        def statusAndTypesEnabler() -> NoReturn:\r\n            \"\"\"\r\n            Manages well visualization filters and field label visibility based on UI state.\r\n\r\n            Coordinates the mutual exclusivity between well type and status filters while\r\n            maintaining independent control of field label visibility. Handles three main\r\n            aspects of visualization:\r\n            1. Well type filtering (for Oil, Gas, Injection, Disposal wells etc.)\r\n            2. Well status filtering (Producing, Shut-in, P&A, Drilling etc.)\r\n            3. Field name label visibility\r\n\r\n            Radio Button IDs:\r\n                -2: Well Type filtering mode (Oil, Gas, Injection, etc.)\r\n                -3: Well Status filtering mode (Producing, Shut-in, etc.)\r\n\r\n            Field Labels:\r\n                - Displayed as red text at field centroids when enabled\r\n                - Size: 75 units\r\n                - Visibility tied to field_names_checkbox state\r\n\r\n            Side Effects:\r\n                - Updates well visibility based on selected filter mode\r\n                - Modifies field label and section visibility\r\n                - Changes currently_used_lines DataFrame content\r\n                - Triggers field label rendering when enabled\r\n                - Maintains field visibility state independent of filter changes\r\n\r\n            Notes:\r\n                - Part of the well visualization control system\r\n                - Connected to radio button and checkbox state changes\r\n                - Preserves field label state across filter changes\r\n                - Ensures proper layering of visual elements\r\n                - Manages memory by creating field labels only when visible\r\n                - Coordinates with wellTypesEnable() and wellStatusEnable()\r\n\r\n            Example:\r\n                Called when switching between well type/status or toggling field names:\r\n                >>> self.ui.well_type_or_status_button_group.buttonClicked.connect(\r\n                        self.statusAndTypesEnabler)\r\n                >>> self.ui.field_names_checkbox.stateChanged.connect(\r\n                        self.statusAndTypesEnabler)\r\n            \"\"\"\r\n            # Store field checkbox state to preserve across filter changes\r\n            field_checkbox_state = self.ui.field_names_checkbox.isChecked()\r\n\r\n            # Get the ID of currently selected radio button\r\n            active_button_id_type_status = self.ui.well_type_or_status_button_group.checkedId()\r\n\r\n            # Enable well type filtering mode\r\n            if active_button_id_type_status == -2:\r\n                wellTypesEnable()\r\n            # Enable well status filtering mode\r\n            elif active_button_id_type_status == -3:\r\n                wellStatusEnable()\r\n\r\n            # Handle field label visibility independent of filter state\r\n            if field_checkbox_state:\r\n                self.field_sections.set_visible(True)\r\n                # Create field label paths with consistent styling\r\n                paths = [\r\n                    PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\")\r\n                    for coord, text in zip(self.field_centroids_lst, self.field_labels)\r\n                ]\r\n                self.labels_field.set_paths(paths)\r\n                self.labels_field.set_visible(True)\r\n            else:\r\n                self.field_sections.set_visible(False)\r\n                self.labels_field.set_visible(False)\r\n\r\n        def wellTypesEnable() -> NoReturn:\r\n            \"\"\"\r\n            Enables well type filtering while temporarily disabling well status filters.\r\n\r\n            Updates the visualization based on selected well type checkboxes in the UI.\r\n            Temporarily blocks signals from status checkboxes to prevent interference\r\n            between type and status filters.\r\n\r\n            Well Types Handled:\r\n                - Oil Wells\r\n                - Gas Wells\r\n                - Water Disposal Wells (including dual-purpose Oil/Disposal wells)\r\n                - Dry Holes\r\n                - Injection Wells (Water and Gas)\r\n                - Other Wells (Unknown, Test Wells, Water Source Wells)\r\n\r\n            Side Effects:\r\n                # - Temporarily blocks signals from status checkboxes\r\n                - Unchecks all status checkboxes\r\n                - Updates well visualization based on checked type filters\r\n                # - Restores signal handling for status checkboxes\r\n                - Modifies well colors and visibility in the visualization\r\n                - Updates currently_used_lines DataFrame\r\n\r\n            Notes:\r\n                - Uses wellChecked() for single well types\r\n                - Uses wellCheckedMultiple() for grouped well types\r\n                - Ensures mutual exclusivity between type and status filters\r\n                - Part of the well visualization control system\r\n                - Connected to UI checkbox state changes\r\n                - Maintains separation between well type and status filtering\r\n\r\n            Example:\r\n                Called when user interacts with well type checkboxes:\r\n                >>> self.ui.oil_well_check.stateChanged.connect(self.wellTypesEnable)\r\n            \"\"\"\r\n            # Temporarily disable status checkbox signals\r\n            # for q in self.status_checks:\r\n            #     q.blockSignals(True)\r\n            #     q.setChecked(False)\r\n\r\n            # Handle Oil Well selection\r\n            if self.ui.oil_well_check.isChecked():\r\n                wellChecked('Oil Well', 'CurrentWellType')\r\n\r\n            # Handle Gas Well selection\r\n            if self.ui.gas_well_check.isChecked():\r\n                wellChecked('Gas Well', 'CurrentWellType')\r\n\r\n            # Handle Water Disposal Well selection (including combination wells)\r\n            if self.ui.water_disposal_check.isChecked():\r\n                wellCheckedMultiple(['Water Disposal Well', 'Oil Well/Water Disposal Well'], 'CurrentWellType')\r\n\r\n            # Handle Dry Hole selection\r\n            if self.ui.dry_hole_check.isChecked():\r\n                wellChecked('Dry Hole', 'CurrentWellType')\r\n\r\n            # Handle Injection Well selection (both water and gas)\r\n            if self.ui.injection_check.isChecked():\r\n                wellCheckedMultiple(['Water Injection Well', 'Gas Injection Well'], 'CurrentWellType')\r\n\r\n            # Handle Other Well Types selection\r\n            if self.ui.other_well_status_check.isChecked():\r\n                wellCheckedMultiple(['Unknown', 'Test Well', 'Water Source Well'], 'CurrentWellType')\r\n\r\n            # Re-enable status checkbox signals\r\n            # for q in self.status_checks:\r\n            # q.blockSignals(False)\r\n\r\n        def wellStatusEnable() -> NoReturn:\r\n            \"\"\"\r\n            Enables well status filtering while temporarily disabling well type filters.\r\n\r\n            Updates the visualization based on selected well status checkboxes in the UI.\r\n            Temporarily blocks signals from type checkboxes to prevent interference\r\n            between status and type filters.\r\n\r\n            Well Statuses Handled:\r\n                - Shut-in wells\r\n                - Plugged & Abandoned wells\r\n                - Producing wells\r\n                - Currently drilling wells\r\n                - Miscellaneous statuses:\r\n                    - Location Abandoned (APD rescinded)\r\n                    - Returned APD (Unapproved)\r\n                    - Approved Permit\r\n                    - Active\r\n                    - Drilling Operations Suspended\r\n                    - New Permit\r\n                    - Inactive\r\n                    - Temporarily-abandoned\r\n                    - Test/Monitor Wells\r\n\r\n            Side Effects:\r\n                - Temporarily blocks signals from type checkboxes\r\n                - Unchecks all type checkboxes\r\n                - Updates well visualization based on checked status filters\r\n                - Restores signal handling for type checkboxes\r\n                - Modifies well colors and visibility in visualization\r\n                - Updates currently_used_lines DataFrame\r\n\r\n            Notes:\r\n                - Uses wellChecked() for single well statuses\r\n                - Uses wellCheckedMultiple() for grouped miscellaneous statuses\r\n                - Ensures mutual exclusivity between status and type filters\r\n                - Part of the well visualization control system\r\n                - Connected to UI checkbox state changes\r\n                - Maintains separation between well status and type filtering\r\n\r\n            Example:\r\n                Called when user interacts with well status checkboxes:\r\n                >>> self.ui.shut_in_check.stateChanged.connect(self.wellStatusEnable)\r\n            \"\"\"\r\n            # Temporarily disable type checkbox signals\r\n            # for q in self.type_checks:\r\n            #     q.blockSignals(True)\r\n            #     q.setChecked(False)\r\n\r\n            # Handle Shut-in wells\r\n            if self.ui.shut_in_check.isChecked():\r\n                wellChecked('Shut-in', 'current_well_status')\r\n\r\n            # Handle Plugged & Abandoned wells\r\n            if self.ui.pa_check.isChecked():\r\n                wellChecked('Plugged & Abandoned', 'current_well_status')\r\n\r\n            # Handle Producing wells\r\n            if self.ui.producing_check.isChecked():\r\n                wellChecked('Producing', 'current_well_status')\r\n\r\n            # Handle Currently Drilling wells\r\n            if self.ui.drilling_status_check.isChecked():\r\n                wellChecked('Drilling', 'current_well_status')\r\n\r\n            # Handle Miscellaneous well statuses\r\n            if self.ui.misc_well_type_check.isChecked():\r\n                wellCheckedMultiple(['Location Abandoned - APD rescinded',\r\n                                     'Returned APD (Unapproved)', 'Approved Permit',\r\n                                     'Active', 'Drilling Operations Suspended', 'New Permit', 'Inactive',\r\n                                     'Temporarily-abandoned', 'Test Well or Monitor Well'], 'current_well_status')\r\n\r\n            # Re-enable type checkbox signals\r\n            # for q in self.type_checks:\r\n            #     q.blockSignals(False)\r\n\r\n        # Reset current line tracking\r\n        self.currently_used_lines = None\r\n\r\n        # Store segment and DataFrame references locally\r\n        drilled_segments = self.drilled_segments\r\n        planned_segments = self.planned_segments\r\n        currently_drilling_segments = self.currently_drilling_segments\r\n\r\n        drilled_segments_3d = self.drilled_segments_3d\r\n        planned_segments_3d = self.planned_segments_3d\r\n        currently_drilling_segments_3d = self.currently_drilling_segments_3d\r\n\r\n        drilled_df = self.drilled_df\r\n        planned_df = self.planned_df\r\n        currently_drilling_df = self.currently_drilling_df\r\n\r\n        # Process each well category data\r\n        drilled_df, drilled_segments, drilled_segments_3d, data_drilled, df_drilled_parameters = setupData(\r\n            drilled_df, drilled_segments, drilled_segments_3d)\r\n        planned_df, planned_segments, planned_segments_3d, data_planned, df_planned_parameters = setupData(\r\n            planned_df, planned_segments, planned_segments_3d)\r\n        currently_drilling_df, currently_drilling_segments, currently_drilling_segments_3d, data_drilling, df_drilling_parameters = setupData(\r\n            currently_drilling_df, currently_drilling_segments, currently_drilling_segments_3d)\r\n\r\n        # Update well type/status filters\r\n        statusAndTypesEnabler()\r\n        # Handle field name visibility\r\n        if self.ui.field_names_checkbox.isChecked():\r\n            self.field_sections.set_visible(True)\r\n            paths = [PathPatch(TextPath((coord.x, coord.y), text, size=75), color=\"red\")\r\n                     for coord, text in zip(self.field_centroids_lst, self.field_labels)]\r\n            self.labels_field.set_paths(paths)\r\n            self.labels_field.set_visible(True)\r\n        else:\r\n            self.field_sections.set_visible(False)\r\n            self.labels_field.set_visible(False)\r\n\r\n        # Extract visualization parameters\r\n        drilled_colors_init, drilled_line_width = df_drilled_parameters['color'].tolist(), df_drilled_parameters[\r\n            'width'].tolist()\r\n        planned_colors_init, planned_line_width = df_planned_parameters['color'].tolist(), df_planned_parameters[\r\n            'width'].tolist()\r\n        currently_drilling_colors_init, currently_drilling_width = df_drilling_parameters['color'].tolist(), \\\r\n            df_drilling_parameters['width'].tolist()\r\n\r\n        # Toggle visibility for each well category\r\n        toggleWellDisplay(\r\n            self.ui.asdrilled_check.isChecked(), drilled_df,\r\n            drilled_segments, drilled_colors_init, drilled_line_width,\r\n            self.all_wells_2d_asdrilled, self.all_wells_3d_asdrilled,\r\n            self.all_wells_2d_vertical_asdrilled, drilled_segments_3d)\r\n\r\n        toggleWellDisplay(\r\n            self.ui.planned_check.isChecked(), planned_df,\r\n            planned_segments, planned_colors_init, planned_line_width,\r\n            self.all_wells_2d_planned, self.all_wells_3d_planned,\r\n            self.all_wells_2d_vertical_planned, planned_segments_3d)\r\n\r\n        toggleWellDisplay(\r\n            self.ui.currently_drilling_check.isChecked(), currently_drilling_df,\r\n            currently_drilling_segments, currently_drilling_colors_init, currently_drilling_width,\r\n            self.all_wells_2d_current, self.all_wells_3d_current,\r\n            self.all_wells_2d_vertical_current, currently_drilling_segments_3d)\r\n\r\n        # Update 3D plot boundaries if drilled segments exist\r\n        if drilled_segments_3d:\r\n            self.centroid, std_vals = self.calculateCentroidNP(drilled_segments_3d)\r\n            new_xlim = [self.centroid[0] - 10000, self.centroid[0] + 10000]\r\n            new_ylim = [self.centroid[1] - 10000, self.centroid[1] + 10000]\r\n            new_zlim = [self.centroid[2] - 10000, self.centroid[2] + 10000]\r\n            self.ax3d.set_xlim3d(new_xlim)\r\n            self.ax3d.set_ylim3d(new_ylim)\r\n            self.ax3d.set_zlim3d(new_zlim)\r\n\r\n        # Refresh all canvases\r\n        self.canvas2d.blit(self.ax2d.bbox)\r\n        self.canvas2d.draw()\r\n        self.canvas3d.blit(self.ax3d.bbox)\r\n        self.canvas3d.draw()\r\n\r\n    # def draw_2d_data_all(self, well_info_df, dx_data):\r\n    #     def find_populated_dataframe():\r\n    #         if not drilled_df.empty:\r\n    #             return drilled_df\r\n    #         elif not planned_df.empty:\r\n    #             return planned_df\r\n    #         else:\r\n    #             return vert_df\r\n    #\r\n    #     Get well parameter data from current selection\r\n    #     # df_well_data: pd.DataFrame = well_info_df.loc[dx_data['DisplayName'] == self.ui.well_lst_combobox.currentText()]\r\n    #\r\n    #     # Filter directional survey data for selected well\r\n    #     df_well: pd.DataFrame = dx_data[dx_data['apinumber'] == df_well_data['WellID'].iloc[0]]\r\n    #\r\n    #     # Separate data by citing type\r\n    #     drilled_df: pd.DataFrame = df_well[df_well['citing_type'].isin(['asdrilled'])]\r\n    #     planned_df: pd.DataFrame = df_well[df_well['citing_type'].isin(['planned'])]\r\n    #     vert_df: pd.DataFrame = df_well[df_well['citing_type'].isin(['vertical'])]\r\n    #\r\n    #     # Get best available data based on priority\r\n    #     df_well = find_populated_dataframe()\r\n    #     df_well.drop_duplicates(keep='first', inplace=True)\r\n    #     df_well['X'] = df_well['X'].astype(float)\r\n    #     df_well['Y'] = df_well['Y'].astype(float)\r\n    #\r\n    #     # # Extract coordinate data\r\n    #     # xy_data = df_well[['X', 'Y']].values\r\n    #     #\r\n    #     # # Update appropriate plot based on well type\r\n    #     # if df_well['citing_type'].iloc[0] == 'vertical':\r\n    #     #     self.spec_vertical_wells_2d.set_offsets(xy_data)\r\n    #     #     self.spec_well_2d.set_data([], [])\r\n    #     # else:\r\n    #     #     self.spec_vertical_wells_2d.set_offsets([None, None])\r\n    #     #     self.spec_well_2d.set_data(xy_data[:, 0], xy_data[:, 1])\r\n    #     #\r\n    #     # # Process 3D coordinates\r\n    #     # x = to_numeric(df_well['SPX'], errors='coerce')\r\n    #     # y = to_numeric(df_well['SPY'], errors='coerce')\r\n    #     # z = to_numeric(df_well['Targeted Elevation'], errors='coerce')\r\n    #     # self.centroid = (x.mean(), y.mean(), z.mean())\r\n    #     #\r\n    #     # # Update 3D visualizations\r\n    #     # self.spec_well_3d.set_data(x, y)\r\n    #     # self.spec_well_3d.set_3d_properties(z)\r\n    #     # self.spec_well_3d_solo.set_data(x, y)\r\n    #     # self.spec_well_3d_solo.set_3d_properties(z)\r\n    #     #\r\n    #     # # Refresh canvases\r\n    #     # self.canvas2d.draw()\r\n    #     # self.canvas3d.draw()\r\n    #     #\r\n    #     # # Set new view limits centered on well\r\n    #     # new_xlim = [self.centroid[0] - 8000, self.centroid[0] + 8000]\r\n    #     # new_ylim = [self.centroid[1] - 8000, self.centroid[1] + 8000]\r\n    #     # new_zlim = [self.centroid[2] - 8000, self.centroid[2] + 8000]\r\n    #     #\r\n    #     # # Update 3D solo view limits\r\n    #     # self.ax3d_solo.set_xlim3d(new_xlim)\r\n    #     # self.ax3d_solo.set_ylim3d(new_ylim)\r\n    #     # self.ax3d_solo.set_zlim3d(new_zlim)\r\n    #     #\r\n    #     # # Refresh solo canvas and production graphic\r\n    #     # self.canvas3d_solo.draw()\r\n    #     # self.drawProductionGraphic()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../main_process_drawer.py b/../main_process_drawer.py
--- a/../main_process_drawer.py	(revision 11c8d433909f415072d1821b99a7cb0108153144)
+++ b/../main_process_drawer.py	(date 1743024924132)
@@ -22,7 +22,7 @@
 import os
 import sqlite3
 from datetime import datetime
-from typing import Callable, Dict, List, Literal, NoReturn, Optional, Set, Tuple, Union
+from typing import Callable, Dict, List, Literal, NoReturn, Optional, Set, Tuple, Union, Any, Hashable
 
 # Third-party imports - Core Data/Scientific
 import numpy as np
@@ -59,13 +59,19 @@
 from matplotlib.ticker import FuncFormatter, ScalarFormatter
 from mpl_toolkits.mplot3d.art3d import Line3DCollection
 from typing import *
+
+from PyQt5.QtWidgets import QApplication, QWidget, QCheckBox, QHBoxLayout, QVBoxLayout, QLabel, QGroupBox
+from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
+from matplotlib.figure import Figure
+from matplotlib.collections import LineCollection
+from mpl_toolkits.mplot3d import art3d  # for 3D line collections
+
+
 class Drawer:
     def __init__(self, ui, used_df_dx, well_info_df):
         self.ui = ui
         self.df_docket_data = well_info_df
         self.dx_df = used_df_dx
-        print(well_info_df.columns)
-        print(used_df_dx.columns)
 
         # self.df_docket_data = self.df_tsr.merge(
         #     self.df_BoardData,
@@ -161,16 +167,16 @@
             [1, 2, 3]
         """
         # Remove duplicates and sort
-        print(df)
         df = df.drop_duplicates(keep='first')
-        df = df.sort_values(by='well_id')
+        df = df.sort_values(by='api_number')
 
         # Reset index and handle missing ages
         df = df.reset_index(drop=True)
         df['well_age'] = df['well_age'].fillna(0)
 
         return df
-    def generateMasks(self) -> Tuple[pd.Series, pd.Series, pd.Series]:
+
+    def generateMasks(self, df) -> Tuple[pd.Series, pd.Series, pd.Series]:
         """
         Generates boolean masks for filtering well data based on drilling status and type.
 
@@ -205,16 +211,26 @@
             >>> drilling_wells = self.df_docket_data[drilling]
         """
         # Generate mask for drilled/completed wells
-        mask_drilled = self.dx_df['citing_type'].isin(['asdrilled', 'vertical'])
+        mask_drilled = df['citing_type'].isin(['asdrilled', 'vertical'])
 
         # Generate mask for planned/permitted wells
-        mask_planned = self.dx_df['citing_type'].isin(['planned', 'vertical'])
-
+        mask_planned = df['citing_type'].isin(['planned', 'vertical'])
         # Generate mask for currently drilling wells
-        mask_drilling = self.dx_df['current_well_status'].isin(['Drilling'])
+        mask_drilling = df['current_well_status'].isin(['Drilling'])
 
         return mask_drilled, mask_planned, mask_drilling
 
+    def create_age_masks_values(self, row):
+        row = float(row)
+        if row <= 12:
+            return 'one_year'
+        elif row <= 60:
+            return 'five_years'
+        elif row <= 120:
+            return 'ten_years'
+        elif row <= 9999:
+            return 'all_wells'
+
     def createAgeMasks(self) -> List[pd.Series]:
         """
         Creates boolean masks for filtering wells based on age thresholds.
@@ -294,7 +310,7 @@
             2
         """
         # Remove rows with missing targeted elevation values
-        return df.dropna(subset=['Targeted Elevation'])
+        return df.dropna(subset=['true_elevation'])
 
     def generateDataframes(
             self,
@@ -352,10 +368,11 @@
             # Filter data using combined masks and sort
             dataframes[key] = self.df_docket_data.loc[mask & age_masks[i]]
             dataframes[key] = dataframes[key].reset_index(drop=True).sort_values(
-                by=['apinumber', 'measured_depth']
+                by=['api_number', 'measured_depth']
             )
 
         return dataframes
+
     def returnWellsWithParameters(self, info_df, dx_df) -> DataFrame:
         """
         Processes and returns well data with color-coded parameters for visualization.
@@ -430,25 +447,24 @@
 
         # Define required columns for final dataset
         necessary_columns = [
-            'apinumber', 'x', 'y', 'targeted_elevation', 'citing_type',
+            'api_number', 'x', 'y', 'true_elevation', 'citing_type',
             'spx', 'spy', 'current_well_type', 'current_well_status',
             'well_age', 'measured_depth', 'conc_code_y'
         ]
 
         # Process and filter data
-        apis = info_df['well_id'].unique()
+        apis = info_df['api_number'].unique()
         # operators = self.df_docket['Operator'].unique()
-        dx_filtered = dx_df[dx_df['apinumber'].isin(apis)]
-        docket_filtered = info_df[info_df['well_id'].isin(apis)]
+        dx_filtered = dx_df[dx_df['api_number'].isin(apis)]
+        docket_filtered = info_df[info_df['api_number'].isin(apis)]
 
         # Merge and clean data
         merged_df = pd.merge(dx_filtered, docket_filtered,
-                             left_on='apinumber', right_on='well_id')
+                             left_on='api_number', right_on='api_number')
         merged_df = merged_df.drop_duplicates(keep='first')
-        merged_df = merged_df.sort_values(by=['apinumber', 'measured_depth'])
+        merged_df = merged_df.sort_values(by=['api_number', 'measured_depth'])
 
         # Create final dataset with necessary columns
-        print(merged_df)
         final_df = merged_df[necessary_columns]
         final_df.reset_index(drop=True, inplace=True)
 
@@ -458,28 +474,34 @@
             lambda x: colors_status.get(x, '#4a7583')
         )
 
-        return final_df.sort_values(by=['apinumber', 'measured_depth'])
-
+        return final_df.sort_values(by=['api_number', 'measured_depth'])
 
     def setupDataForBoardDrillingInformation(self):
+
         self.df_docket_data = self.returnWellsWithParameters(self.df_docket_data, self.dx_df)
-        print(self.df_docket_data)
         # Clear and prep the data
+
         self.df_docket_data = self.preprocessData(self.df_docket_data)
-        print(self.df_docket_data)
-        print(foo)
+
         # Initialize data containers
         self.planned_xy_2d, self.planned_xy_3d, self.drilled_xy_2d, self.drilled_xy_3d, self.currently_drilling_xy_2d, self.currently_drilling_xy_3d = [], [], [], [], [], []
 
         # Generate masks for data filtering
-        mask_drilled, mask_planned, mask_drilling = self.generateMasks()
+        mask_drilled, mask_planned, mask_drilling = self.generateMasks(self.df_docket_data)
 
         # Generate age-based masks
+
         age_masks = self.createAgeMasks()
+        # self.df_docket_data['age_label'] = self.df_docket_data[
+        #     'well_age'].apply(lambda row: self.create_age_masks_values(row), axis=1)
 
         # Clean data
         self.df_docket_data = self.cleanData(self.df_docket_data)
-
+        print(self.df_docket_data)
+        self.df_docket_data['age_label'] = self.df_docket_data['well_age'].apply(self.create_age_masks_values)
+        print(self.df_docket_data)
+        drilled_dataframes = self.df_docket_data.loc[mask_drilled].sort_values(by='well_age')
+        print(drilled_dataframes)
         # Generate dataframes based on conditions
 
         # For drilled
@@ -489,11 +511,14 @@
         # For currently drilling
         currently_drilling_dfs = self.generateDataframes('currently_drilling', mask_drilling, age_masks)
 
-
-        drilled_dataframes = [drilled_dfs['drilled_year'], drilled_dfs['drilled_5years'], drilled_dfs['drilled_10years'], drilled_dfs['drilled_all']]
-        planned_dataframes = [planned_dfs['planned_year'], planned_dfs['planned_5years'], planned_dfs['planned_10years'], planned_dfs['planned_all']]
-        currently_drilling_dataframes = [currently_drilling_dfs['currently_drilling_year'], currently_drilling_dfs['currently_drilling_5years'], currently_drilling_dfs['currently_drilling_10years'], currently_drilling_dfs['currently_drilling_all']]
-
+        drilled_dataframes = [drilled_dfs['drilled_year'], drilled_dfs['drilled_5years'],
+                              drilled_dfs['drilled_10years'], drilled_dfs['drilled_all']]
+        planned_dataframes = [planned_dfs['planned_year'], planned_dfs['planned_5years'],
+                              planned_dfs['planned_10years'], planned_dfs['planned_all']]
+        currently_drilling_dataframes = [currently_drilling_dfs['currently_drilling_year'],
+                                         currently_drilling_dfs['currently_drilling_5years'],
+                                         currently_drilling_dfs['currently_drilling_10years'],
+                                         currently_drilling_dfs['currently_drilling_all']]
         # Filter out planned data based on drilled data
         planned_dataframes = self.filterPlannedData(drilled_dataframes, planned_dataframes)
 
@@ -555,6 +580,7 @@
             drilled_dataframes[3], planned_dataframes[3])  # All time filter
 
         return planned_year, planned_5years, planned_10years, planned_all
+
     def filterPlannedDataForYear(
             self,
             drilled_df: pd.DataFrame,
@@ -599,7 +625,7 @@
         """
         # Filter out wells that are either drilled or currently drilling
         planned_year = planned_df[
-            ~planned_df['apinumber'].isin(drilled_df['apinumber']) &
+            ~planned_df['api_number'].isin(drilled_df['api_number']) &
             (planned_df['current_well_status'] != 'Drilling')
             ]
 
@@ -649,7 +675,8 @@
         self.processXYData(planned_dataframes, 'planned')  # Process planned wells XY data
         self.processXYData(currently_drilling_dataframes, 'currently_drilling')  # Process drilling wells XY data
 
-    def processXYData(self, dataframes: Dict[str, pd.DataFrame], data_type: Literal['drilled', 'planned', 'currently_drilling']) -> None:
+    def processXYData(self, dataframes: Dict[str, pd.DataFrame],
+                      data_type: Literal['drilled', 'planned', 'currently_drilling']) -> None:
         """
         Processes spatial (XY) coordinate data for each well dataframe in a category.
 
@@ -685,7 +712,7 @@
         """
         # Process each DataFrame in the dictionary
         for i, df in enumerate(dataframes):
-        # Call helper method to process individual DataFrame
+            # Call helper method to process individual DataFrame
             self.processSingleDataframe(df, data_type, i)
 
     # def processXYData(self, dataframes, data_type):
@@ -734,7 +761,7 @@
         xy_points_dict = self.createXYPointsDict(df)
 
         # Get unique API numbers from the DataFrame
-        apinums: Set[str] = set(df['apinumber'])
+        apinums: Set[str] = set(df['api_number'])
 
         # Create attribute keys for storing coordinates
         xy_2d_key = f"{data_type}_xy_2d"
@@ -755,7 +782,7 @@
     def createXYPointsDict(
             self,
             df: pd.DataFrame
-    ) -> Dict[str, List[List[float]]]:
+    ) -> dict[Hashable, list[list[Any]]]:
         """
         Creates a dictionary mapping API numbers to their coordinate points and elevation data.
 
@@ -796,14 +823,12 @@
             First well coordinates: [1234.5, 5678.9, 1000.0, 2000.0, 3500.0]
         """
         return {k: [[x, y, spx, spy, z] for x, y, spx, spy, z in
-                zip(g['X'].astype(float),
-                    g['Y'].astype(float),
-                    g['SPX'].astype(float),
-                    g['SPY'].astype(float),
-                    g['Targeted Elevation'].astype(float))]
-            for k, g in df.groupby('apinumber')}
-
-
+                    zip(g['x'].astype(float),
+                        g['y'].astype(float),
+                        g['spx'].astype(float),
+                        g['spy'].astype(float),
+                        g['true_elevation'].astype(float))]
+                for k, g in df.groupby('api_number')}
 
     def returnWellDataDependingOnParametersTest(self) -> None:
         """
@@ -921,14 +946,14 @@
         ) -> Tuple[pd.DataFrame, List[List[List[float]]], List[List[List[float]]]]:
 
             # Sort DataFrame by API number and measured depth
-            df = df.sort_values(by=['apinumber', 'measured_depth'])
+            df = df.sort_values(by=['api_number', 'measured_depth'])
 
             # Create index mapping for API numbers
-            api = df[['apinumber']].drop_duplicates().reset_index(drop=True)
+            api = df[['api_number']].drop_duplicates().reset_index(drop=True)
             api['index'] = api.index
 
             # Merge to maintain relationships
-            merged = pd.merge(api, df, left_on='apinumber', right_on='apinumber')
+            merged = pd.merge(api, df, left_on='api_number', right_on='apinumber')
 
             # Filter segments to match DataFrame wells
             segments = [segments[i] for i in range(len(segments)) if i in merged['index'].unique()]
@@ -1007,9 +1032,9 @@
             colors_lst = 'WellTypeColor' if column == 'CurrentWellType' else 'WellStatusColor'
 
             # Get first row for each API number to determine well properties
-            drilled_df_restricted = drilled_df.groupby('apinumber').first().reset_index()
-            planned_df_restricted = planned_df.groupby('apinumber').first().reset_index()
-            currently_drilling_df_restricted = currently_drilling_df.groupby('apinumber').first().reset_index()
+            drilled_df_restricted = drilled_df.groupby('api_number').first().reset_index()
+            planned_df_restricted = planned_df.groupby('api_number').first().reset_index()
+            currently_drilling_df_restricted = currently_drilling_df.groupby('api_number').first().reset_index()
 
             # Create masks for wells matching specified type/status
             drilled_well_mask = drilled_df_restricted[column] == type
@@ -1094,9 +1119,9 @@
             colors_lst = 'WellTypeColor' if column == 'CurrentWellType' else 'WellStatusColor'
 
             # Get first row for each API number to determine well properties
-            drilled_df_restricted = drilled_df.groupby('apinumber').first().reset_index()
-            planned_df_restricted = planned_df.groupby('apinumber').first().reset_index()
-            currently_drilling_df_restricted = currently_drilling_df.groupby('apinumber').first().reset_index()
+            drilled_df_restricted = drilled_df.groupby('api_number').first().reset_index()
+            planned_df_restricted = planned_df.groupby('api_number').first().reset_index()
+            currently_drilling_df_restricted = currently_drilling_df.groupby('api_number').first().reset_index()
 
             # Create masks for wells matching any specified type/status
             drilled_well_mask = drilled_df_restricted[column].isin(types)
@@ -1491,7 +1516,7 @@
         self.canvas3d.draw()
 
 
-class Drawer2:
+class Drawer3:
     def __init__(self, ui, used_df_dx, well_info_df):
         self.segment_properties = None
         self.df_wells = None
@@ -1507,6 +1532,7 @@
                 child = layout.takeAt(0)
                 if child.widget():
                     child.widget().deleteLater()
+
         self.ui = ui
         self.well_info_df = well_info_df
         self.surveys = used_df_dx
@@ -1631,7 +1657,6 @@
     #
     #         Example:
     #             >>> df_filtered, seg_2d, seg_3d = platBounded(well_df, segments_2d, segments_3d)
-    #             >>> print(f"Filtered to {len(seg_2d)} wells")
     #         """
     #         # Sort DataFrame by API number and measured depth
     #         df = df.sort_values(by=['apinumber', 'measured_depth'])
@@ -1689,7 +1714,6 @@
     #
     #         Example:
     #             >>> df, segs_2d, segs_3d, style_dict, style_df = setupData(wells_df, segments_2d, segments_3d)
-    #             >>> print(f"Styled {len(style_df)} well segments")
     #         """
     #         # Filter and align data using platBounded
     #         df, segments, segments_3d = platBounded(df, segments, segments_3d)
@@ -2261,21 +2285,20 @@
     def prepare_segments(self, used_df_dx, well_info_df):
         # Group data by api, citing_type, measured_depth, and drilling_status to form LineStrings
         grouped = used_df_dx.sort_values('measured_depth').groupby(
-            ['apinumber', 'citing_type'])
+            ['api_number', 'citing_type'])
 
         # Initialize a dictionary to hold segments and their properties per drilling status
         self.segments_per_drilling_status = {status: [] for status in self.drilling_styles.keys()}
         self.segment_properties = {status: [] for status in self.drilling_styles.keys()}
 
         for (api, citing_type), group in grouped:
-            used_info = well_info_df[well_info_df['well_id']==api]
+            used_info = well_info_df[well_info_df['api_number'] == api]
             used_group = group.sort_values('measured_depth')
             coords = list(zip(used_group['x'], used_group['y']))
             if len(coords) < 2:
                 continue  # Need at least two points to form a line
             line = LineString(coords)
             segment = list(line.coords)
-            print(segment)
             self.segments_per_drilling_status[citing_type].append(segment)
             #
             # # Assuming all points in a group have the same type and status
@@ -2301,34 +2324,28 @@
         #     # Store all properties for later filtering
         #     lc.segment_props = self.segment_properties[drilling_status]
 
-
-
-
-
-
     def draw_2d_data_all(self, well_info_df, used_df_dx):
-            # Create a default LineCollection for all wells
+        # Create a default LineCollection for all wells
         main_statuses = ['Plugged & Abandoned',
-                                    'Producing',
-                                    'Shut-in',
-                                    'Drilling']
+                         'Producing',
+                         'Shut-in',
+                         'Drilling']
         main_types = ['Unknown',
-                                 'Oil Well',
-                                 'Dry Hole',
-                                 'Gas Well',
-                                 'Test Well',
-                                 'Water Source Well']
-        other_statuses= ['Location Abandoned - APD rescinded',
-                                     'Returned APD (Unapproved)',
-                                     'Approved Permit',
-                                     'Active',
-                                     'Drilling Operations Suspended',
-                                     'New Permit',
-                                     'Inactive',
-                                     'Temporarily-abandoned',
-                                     'Test Well or Monitor Well']
+                      'Oil Well',
+                      'Dry Hole',
+                      'Gas Well',
+                      'Test Well',
+                      'Water Source Well']
+        other_statuses = ['Location Abandoned - APD rescinded',
+                          'Returned APD (Unapproved)',
+                          'Approved Permit',
+                          'Active',
+                          'Drilling Operations Suspended',
+                          'New Permit',
+                          'Inactive',
+                          'Temporarily-abandoned',
+                          'Test Well or Monitor Well']
 
-
         self.drilling_collections = {}
         for drilling_status, style in self.drilling_styles.items():
             lc = LineCollection([], linestyles=style['linestyle'], linewidths=1.5, zorder=2)
@@ -2383,7 +2400,6 @@
         # for i, group in enumerate(all_wells):
         #     citing_group = self.surveys.groupby('citing_type')
         #     for j in group2 in
-        #     print(group)
         # for idx, row in self.surveys.iterrows():
         #     line = row['geometry']
         #     coords = list(line.coords)
@@ -2403,6 +2419,7 @@
         # # Adjust plot limits
         # self.ax.autoscale()
         # self.canvas.draw()
+
     def manipulateTheDfDocketDataDependingOnCheckboxes(self):
         """
            Main function for managing well visualization based on UI checkbox states.
@@ -2491,14 +2508,14 @@
                 >>> print(f"Filtered to {len(seg_2d)} wells")
             """
             # Sort DataFrame by API number and measured depth
-            df = df.sort_values(by=['apinumber', 'measured_depth'])
+            df = df.sort_values(by=['api_number', 'measured_depth'])
 
             # Create index mapping for API numbers
-            api = df[['apinumber']].drop_duplicates().reset_index(drop=True)
+            api = df[['api_number']].drop_duplicates().reset_index(drop=True)
             api['index'] = api.index
 
             # Merge to maintain relationships
-            merged = pd.merge(api, df, left_on='apinumber', right_on='apinumber')
+            merged = pd.merge(api, df, left_on='api_number', right_on='api_number')
 
             # Filter segments to match DataFrame wells
             segments = [segments[i] for i in range(len(segments)) if i in merged['index'].unique()]
@@ -2613,9 +2630,9 @@
             colors_lst = 'WellTypeColor' if column == 'CurrentWellType' else 'WellStatusColor'
 
             # Get first row for each API number to determine well properties
-            drilled_df_restricted = drilled_df.groupby('apinumber').first().reset_index()
-            planned_df_restricted = planned_df.groupby('apinumber').first().reset_index()
-            currently_drilling_df_restricted = currently_drilling_df.groupby('apinumber').first().reset_index()
+            drilled_df_restricted = drilled_df.groupby('api_number').first().reset_index()
+            planned_df_restricted = planned_df.groupby('api_number').first().reset_index()
+            currently_drilling_df_restricted = currently_drilling_df.groupby('api_number').first().reset_index()
 
             # Create masks for wells matching specified type/status
             drilled_well_mask = drilled_df_restricted[column] == type
@@ -2700,9 +2717,9 @@
             colors_lst = 'WellTypeColor' if column == 'CurrentWellType' else 'WellStatusColor'
 
             # Get first row for each API number to determine well properties
-            drilled_df_restricted = drilled_df.groupby('apinumber').first().reset_index()
-            planned_df_restricted = planned_df.groupby('apinumber').first().reset_index()
-            currently_drilling_df_restricted = currently_drilling_df.groupby('apinumber').first().reset_index()
+            drilled_df_restricted = drilled_df.groupby('api_number').first().reset_index()
+            planned_df_restricted = planned_df.groupby('api_number').first().reset_index()
+            currently_drilling_df_restricted = currently_drilling_df.groupby('api_number').first().reset_index()
 
             # Create masks for wells matching any specified type/status
             drilled_well_mask = drilled_df_restricted[column].isin(types)
@@ -2936,10 +2953,6 @@
             if self.ui.other_well_status_check.isChecked():
                 wellCheckedMultiple(['Unknown', 'Test Well', 'Water Source Well'], 'CurrentWellType')
 
-            # Re-enable status checkbox signals
-            # for q in self.status_checks:
-            # q.blockSignals(False)
-
         def wellStatusEnable() -> NoReturn:
             """
             Enables well status filtering while temporarily disabling well type filters.
@@ -3012,10 +3025,6 @@
                                      'Active', 'Drilling Operations Suspended', 'New Permit', 'Inactive',
                                      'Temporarily-abandoned', 'Test Well or Monitor Well'], 'current_well_status')
 
-            # Re-enable type checkbox signals
-            # for q in self.type_checks:
-            #     q.blockSignals(False)
-
         # Reset current line tracking
         self.currently_used_lines = None
 
@@ -3161,4 +3170,183 @@
     #     #
     #     # # Refresh solo canvas and production graphic
     #     # self.canvas3d_solo.draw()
-    #     # self.drawProductionGraphic()
\ No newline at end of file
+    #     # self.drawProductionGraphic()
+
+
+# Define well type and status categories with associated styles
+WELL_TYPES = {
+    "Oil": {"color": "brown"},
+    "Gas": {"color": "green"},
+    "Dry": {"color": "black"},
+    "Injection": {"color": "blue"}
+}
+WELL_STATUSES = {
+    "Producing": {"width": 2.5},
+    "Shut-In": {"width": 1.0},
+    # Additional statuses can be added here (e.g., "Abandoned": {"width": 1.5})
+}
+
+
+class WellVisualizer(QWidget):
+    def __init__(self, wells_data):
+        super().__init__()
+        self.wells_data = wells_data  # list of well records (each a dict with type, status, path, name, etc.)
+        self._init_ui()
+        self._init_plot()
+        self.draw_wells()  # initial draw with default (all filters on)
+
+    def _init_ui(self):
+        """Set up the PyQt5 UI elements (checkboxes and canvas)."""
+        self.setWindowTitle("Well Visualization")
+        # Create group boxes for types and statuses for better organization in the UI
+        type_group = QGroupBox("Well Types")
+        status_group = QGroupBox("Well Status")
+        # Layouts for the groups
+        type_layout = QVBoxLayout()
+        status_layout = QVBoxLayout()
+        # Create checkboxes for each well type and status, checked by default
+        self.checkboxes_type = {}
+        for t in WELL_TYPES:
+            cb = QCheckBox(t)
+            cb.setChecked(True)
+            # Connect each type checkbox to update the plot when toggled
+            cb.toggled.connect(lambda checked, t=t: self._on_type_toggled(t, checked))
+            self.checkboxes_type[t] = cb
+            type_layout.addWidget(cb)
+        self.checkboxes_status = {}
+        for s in WELL_STATUSES:
+            cb = QCheckBox(s)
+            cb.setChecked(True)
+            # Connect each status checkbox to update the plot when toggled
+            cb.toggled.connect(lambda checked, s=s: self._on_status_toggled(s, checked))
+            self.checkboxes_status[s] = cb
+            status_layout.addWidget(cb)
+        # Checkbox for toggling well labels (names)
+        self.checkbox_labels = QCheckBox("Show Labels")
+        self.checkbox_labels.setChecked(True)
+        # Connect label checkbox to update plot (show/hide labels)
+        self.checkbox_labels.toggled.connect(self.draw_wells)
+
+        type_group.setLayout(type_layout)
+        status_group.setLayout(status_layout)
+        # Arrange all UI elements in the main layout
+        controls_layout = QHBoxLayout()
+        controls_layout.addWidget(type_group)
+        controls_layout.addWidget(status_group)
+        controls_layout.addWidget(self.checkbox_labels)
+        # Matplotlib canvas for plots
+        self.figure = Figure()
+        self.canvas = FigureCanvas(self.figure)
+        # Combine controls and canvas in a vertical layout
+        main_layout = QVBoxLayout()
+        main_layout.addLayout(controls_layout)
+        main_layout.addWidget(self.canvas)
+        self.setLayout(main_layout)
+
+    def _init_plot(self):
+        """Initialize the Matplotlib axes for 2D and 3D plots."""
+        # 2D axis (plan view) and 3D axis for well trajectories
+        self.ax2d = self.figure.add_subplot(1, 2, 1)  # one row, two columns, first plot
+        self.ax3d = self.figure.add_subplot(1, 2, 2, projection='3d')  # second plot as 3D
+        self.ax2d.set_title("Map View (2D)")
+        self.ax3d.set_title("Well Trajectories (3D)")
+        # Lists to hold label text artists (for easy removal toggling)
+        self.label_texts2d = []
+        self.label_texts3d = []
+
+    def _on_type_toggled(self, well_type, checked):
+        """Slot called when a well type checkbox is toggled."""
+        # (We could update internal state here if needed; for this implementation, we just redraw.)
+        self.draw_wells()
+
+    def _on_status_toggled(self, status, checked):
+        """Slot called when a well status checkbox is toggled."""
+        self.draw_wells()
+
+    def filter_allows(self, well):
+        """Check if a given well passes the current type/status filters."""
+        type_ok = self.checkboxes_type.get(well["type"], None)
+        status_ok = self.checkboxes_status.get(well["status"], None)
+        # Only show the well if its type and status checkboxes are checked
+        return (type_ok is not None and type_ok.isChecked()) and \
+            (status_ok is not None and status_ok.isChecked())
+
+    def style_for_well(self, well):
+        """Determine the plotting style (color, line width) for a well based on its type and status."""
+        well_type = well["type"]
+        well_status = well["status"]
+        color = WELL_TYPES.get(well_type, {}).get("color", "gray")  # default to gray if type not found
+        width = WELL_STATUSES.get(well_status, {}).get("width", 1.0)  # default line width 1.0 if status not found
+        return color, width
+
+    def draw_wells(self):
+        """Clear and redraw the 2D and 3D plots based on current filters and settings."""
+        # Clear previous plot content
+        self.ax2d.clear()
+        self.ax3d.clear()
+        self.ax2d.set_title("Map View (2D)")
+        self.ax3d.set_title("Well Trajectories (3D)")
+
+        # Remove any existing label texts from previous draw
+        for txt in self.label_texts2d:
+            txt.remove()
+        for txt in self.label_texts3d:
+            txt.remove()
+        self.label_texts2d.clear()
+        self.label_texts3d.clear()
+
+        # Prepare lists for LineCollection segments, colors, and widths
+        segments2d = []  # list of line segments for 2D
+        segments3d = []  # list of line segments for 3D
+        colors = []  # corresponding colors for each well segment
+        widths = []  # corresponding line widths for each well segment
+
+        # Gather data for wells that pass the filters
+        for well in self.wells_data:
+            if not self.filter_allows(well):
+                continue  # skip wells that don't match current filter selection
+            path = well["path"]  # well path is a list of (x, y, z) tuples
+            if len(path) < 2:
+                continue  # skip if not enough points to form a line
+            # Split path into separate coordinates for 2D and 3D usage
+            # 2D segment: list of (x, y) points
+            seg2d = [(pt[0], pt[1]) for pt in path]
+            segments2d.append(seg2d)
+            # 3D segment: list of (x, y, z) points (to be added as a 3D line)
+            segments3d.append(path)
+            # Determine style for this well
+            color, width = self.style_for_well(well)
+            colors.append(color)
+            widths.append(width)
+            # Add label at end of well (if labels toggled on)
+            if self.checkbox_labels.isChecked():
+                well_name = well.get("name", "")
+                # Place label near the last point of the well path (bottom hole or endpoint)
+                end_x, end_y, end_z = path[-1]
+                # Create text labels on both 2D and 3D plots
+                label2d = self.ax2d.text(end_x, end_y, well_name, fontsize=8, color=color)
+                label3d = self.ax3d.text(end_x, end_y, end_z, well_name, fontsize=8, color=color)
+                self.label_texts2d.append(label2d)
+                self.label_texts3d.append(label3d)
+
+        # Create and add the line collections for all filtered wells
+        if segments2d:
+            lc2d = LineCollection(segments2d, colors=colors, linewidths=widths)
+            self.ax2d.add_collection(lc2d)
+            # Adjust 2D view limits to fit the new collection
+            self.ax2d.relim()
+            self.ax2d.autoscale_view()
+        if segments3d:
+            lc3d = art3d.Line3DCollection(segments3d, colors=colors, linewidths=widths)
+            self.ax3d.add_collection(lc3d)
+            # Optionally, set 3D axis limits to encompass data (autoscale for 3D)
+            xs = [pt[0] for seg in segments3d for pt in seg]
+            ys = [pt[1] for seg in segments3d for pt in seg]
+            zs = [pt[2] for seg in segments3d for pt in seg]
+            if xs and ys and zs:  # set limits if lists are not empty
+                self.ax3d.set_xlim(min(xs), max(xs))
+                self.ax3d.set_ylim(min(ys), max(ys))
+                self.ax3d.set_zlim(min(zs), max(zs))
+
+        # Redraw the canvas to update the visuals
+        self.canvas.draw()
